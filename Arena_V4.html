<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chroma Core Arena — V4.1 (Stability Patch)</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

  <!-- Three.js import map -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
      }
    }
  </script>

  <style>
    body { margin: 0; padding: 0; background-color: #000; color: #fff; font-family: 'Orbitron', 'Consolas', monospace; overflow: hidden; }
    canvas { position: absolute; top: 0; left: 0; z-index: 1; }
    .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(5, 5, 10, 0.8); z-index: 200; transition: opacity 0.5s, visibility 0s 0.5s; opacity: 0; visibility: hidden; backdrop-filter: blur(10px); }
    .screen.active { opacity: 1; visibility: visible; transition-delay: 0s; }
    .panel { background: rgba(10, 20, 30, 0.7); border: 1px solid #00ffff; border-radius: 10px; padding: 40px; box-shadow: 0 0 25px rgba(0, 255, 255, 0.5); text-align: center; max-width: 90vw; width: 900px; }
    .menu-button { padding: 15px 40px; font-size: 1.2em; background-color: #111; border: 2px solid #fff; color: #fff; cursor: pointer; border-radius: 6px; transition: all 0.2s; font-family: 'Orbitron', sans-serif; margin: 8px; width: 350px; text-align: center; }
    .menu-button:hover:not(:disabled) { background-color: #fff; color: #000; box-shadow: 0 0 15px #fff; }
    .menu-button:disabled { cursor: not-allowed; opacity: 0.5; }
    input { padding: 12px; font-size: 1.1em; background-color: #111; border: 2px solid #fff; color: #fff; border-radius: 6px; width: 350px; margin: 6px auto; display: block; text-align: center; }
    #login-message, #leaderboard-message, #room-status { min-height: 20px; color: #00ffff; }
    #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 10; }
    .player-hud { position: absolute; bottom: 20px; display: flex; align-items: center; gap: 12px; background: rgba(10, 20, 30, 0.7); border-radius: 10px; padding: 10px; border: 1px solid #555; backdrop-filter: blur(5px); }
    #player1-hud { left: 20px; }
    #player2-hud { right: 20px; flex-direction: row-reverse; }
    .portrait-container { position: relative; width: 100px; height: 100px; }
    .portrait { width: 100%; height: 100%; border-radius: 50%; border: 3px solid; object-fit: cover; }
    .portrait-canvas { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 160px; height: 160px; z-index: -1; }
    .circular-bars svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: rotate(-90deg); }
    .bar-bg { fill: none; stroke: rgba(0,0,0,0.3); }
    .bar-fill { fill: none; transition: stroke-dashoffset 0.3s ease; }
    #p1-health-bar-fill, #p2-health-bar-fill { stroke: #0f0; }
    #p1-energy-bar-fill, #p2-energy-bar-fill { stroke: #ff0; }
    .hud-details { display: flex; flex-direction: column; }
    .skills-container { display: flex; gap: 8px; margin-bottom: 5px; }
    .skill { width: 45px; height: 45px; border: 2px solid #888; border-radius: 6px; position: relative; background-color: #222; display: flex; justify-content: center; align-items: center; font-size: 1.2em; font-weight: bold; }
    .skill.ready { border-color: #fff; box-shadow: 0 0 8px #fff; }
    .cooldown-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.85); color: white; display: flex; justify-content: center; align-items: center; font-size: 1.2em; font-weight: bold; pointer-events: none; opacity: 0; transition: opacity 0.1s; border-radius: 4px; }
    #game-message-container { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 4.5em; font-weight: 900; text-shadow: 0 0 20px #fff; z-index: 50; }
    .tabs { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin: 10px 0 16px; }
    .tab { padding: 8px 12px; border: 1px solid #888; border-radius: 6px; cursor: pointer; }
    .tab.active { border-color: #00ffff; color: #00ffff; box-shadow: 0 0 8px #00ffff; }
    #char-select-screen .panel { max-width: 95vw; width: 1500px; }
    .char-grid { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; width: 100%; margin-bottom: 20px; max-height: 60vh; overflow-y: auto; padding: 10px;}
    .char-card { width: 200px; height: 280px; border: 2px solid #555; border-radius: 10px; background: rgba(17,17,17,.85); padding: 10px; transition: all .2s; display: flex; flex-direction: column; justify-content: space-between; cursor: pointer; }
    .char-card:not(.locked-by-p1):not(.locked-by-p2):hover { border-color: #fff; box-shadow: 0 0 10px #fff; transform: translateY(-3px); }
    .char-portrait { width: 100%; height: 50%; border-radius: 5px; background-size: cover; background-position: center; }
    .char-card.locked-by-p1 { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; transform: scale(1.04); }
    .char-card.locked-by-p2 { border-color: #ff00ff; box-shadow: 0 0 15px #ff00ff; transform: scale(1.04); }
    .leaderboard-header, .leaderboard-row { display: flex; padding: 10px; }
    .leaderboard-header { font-weight: bold; color: #00ffff; border-bottom: 2px solid #00ffff; }
    .leaderboard-row { border-bottom: 1px solid #333; }
    .leaderboard-row:nth-child(odd) { background-color: rgba(0,0,0,0.2); }
    .rank { width: 15%; text-align: center; }
    .name { width: 60%; }
    .score { width: 25%; text-align: right; font-weight: bold; color: #fff; }
    #import-data-area { width: 90%; height: 60px; background-color: #111; color: #eee; border: 1px solid #888; border-radius: 5px; padding: 10px; font-family: 'Consolas', monospace; margin-bottom: 10px; }
  </style>
</head>
<body>
  <!-- LOGIN -->
  <div id="login-screen" class="screen active">
    <div class="panel">
      <h1 id="login-title">PLAYER LOGIN</h1>
      <input id="login-nickname" type="text" placeholder="NICKNAME (3-10 chars)" maxlength="10" minlength="3">
      <input id="login-password" type="password" placeholder="PASSWORD (min 4 chars)" minlength="4">
      <p id="login-message">&nbsp;</p>
      <div style="display:flex;justify-content:center;gap:18px">
        <button id="login-button" class="menu-button" style="width:200px;">LOGIN</button>
        <button id="signup-button" class="menu-button" style="width:200px;">SIGN UP</button>
      </div>
        <button id="guest-login-button" class="menu-button" style="width:200px; margin-top: 10px;">Play as Guest</button>
    </div>
  </div>

  <!-- START -->
  <div id="start-screen" class="screen">
    <div class="panel">
      <h1>CHROMA CORE ARENA</h1>
      <div class="tabs" id="mode-tabs">
        <div class="tab active" data-mode="LOCAL_CLASSIC">Local Classic Duel</div>
        <div class="tab" data-mode="LOCAL_RIFT">Local Rift Duel</div>
        <div class="tab" data-mode="ONLINE_CLASSIC">Online Classic Duel</div>
        <div class="tab" data-mode="ONLINE_RIFT">Online Rift Duel</div>
      </div>
      <button id="start-button" class="menu-button">START LOCAL DUEL</button>
      <button id="leaderboard-button" class="menu-button">LEADERBOARD</button>
      <button id="settings-button" class="menu-button">SETTINGS</button>

      <!-- Matchmaking UI -->
      <div id="online-controls" style="display:none;margin-top:14px">
        <button id="find-match-button" class="menu-button">Find Online Match</button>
        <button id="cancel-match-button" class="menu-button" style="display:none; background-color:#c00;">Cancel Search</button>
        <p id="room-status">&nbsp;</p>
      </div>
    </div>
  </div>

  <!-- LEADERBOARD -->
  <div id="leaderboard-screen" class="screen">
    <div class="panel" style="width: 900px;">
      <h1>LEADERBOARD</h1>
      <div class="tabs" id="lb-tabs">
        <div class="tab active" data-lb="LOCAL_CLASSIC">Local Classic</div>
        <div class="tab" data-lb="LOCAL_RIFT">Local Rift</div>
        <div class="tab" data-lb="ONLINE_CLASSIC">Online Classic</div>
        <div class="tab" data-lb="ONLINE_RIFT">Online Rift</div>
      </div>
      <div id="leaderboard-table"></div>
      <p id="leaderboard-message">&nbsp;</p>
      <div id="import-export-section" style="margin-top:20px;border-top:1px solid #00ffff;padding-top:12px">
        <textarea id="import-data-area" placeholder="Paste exported leaderboard snapshot JSON here (optional)…"></textarea>
        <div style="display:flex;gap:12px;justify-content:center">
          <button id="import-leaderboard-button" class="menu-button" style="width:auto;">Import Snapshot</button>
          <button id="export-leaderboard-button" class="menu-button" style="width:auto;">Export Snapshot</button>
        </div>
      </div>
      <button id="leaderboard-back-button" class="menu-button" style="margin-top: 16px;">BACK</button>
    </div>
  </div>

  <!-- SETTINGS -->
  <div id="settings-screen" class="screen">
    <div class="panel">
      <h1>SETTINGS</h1>
      <p style="margin-bottom: 25px;">Player controls for local multiplayer mode. Online mode uses Player 1 controls.</p>
      <div class="settings-container" style="display:flex;gap:50px;flex-wrap:wrap;justify-content:center">
        <div class="player-settings">
          <h2 style="color:#00ffff;">PLAYER 1 (WASD)</h2>
          <div>Forward: W</div><div>Backward: S</div><div>Left: A</div><div>Right: D</div>
          <div>Basic: Space</div><div>Skill1: Q</div><div>Skill2: E</div><div>Skill3: R</div>
        </div>
        <div class="player-settings">
          <h2 style="color:#ff00ff;">PLAYER 2 (IJKL)</h2>
          <div>Forward: I</div><div>Backward: K</div><div>Left: J</div><div>Right: L</div>
          <div>Basic: Enter</div><div>Skill1: U</div><div>Skill2: O</div><div>Skill3: P</div>
        </div>
      </div>
      <button id="settings-back-button" class="menu-button">BACK</button>
    </div>
  </div>

  <!-- CHAR SELECT -->
  <div id="char-select-screen" class="screen">
    <div class="panel">
      <h1>CHOOSE YOUR ECHO</h1>
      <div id="char-grid" class="char-grid"></div>
      <div id="char-select-footer">
        <p id="lock-in-status">Player 1: Click to select your Echo</p>
      </div>
    </div>
  </div>

  <!-- GAME OVER -->
  <div id="game-over-screen" class="screen">
    <div class="panel">
      <div id="winner-text" style="font-size: 2.4em; margin-bottom: 20px;"></div>
      <button id="restart-button" class="menu-button">RETURN TO MENU</button>
    </div>
  </div>

  <!-- HUD & Countdowns -->
  <div id="ui-container">
    <div id="player1-hud" class="player-hud"></div>
    <div id="player2-hud" class="player-hud"></div>
  </div>
  <div id="game-message-container"><span id="countdown-text"></span></div>

  <!-- Audio -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
    import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, updateProfile, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, updateDoc, collection, query, orderBy, limit, getDocs, serverTimestamp, onSnapshot, increment, where, deleteDoc, addDoc, writeBatch } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";

    /*
    * ======================================
    * V4.1 STABILITY & BALANCE PATCH
    * ======================================
    *
    * BUGFIX: Fixed room deletion race conditions in online mode
    * BUGFIX: Improved memory management and resource disposal
    * BUGFIX: Fixed HP sync issues in online matches
    * BUGFIX: Proper cleanup of event listeners on game end
    * BUGFIX: Fixed geometry disposal memory leaks
    * BUGFIX: Improved error handling throughout
    *
    * BALANCE:
    * - Normalized projectile speeds (15-25 range)
    * - Rift mode energy regen: 25/s -> 15/s (total 20/s with base)
    * - Reduced base energy regen: 5/s -> 5/s (kept same)
    * - Echo Prime: Phase Shift CD 4s -> 5s
    * - Tempest: Ball Lightning damage 15 -> 12
    * - Vortex: Event Horizon damage 40 -> 35
    * - Oracle: Empower duration 4s -> 6s
    * - Catalyst: Caustic Blast cost 25 -> 20
    * - Improved ultimate ability balance
    */

    /********** Firebase Init **********/
    const firebaseConfig = {
      apiKey: "AIzaSyCuBgpaWTxOxpFLxe7GfQY8UytWb3LkpvY",
      authDomain: "chroma-core-arena.firebaseapp.com",
      projectId: "chroma-core-arena",
      storageBucket: "chroma-core-arena.firebasestorage.app",
      messagingSenderId: "314470360799",
      appId: "1:314470360799:web:55cfee1b216fcf51072b6a"
    };
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    window.CCA = window.CCA || {};
    CCA.firebase = { auth, db, serverTimestamp, doc, setDoc, getDoc, updateDoc, collection, query, orderBy, limit, getDocs, onSnapshot, increment, addDoc, deleteDoc, writeBatch };
    const $$ = id => document.getElementById(id);

    const MODES = {
      LOCAL_CLASSIC:  { key:'LOCAL_CLASSIC',  rift:false },
      LOCAL_RIFT:     { key:'LOCAL_RIFT',     rift:true  },
      ONLINE_CLASSIC: { key:'ONLINE_CLASSIC', rift:false },
      ONLINE_RIFT:    { key:'ONLINE_RIFT',    rift:true  }
    };
    CCA.MODES = MODES;
    let currentMode = MODES.LOCAL_CLASSIC;
    let isOnline = false;

    function sanitizeNick(n){ return (n||'').toLowerCase().replace(/[^a-z0-9]/g,'').slice(0,30); }
    function emailFromNick(n){ return `${sanitizeNick(n)}@chroma.local`; }

    async function signupNickname(nick, pass){
      const email = emailFromNick(nick);
      const cred = await createUserWithEmailAndPassword(auth, email, pass);
      await updateProfile(cred.user, { displayName: nick });
      await setDoc(doc(db, "users", cred.user.uid), {
        nickname: nick,
        createdAt: serverTimestamp(),
        wins: { LOCAL_CLASSIC:0, LOCAL_RIFT:0, ONLINE_CLASSIC:0, ONLINE_RIFT:0 }
      }, { merge:true });
      return cred.user;
    }
    async function loginNickname(nick, pass){
      const email = emailFromNick(nick);
      const cred  = await signInWithEmailAndPassword(auth, email, pass);
      if(!cred.user.displayName){ await updateProfile(cred.user, { displayName: nick }); }
      return cred.user;
    }
    function explainAuthError(e){
      $$('login-message').textContent = e?.message || 'Authentication failed.';
    }

    async function addWin(uid, modeKey){
      try {
        const userRef = doc(db, "users", uid);
        await updateDoc(userRef, { [`wins.${modeKey}`]: increment(1) });
        const snap = await getDoc(userRef);
        const nickname = snap.data()?.nickname || 'Guest';
        const lbRef = doc(db, "leaderboards", modeKey, "scores", uid);
        await setDoc(lbRef, { nickname, wins: increment(1), updatedAt: serverTimestamp() }, { merge: true });
      } catch (e) {
        console.error(`Failed to add win for user ${uid} in mode ${modeKey}:`, e);
      }
    }
    async function fetchLeaderboard(modeKey, topN=50){
      const q = query(collection(db, "leaderboards", modeKey, "scores"), orderBy("wins","desc"), limit(topN));
      const snap = await getDocs(q);
      return snap.docs.map((d,i)=>({ rank:i+1, name:d.data().nickname, wins:d.data().wins }));
    }
    CCA.lb = { addWin, fetchLeaderboard };

    const ROOMS = collection(db, 'rooms');
    const QUEUE = collection(db, 'matchmaking');
    let queueDocId = null;
    let eventsListenerUnsub = null;

    async function findMatch(modeKey) {
      try {
        if (!auth.currentUser) {
            $$('room-status').textContent = 'Error: You must be logged in to find a match.';
            return;
        }
        const userId = auth.currentUser.uid;
        const userNick = auth.currentUser.displayName || 'Guest';
        $$('find-match-button').disabled = true;
        $$('cancel-match-button').style.display = 'inline-block';
        $$('room-status').textContent = 'Searching for an opponent...';

        const q = query(QUEUE, where("mode", "==", modeKey), where("hostId", "!=", userId), limit(1));
        const snap = await getDocs(q);

        if (snap.empty) {
            const newQueueDoc = await addDoc(QUEUE, {
                mode: modeKey,
                hostId: userId,
                hostNick: userNick,
                createdAt: serverTimestamp()
            });
            queueDocId = newQueueDoc.id;
            online.isHost = true;
            $$('room-status').textContent = 'Waiting for an opponent...';
            listenQueueDoc(queueDocId);
        } else {
            const openQueueDoc = snap.docs[0];
            queueDocId = openQueueDoc.id;
            online.isHost = false;
            
            const newRoom = await addDoc(ROOMS, {
                mode: modeKey,
                createdAt: serverTimestamp(),
                host: { id: openQueueDoc.data().hostId, nick: openQueueDoc.data().hostNick, charKey: null },
                guest: { id: userId, nick: userNick, charKey: null },
                state: { p1CharKey: null, p2CharKey: null, started: false, winner: null }
            });

            await updateDoc(doc(QUEUE, queueDocId), { roomId: newRoom.id, guestId: userId });
            online.code = newRoom.id;
            wireRoomListener();
        }
      } catch (e) {
        console.error("Matchmaking Error:", e);
        $$('room-status').textContent = 'Error: Could not search. Check Firebase permissions.';
        $$('find-match-button').disabled = false;
        $$('cancel-match-button').style.display = 'none';
      }
    }
    
    function listenQueueDoc(id) {
        if(online.unsub) online.unsub();
        online.unsub = onSnapshot(doc(QUEUE, id), async (docSnap) => {
            if (docSnap.exists() && docSnap.data().roomId) {
                online.code = docSnap.data().roomId;
                if(online.unsub) online.unsub(); 
                online.unsub = null;
                await deleteDoc(doc(QUEUE, id)); 
                queueDocId = null;
                wireRoomListener();
            }
        });
    }

    async function cancelMatchmaking() {
        if(online.unsub) online.unsub();
        online.unsub = null;
        if(queueDocId) {
            await deleteDoc(doc(QUEUE, queueDocId));
            queueDocId = null;
        }
        $$('find-match-button').disabled = false;
        $$('cancel-match-button').style.display = 'none';
        $$('room-status').textContent = '';
    }

    function listenRoom(code, cb){ return onSnapshot(doc(ROOMS, code), snap => cb(snap.exists()?snap.data():null)); }
    async function setStarted(code){ await updateDoc(doc(ROOMS, code), { 'state.started': true }); }
    
    async function pushState(code, isHost, payload) {
        const pathPrefix = isHost ? 'state.p1' : 'state.p2';
        const updates = {};
        Object.keys(payload).forEach(key => {
            updates[`${pathPrefix}.${key}`] = payload[key];
        });
        if (Object.keys(updates).length > 0) {
           try {
             await updateDoc(doc(ROOMS, code), updates);
           } catch (e) {
             console.error("Error pushing state:", e);
           }
        }
    }

    async function pushSkillEvent(skillKey) {
        if (!isOnline || !online.code) return;
        try {
            const eventCollection = collection(db, 'rooms', online.code, 'events');
            await addDoc(eventCollection, {
                by: online.isHost ? 'host' : 'guest',
                key: skillKey,
                timestamp: serverTimestamp()
            });
        } catch (e) {
            console.error("Failed to push skill event:", e);
        }
    }
    window.pushSkillEvent = pushSkillEvent;

    function wireEventsListener() {
        if (eventsListenerUnsub) eventsListenerUnsub();

        const eventCollection = collection(db, 'rooms', online.code, 'events');
        const myIdentifier = online.isHost ? 'host' : 'guest';

        eventsListenerUnsub = onSnapshot(eventCollection, (snapshot) => {
            const batch = writeBatch(db);
            let changesProcessed = 0;
            snapshot.docChanges().forEach(change => {
                if (change.type === 'added') {
                    const event = change.data();
                    if (event.by && event.by !== myIdentifier && event.key) {
                        const opponent = online.isHost ? window.players?.[1] : window.players?.[0];
                        if (opponent && typeof opponent.useSkillRemote === 'function') {
                            console.log(`Received skill event: ${event.key} from opponent`);
                            opponent.useSkillRemote(event.key);
                        } else {
                            console.warn("Opponent or useSkillRemote not found for event:", event);
                        }
                    } else if (!event.key) {
                        console.warn("Received event without key:", event);
                    }
                    batch.delete(change.doc.ref);
                    changesProcessed++;
                }
            });
            if (changesProcessed > 0) {
                batch.commit().catch(e => console.error("Failed to clear events:", e));
            }
        }, (error) => {
            console.error("Error in events listener:", error);
        });
        console.log("Events listener wired for room:", online.code);
    }

    async function setWinner(code, winner){ await updateDoc(doc(ROOMS, code), { 'state.winner': winner }); }
    async function selectCharacterOnline(code, isHost, charKey) {
        const path = isHost ? 'state.p1CharKey' : 'state.p2CharKey';
        await updateDoc(doc(ROOMS, code), { [path]: charKey });
    }
    CCA.online = { listenRoom, setStarted, pushState, setWinner, selectCharacterOnline };

    let gameState = 'LOGIN_SCREEN';
    let loggedInUser = null; 
    CCA.flow = { get gameState(){ return gameState; }, set gameState(v){ gameState=v; } };
    CCA.playersMeta = { get loggedInUser(){ return loggedInUser; } };

    function switchScreen(id){ document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active')); if(id) document.getElementById(id).classList.add('active'); }

    const modeTabs = document.querySelectorAll('#mode-tabs .tab');
    modeTabs.forEach(t => t.addEventListener('click', ()=>{
      modeTabs.forEach(x=>x.classList.remove('active')); t.classList.add('active');
      currentMode = MODES[t.dataset.mode];
      isOnline = (currentMode===MODES.ONLINE_CLASSIC || currentMode===MODES.ONLINE_RIFT);
      $$('online-controls').style.display = isOnline ? 'block' : 'none';
      $$('start-button').style.display = isOnline ? 'none' : 'inline-block';
    }));

    const lbTabs = document.querySelectorAll('#lb-tabs .tab');
    lbTabs.forEach(t => t.addEventListener('click', ()=>{
      lbTabs.forEach(x=>x.classList.remove('active')); t.classList.add('active');
      loadLeaderboard(t.dataset.lb);
    }));

    async function loadLeaderboard(modeKey){
        const table = $$('leaderboard-table');
        table.innerHTML = `
            <div class="leaderboard-header">
            <div class="rank">RANK</div><div class="name">NICKNAME</div><div class="score">WINS</div>
            </div>`;
        const rows = await CCA.lb.fetchLeaderboard(modeKey).catch(e=>{ console.error('LB err', e); return []; });
        if(rows.length===0){
            table.innerHTML += '<div class="leaderboard-row"><div class="name" style="width:100%;text-align:center;">No games played yet.</div></div>';
        }else{
            rows.forEach(r=>{
            const row = document.createElement('div'); row.className='leaderboard-row';
            row.innerHTML = `<div class="rank">#${r.rank}</div><div class="name">${r.name}</div><div class="score">${r.wins}</div>`;
            table.appendChild(row);
            });
        }
    }
    
    $$('start-button').addEventListener('click', ()=>{
      if(!isOnline){
        window.loggedInUsers = { p1: 'Player 1', p2: 'Player 2' };
        CCA.flow.gameState='CHAR_SELECT'; switchScreen('char-select-screen'); window.setupCharSelect(null);
      }
    });
    $$('leaderboard-button').addEventListener('click', ()=>{ CCA.flow.gameState='LEADERBOARD'; switchScreen('leaderboard-screen'); loadLeaderboard('LOCAL_CLASSIC'); });
    $$('leaderboard-back-button').addEventListener('click', ()=>{ CCA.flow.gameState='START_SCREEN'; switchScreen('start-screen'); });
    $$('settings-button').addEventListener('click', ()=>{ CCA.flow.gameState='SETTINGS'; switchScreen('settings-screen'); });
    $$('settings-back-button').addEventListener('click', ()=>{ CCA.flow.gameState='START_SCREEN'; switchScreen('start-screen'); });

    let online = { code:null, isHost:false, unsub:null, ready:false };
    $$('find-match-button').addEventListener('click', () => findMatch(currentMode.key));
    $$('cancel-match-button').addEventListener('click', cancelMatchmaking);

    function wireRoomListener(){
      if(online.unsub) online.unsub();
      console.log("Wiring room listener for room:", online.code);
      online.unsub = listenRoom(online.code, (room)=>{
        if(!room) {
             console.log("Room data is null, detaching listener for:", online.code);
             if (online.unsub) online.unsub();
             online.unsub = null;
             if(CCA.flow.gameState !== 'START_SCREEN' && CCA.flow.gameState !== 'LOGIN_SCREEN' && CCA.flow.gameState !== 'GAME_OVER') {
                console.error("Room connection lost. Returning to main menu."); 
                const statusElement = $$('room-status') || $$('login-message');
                if (statusElement) {
                    statusElement.textContent = "Room connection lost. Returning to menu...";
                }
                setTimeout(() => resetGame(true), 1500);
             }
             return;
        }
        console.log("Received room update:", room);

        if (CCA.flow.gameState === 'CHAR_SELECT') {
            window.setupCharSelect(room.state);
        }
        
        if(room.host.id && room.guest.id && !room.state.started && CCA.flow.gameState!=='CHAR_SELECT'){
          console.log("Both players joined, moving to char select");
          window.loggedInUsers = { p1: room.host.nick, p2: room.guest.nick };
          CCA.flow.gameState='CHAR_SELECT'; switchScreen('char-select-screen'); window.setupCharSelect(room.state);
        }
        
        if (room.state.p1CharKey && room.state.p2CharKey && CCA.flow.gameState === 'CHAR_SELECT') {
            console.log("Both players locked in, starting game and wiring events listener");
            wireEventsListener();
            window.startGame(room.state.p1CharKey, room.state.p2CharKey);
        }

        if(CCA.flow.gameState==='ACTIVE' && room.state.started){
          const oppState = online.isHost ? room.state.p2 : room.state.p1;
          const opp = online.isHost ? window.players?.[1] : window.players?.[0];
          if(opp && oppState){
            if(oppState.pos){
              opp.networkTargetPosition.set(oppState.pos.x, oppState.pos.y, oppState.pos.z);
            }
            if (typeof oppState.energy !== 'undefined') opp.energy = oppState.energy;
            
            if (typeof oppState.hp !== 'undefined' && opp.hp !== oppState.hp) {
                console.log(`Opponent HP updated via network: ${opp.hp} -> ${oppState.hp}`);
                opp.hp = oppState.hp;
                if (opp.hp <= 0 && !opp.isDead) {
                    opp.die();
                }
            }
          }

          const meState = online.isHost ? room.state.p1 : room.state.p2;
          const me = online.isHost ? window.players?.[0] : window.players?.[1];
          if(me && meState && !me.isDead) {
              if (typeof meState.hp !== 'undefined' && me.hp !== meState.hp) {
                  console.log(`My HP updated via network: ${me.hp} -> ${meState.hp}`);
                  me.hp = meState.hp;
                  if (me.hp <= 0) {
                      me.die();
                  }
              }
          }
        }
        if(room.state.winner && CCA.flow.gameState!=='GAME_OVER'){ 
            console.log("Winner declared via network:", room.state.winner);
            window.endGame(room.state.winner); 
        }
      }, (error) => {
          console.error("Error in room listener:", error);
          if (CCA.flow.gameState !== 'START_SCREEN' && CCA.flow.gameState !== 'LOGIN_SCREEN') {
             console.error("Error connecting to room. Returning to main menu.");
             const statusElement = $$('room-status') || $$('login-message');
             if (statusElement) {
                 statusElement.textContent = "Error connecting to room. Returning to menu...";
             }
             setTimeout(() => resetGame(true), 1500);
          }
      });
    }

    setInterval(()=>{
      if(!isOnline || CCA.flow.gameState!=='ACTIVE' || !online.code) return;
      const me = online.isHost ? window.players?.[0] : window.players?.[1];
      if(!me || me.isDead) return;
      pushState(online.code, online.isHost, {
        pos:{ x:me.mesh.position.x, y:me.mesh.position.y, z:me.mesh.position.z },
        energy: me.energy
      }).catch(()=>{});
    }, 100);

    $$('signup-button').addEventListener('click', async ()=>{
      const nick = ($$('login-nickname')?.value||'').trim(), pass = ($$('login-password')?.value||'').trim();
      if(nick.length<3 || pass.length<4){ $$('login-message').textContent='Invalid nickname or password.'; return; }
      try{
        await signupNickname(nick, pass);
        await loginNickname(nick, pass);
        handleSuccessfulLogin();
      }catch(e){ explainAuthError(e); }
    });
    $$('login-button').addEventListener('click', async ()=>{
      const nick = ($$('login-nickname')?.value||'').trim(), pass = ($$('login-password')?.value||'').trim();
      if(!nick||!pass){ $$('login-message').textContent='Enter nickname and password.'; return; }
      try{
        await loginNickname(nick, pass);
        handleSuccessfulLogin();
      }catch(e){ explainAuthError(e); }
    });
    $$('guest-login-button').addEventListener('click', async () => {
        try {
            const userCred = await signInAnonymously(auth);
            const guestName = `Guest${Math.floor(Math.random()*1000)}`;
            await updateProfile(userCred.user, { displayName: guestName });
            await setDoc(doc(db, "users", userCred.user.uid), {
                nickname: guestName,
                createdAt: serverTimestamp(),
                wins: { LOCAL_CLASSIC:0, LOCAL_RIFT:0, ONLINE_CLASSIC:0, ONLINE_RIFT:0 }
            }, { merge:true });
            handleSuccessfulLogin();
        } catch(e) { explainAuthError(e); }
    });

    function handleSuccessfulLogin(){
      loggedInUser = auth.currentUser;
      CCA.flow.gameState='START_SCREEN';
      switchScreen('start-screen');
    }

    window.mode = { get current(){ return currentMode; }, get isOnline(){ return isOnline; }, onlineState: online };
    window.switchScreen = switchScreen;
    window.addWin = addWin;
    window.firebaseAuth = auth;
    
    document.body.addEventListener('click', async () => {
        if(window.audioInitialized) return;
        window.audioInitialized = true;
        if (Tone.context.state !== 'running') {
            await Tone.start().catch(e => {
                console.warn("Tone.js worklet failed to load, audio might be limited.", e);
            });
        }
        window.initSounds();
    }, { once: true });

    /********** Constants & structures **********/
    window.loggedInUsers = { p1: 'Player 1', p2: 'Player 2' };

    const controls = { p1: { forward: 'w', backward: 's', left: 'a', right: 'd', basicAttack: ' ', skill1: 'q', skill2: 'e', skill3: 'r' }, p2: { forward: 'i', backward: 'k', left: 'j', right: 'l', basicAttack: 'enter', skill1: 'u', skill2: 'o', skill3: 'p' } };
    const keys = {};
    
    const particleTexture = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABGklEQVRYR+2VwQ2DMAxFr9sN2IAt2A3YgG3YDbpBG7QbsAGb4A17Q1JISklK/4mH/2mSb49fEuA/AhzwCMiAHfC8vYICuAI2Z4bCzcCFBoDd0hMgoA+gUWgZAFVoeQLoFGp+Bugu1LwAej9UfA96PxQ8D/pAFDwP+kAUfA/6QBT8DhpAFHwO2kAUfAqaQBR8CphAFHwJmkAUfAqaQBR8CphAFHwJmkAUfAqaQBR8CphAFHwJmkAUfApqgSi4FNQAqfAqqAFT4FVQAzV4FXwCarwKvgaqwCvwHFSBK/AgqgZX4EVQDC/AiqAaW4CVQDazAS6AaWIFbYBZYgVtgFVgBL/AGrAALeAO2YAH+AF9jAUkP/AnrAAAAAElFTkSuQmCC');

    const CHARACTERS = {
      ECHO_PRIME: { name: "Echo Prime", hp: 100, speed: 8, color: 0x00ffff, attackType: 'RANGED', skills: { s1: {name:"Power Shot", cost: 25, cd: 4}, s2: {name:"Phase Shift", cost: 30, cd: 5}, s3: {name:"Static Field", cost: 50, cd: 12} } },
      AEGIS: { name: "Aegis", hp: 140, speed: 6, color: 0xffa500, attackType: 'MELEE', skills: { s1: {name:"Aegis Charge", cost: 20, cd: 5}, s2: {name:"Energy Shield", cost: 40, cd: 8}, s3: {name:"Overload", cost: 100, cd: 15} } },
      SPECTRE: { name: "Spectre", hp: 85, speed: 10, color: 0x9400d3, attackType: 'MELEE', skills: { s1: {name:"Venom Blade", cost: 15, cd: 4}, s2: {name:"Blink", cost: 25, cd: 5}, s3: {name:"Cloak", cost: 60, cd: 12} } },
      JAVELIN: { name: "Javelin", hp: 90, speed: 7, color: 0x32cd32, attackType: 'RANGED', skills: { s1: {name:"Targeting Array", cost: 30, cd: 10}, s2: {name:"Slowing Mine", cost: 40, cd: 10}, s3: {name:"Laser Core", cost: 80, cd: 18} } },
      TEMPEST: { name: "Tempest", hp: 100, speed: 8, color: 0x1e90ff, attackType: 'RANGED', skills: { s1: {name:"Static Orb", cost: 25, cd: 6}, s2: {name:"Ball Lightning", cost: 50, cd: 12}, s3: {name:"Eye of the Storm", cost: 70, cd: 20} } },
      GLITCH: { name: "Glitch", hp: 100, speed: 8, color: 0xf0e68c, attackType: 'RANGED', skills: { s1: {name:"Corruption", cost: 30, cd: 8}, s2: {name:"Rewind", cost: 40, cd: 10}, s3: {name:"Swap", cost: 60, cd: 20} } },
      COLOSSUS: { name: "Colossus", hp: 140, speed: 6.5, color: 0xdc143c, attackType: 'MELEE', skills: { s1: {name:"Decimate", cost: 20, cd: 3}, s2: {name:"Tectonic Slam", cost: 30, cd: 7}, s3: {name:"Unstoppable Force", cost: 80, cd: 20} } },
      CHRONOMANCER: { name: "Chronomancer", hp: 95, speed: 8, color: 0x40e0d0, attackType: 'RANGED', skills: { s1: {name:"Temporal Anomaly", cost: 35, cd: 9}, s2: {name:"Stasis Field", cost: 40, cd: 12}, s3: {name:"Chrono Prison", cost: 75, cd: 18} } },
      ORACLE: { name: "Oracle", hp: 110, speed: 7, color: 0xffffff, attackType: 'RANGED', skills: { s1: {name:"Empower", cost: 25, cd: 12}, s2: {name:"Sentry Turret", cost: 40, cd: 10}, s3: {name:"Bastion Protocol", cost: 60, cd: 18} } },
      ZEPHYR: { name: "Zephyr", hp: 85, speed: 11, color: 0x90ee90, attackType: 'RANGED', skills: { s1: {name:"Tailwind", cost: 20, cd: 8}, s2: {name:"Wind Wall", cost: 40, cd: 10}, s3: {name:"Cyclone", cost: 70, cd: 15} } },
      NULL: { name: "Null", hp: 100, speed: 8.5, color: 0xa020f0, attackType: 'RANGED', skills: { s1: {name:"Feedback Loop", cost: 30, cd: 7}, s2: {name:"Silence", cost: 40, cd: 12}, s3: {name:"Spell Shield", cost: 30, cd: 15} } },
      VORTEX: { name: "Vortex", hp: 100, speed: 7.5, color: 0x6a0dad, attackType: 'RANGED', skills: { s1: {name:"Singularity", cost: 30, cd: 8}, s2: {name:"Gravity Well", cost: 40, cd: 12}, s3: {name:"Event Horizon", cost: 80, cd: 20} } },
      MIRAGE: { name: "Mirage", hp: 80, speed: 9.5, color: 0xc0c0c0, attackType: 'MELEE', skills: { s1: {name:"Doppelganger", cost: 35, cd: 10}, s2: {name:"Shimmer", cost: 25, cd: 7}, s3: {name:"Hallucinate", cost: 70, cd: 18} } },
      FORGE: { name: "Forge", hp: 120, speed: 6.5, color: 0xcd7f32, attackType: 'MELEE', skills: { s1: {name:"Build Turret", cost: 40, cd: 10}, s2: {name:"Barrier Wall", cost: 30, cd: 12}, s3: {name:"Siege Mode", cost: 60, cd: 16} } },
      CATALYST: { name: "Catalyst", hp: 90, speed: 8, color: 0x00ff7f, attackType: 'RANGED', skills: { s1: {name:"Caustic Blast", cost: 20, cd: 5}, s2: {name:"Adrenal Haze", cost: 45, cd: 14}, s3: {name:"Chain Reaction", cost: 75, cd: 19} } },
      RONIN: { name: "Ronin", hp: 85, speed: 10.5, color: 0xff4500, attackType: 'MELEE', skills: { s1: {name:"Iaijutsu Dash", cost: 20, cd: 4}, s2: {name:"Parry Stance", cost: 30, cd: 9}, s3: {name:"Blade Fury", cost: 65, cd: 15} } }
    };
    const charKeys = Object.keys(CHARACTERS);
    
    const SKILL_ICONS = {
        basicAttack: 'ATK',
        "Power Shot": 'PS', "Phase Shift": 'SH', "Static Field": 'SF',
        "Aegis Charge": 'AC', "Energy Shield": 'ES', "Overload": 'OV',
        "Venom Blade": 'VB', "Blink": 'BL', "Cloak": 'CL',
        "Targeting Array": 'TA', "Slowing Mine": 'SM', "Laser Core": 'LC',
        "Static Orb": 'SO', "Ball Lightning": 'BL', "Eye of the Storm": 'ES',
        "Corruption": 'CR', "Rewind": 'RW', "Swap": 'SW',
        "Decimate": 'DC', "Tectonic Slam": 'TS', "Unstoppable Force": 'UF',
        "Temporal Anomaly": 'TA', "Stasis Field": 'SF', "Chrono Prison": 'CP',
        "Empower": 'EM', "Sentry Turret": 'ST', "Bastion Protocol": 'BP',
        "Tailwind": 'TW', "Wind Wall": 'WW', "Cyclone": 'CY',
        "Feedback Loop": 'FL', "Silence": 'SL', "Spell Shield": 'SS',
        "Singularity": 'SI', "Gravity Well": 'GW', "Event Horizon": 'EH',
        "Doppelganger": 'DG', "Shimmer": 'SH', "Hallucinate": 'HL',
        "Build Turret": 'BT', "Barrier Wall": 'BW', "Siege Mode": 'SM',
        "Caustic Blast": 'CB', "Adrenal Haze": 'AH', "Chain Reaction": 'CR',
        "Iaijutsu Dash": 'ID', "Parry Stance": 'PS', "Blade Fury": 'BF',
    };

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x000000, 0);
    renderer.shadowMap.enabled = true;
    document.body.insertBefore(renderer.domElement, document.body.firstChild);
    const clock = new THREE.Clock();
    const arenaSize = 45;
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
    dirLight.position.set(-15, 20, 10);
    dirLight.castShadow = true;
    scene.add(dirLight);
    scene.add(new THREE.GridHelper(arenaSize, arenaSize, 0x00ffff, 0x333333));
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(arenaSize, arenaSize), new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 }));
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);
    const obstacles = [];
    const pylonGeo = new THREE.CylinderGeometry(1,1,6,8);
    const pylonMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.3 });
    [new THREE.Vector3(10,3,10), new THREE.Vector3(-10,3,-10), new THREE.Vector3(10,3,-10), new THREE.Vector3(-10,3,10), new THREE.Vector3(0,3,0)]
    .forEach(pos => { const pylon = new THREE.Mesh(pylonGeo, pylonMat); pylon.position.copy(pos); pylon.castShadow = true; pylon.receiveShadow = true; scene.add(pylon); const box = new THREE.Box3().setFromObject(pylon); box.isPylon=true; obstacles.push(box); });

    // Sound setup
    let audioReady = false;
    let sounds = {};
    window.initSounds = () => {
        sounds = {
          shoot: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(),
          hit: new Tone.PolySynth(Tone.MembraneSynth, { pitchDecay: 0.1, octaves: 4, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination(),
          death: new Tone.PolySynth(Tone.MetalSynth, { frequency: 50, envelope: { attack: 0.01, decay: 1, release: 0.5 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination(),
          shield: new Tone.PolySynth(Tone.NoiseSynth, { noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 } }).toDestination(),
          teleport: new Tone.PolySynth(Tone.PluckSynth, { attackNoise: 1, dampening: 4000, resonance: 0.7 }).toDestination(),
          laser: new Tone.PolySynth(Tone.FMSynth, { harmonicity: 1.2, modulationIndex: 10, envelope: { attack: 0.01, decay: 1, sustain: 0.1, release: 0.2 } }).toDestination(),
          explosion: new Tone.PolySynth(Tone.MembraneSynth, { pitchDecay: 0.5, octaves: 10, envelope: { attack: 0.01, decay: 0.8, sustain: 0 } }).toDestination(),
          charge: new Tone.PolySynth(Tone.FMSynth, { harmonicity: 0.5, modulationIndex: 10, envelope: { attack: 0.2, decay: 0.3, sustain: 0.1, release: 0.1 } }).toDestination(),
        };
        sounds.shoot.volume.value = -12;
        sounds.hit.volume.value = -6;
        sounds.teleport.volume.value = -6;
        audioReady = true;
    };

    // Game lists
    window.players = [];
    let projectiles = [];
    let specialObjects = [];
    let p1Select=-1, p2Select=-1, p1Locked=false, p2Locked=false;
    
    // HUD 3D Portrait Renderers
    let hudScenes = { p1: null, p2: null };
    let hudCameras = { p1: null, p2: null };
    let hudModels = { p1: null, p2: null };

    // HUD functions
    function buildPlayerHUD(playerNum, character){
        const hud = document.getElementById(`player${playerNum}-hud`);
        hud.className='player-hud';
        hud.style.borderColor = `#${new THREE.Color(character.color).getHexString()}`;
        const playerName = window.loggedInUsers[`p${playerNum}`] || `Player ${playerNum}`;
        const sk = character.skills;

        const hudScene = new THREE.Scene();
        hudScene.background = new THREE.Color(0x112233);
        const hudCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
        hudCamera.position.set(0, 2.5, 4.5);
        hudCamera.lookAt(0, 2, 0);
        hudScene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const hudLight = new THREE.DirectionalLight(0xffffff, 1);
        hudLight.position.set(1, 1, 1);
        hudScene.add(hudLight);
        
        const hudModel = createCharacterModel(character, false);
        hudModel.position.set(0, 0, 0);
        hudScene.add(hudModel);

        const canvas = document.createElement('canvas');
        canvas.className = 'portrait-canvas';
        
        hudScenes[`p${playerNum}`] = hudScene;
        hudCameras[`p${playerNum}`] = hudCamera;
        hudModels[`p${playerNum}`] = hudModel;

        hud.innerHTML = `
            <div class="portrait-container">
                <svg viewBox="0 0 36 36" class="circular-bars">
                    <path class="bar-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.83 a 15.9155 15.9155 0 0 1 0 -31.83" stroke-width="3" />
                    <path class="bar-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.83 a 15.9155 15.9155 0 0 1 0 -31.83" stroke-width="3" transform="scale(0.8) translate(4.5, 4.5)" />
                    <path id="p${playerNum}-health-bar-fill" class="bar-fill" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.83 a 15.9155 15.9155 0 0 1 0 -31.83" stroke-width="3" stroke-dasharray="100, 100" stroke-dashoffset="0"/>
                    <path id="p${playerNum}-energy-bar-fill" class="bar-fill" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.83 a 15.9155 15.9155 0 0 1 0 -31.83" stroke-width="3" stroke-dasharray="100, 100" stroke-dashoffset="0" transform="scale(0.8) translate(4.5, 4.5)" />
                </svg>
            </div>
            <div class="hud-details">
            <h2 style="margin:0 0 5px 0; font-size:1.1em">${playerName} (${character.name})</h2>
            <div class="skills-container">
                <div class="skill" id="p${playerNum}-skill-basicAttack">${SKILL_ICONS.basicAttack || ''}<div class="cooldown-overlay"></div></div>
                <div class="skill" id="p${playerNum}-skill-s1">${SKILL_ICONS[sk.s1.name] || ''}<div class="cooldown-overlay"></div></div>
                <div class="skill" id="p${playerNum}-skill-s2">${SKILL_ICONS[sk.s2.name] || ''}<div class="cooldown-overlay"></div></div>
                <div class="skill" id="p${playerNum}-skill-s3">${SKILL_ICONS[sk.s3.name] || ''}<div class="cooldown-overlay"></div></div>
            </div>
            </div>`;
        
        hud.querySelector('.portrait-container').appendChild(canvas);
    }

    function renderHUDs(delta) {
        for (const playerNum of [1, 2]) {
            const hudScene = hudScenes[`p${playerNum}`];
            const hudCamera = hudCameras[`p${playerNum}`];
            const hudModel = hudModels[`p${playerNum}`];
            const hud = document.getElementById(`player${playerNum}-hud`);
            const canvas = hud?.querySelector('.portrait-canvas');

            if (hudScene && hudCamera && hudModel && canvas) {
                hudModel.rotation.y += delta * 0.5;
                
                const rect = canvas.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    if (canvas.width !== rect.width || canvas.height !== rect.height) {
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                        hudCamera.aspect = rect.width / rect.height;
                        hudCamera.updateProjectionMatrix();
                    }

                    const mainCanvasRect = renderer.domElement.getBoundingClientRect();
                    const left = rect.left - mainCanvasRect.left;
                    const bottom = mainCanvasRect.bottom - rect.
