<!DOCTYPE html>
<html lang="en">
<head>
    <title>Chroma Core Arena - Final Version</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; padding: 0; background-color: #000; color: #fff; font-family: 'Orbitron', 'Consolas', monospace; overflow: hidden; }
        canvas { position: absolute; top: 0; left: 0; z-index: 1; }
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(5, 5, 10, 0.8); z-index: 200; transition: opacity 0.5s, visibility 0s 0.5s; opacity: 0; visibility: hidden; backdrop-filter: blur(10px); }
        .screen.active { opacity: 1; visibility: visible; transition-delay: 0s; }
        .panel { background: rgba(10, 20, 30, 0.7); border: 1px solid #00ffff; border-radius: 10px; padding: 40px; box-shadow: 0 0 25px rgba(0, 255, 255, 0.5); text-align: center; }
        
        #login-screen h1 { font-size: 3em; margin-bottom: 20px; }
        #login-screen input {
            padding: 15px; font-size: 1.2em; background-color: #111; border: 2px solid #fff; color: #fff;
            border-radius: 5px; font-family: 'Orbitron', sans-serif; margin: 10px auto; width: 350px;
            display: block; text-align: center;
        }
        #login-message { margin-top: 15px; height: 20px; color: #ff00ff; }
        .login-buttons { display: flex; justify-content: center; gap: 20px; margin-top: 20px;}

        #start-screen h1 { font-size: 5em; font-weight: 900; margin-bottom: 20px; text-shadow: 0 0 15px #00ffff, 0 0 30px #ff00ff; text-align: center; }
        .menu-button { padding: 15px 40px; font-size: 1.5em; background-color: #111; border: 2px solid #fff; color: #fff; cursor: pointer; border-radius: 5px; transition: all 0.2s; font-family: 'Orbitron', sans-serif; margin: 10px; width: 350px; text-align: center; }
        .menu-button:hover { background-color: #fff; color: #000; box-shadow: 0 0 15px #fff; }

        #settings-screen .settings-container { display: flex; gap: 50px; }
        .player-settings { padding: 20px; border: 2px solid #555; border-radius: 10px; }
        .player-settings h2 { margin-top: 0; text-align: center; }
        .keybind-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-size: 1.2em; }
        .keybind-row span { margin-right: 20px; }
        .keybind-button { width: 150px; padding: 10px; font-size: 1em; background-color: #333; border: 2px solid #888; color: #fff; cursor: pointer; border-radius: 5px; text-align: center; text-transform: uppercase; }
        .keybind-button.waiting { border-color: #ff00ff; color: #ff00ff; box-shadow: 0 0 10px #ff00ff; }
        #settings-back-button { margin-top: 30px; }

        #char-select-screen h1 { font-size: 4em; margin-bottom: 20px; text-shadow: 0 0 10px #00ffff, 0 0 20px #ff00ff; }
        #char-select-screen .panel { width: 95%; max-width: 1500px; }
        .char-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; width: 100%; margin-bottom: 20px; }
        .char-card {
            height: 300px; border: 2px solid #555; border-radius: 10px;
            background-color: rgba(17, 17, 17, 0.8); text-align: center; padding: 10px;
            transition: all 0.2s; position: relative; display: flex; flex-direction: column;
            justify-content: space-between; cursor: pointer;
        }
        .char-card.locked-by-p1 { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; transform: scale(1.05); }
        .char-card.locked-by-p2 { border-color: #ff00ff; box-shadow: 0 0 15px #ff00ff; transform: scale(1.05); }
        .char-card:not(.locked-by-p1):not(.locked-by-p2):hover { border-color: #fff; box-shadow: 0 0 10px #fff; transform: translateY(-5px); }
        .char-portrait { width: 100%; height: 50%; border-radius: 5px; background-size: cover; background-position: center; pointer-events: none; }
        .char-card h3 { margin: 8px 0; font-size: 1.2em; pointer-events: none; }
        .char-card .skills-preview p { margin: 4px 0; font-size: 0.75em; color: #aaa; pointer-events: none; }
        #char-select-footer { margin-top: 20px; font-size: 1.2em; color: #ccc; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }

        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 10; }
        .player-hud { position: absolute; bottom: 20px; display: flex; align-items: center; gap: 15px; background: rgba(10, 20, 30, 0.7); border-radius: 10px; padding: 10px; border: 1px solid #555; backdrop-filter: blur(5px); }
        #player1-hud { left: 20px; }
        #player2-hud { right: 20px; flex-direction: row-reverse; }
        
        .portrait-container { position: relative; width: 100px; height: 100px; }
        .portrait { width: 100%; height: 100%; border-radius: 50%; border: 3px solid; object-fit: cover; }
        .circular-bars svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: rotate(-90deg); }
        .bar-bg { fill: none; stroke: rgba(0,0,0,0.3); }
        .bar-fill { fill: none; transition: stroke-dashoffset 0.3s ease; }
        #p1-health-bar-fill, #p2-health-bar-fill { stroke: #0f0; }
        #p1-energy-bar-fill, #p2-energy-bar-fill { stroke: #ff0; }

        .hud-details { display: flex; flex-direction: column; }
        .hud-details h2 { margin: 0 0 5px 0; font-size: 1.2em; }
        .skills-container { display: flex; gap: 8px; margin-bottom: 5px; }
        .skill { width: 45px; height: 45px; border: 2px solid #888; border-radius: 5px; position: relative; background-color: #222; display: flex; justify-content: center; align-items: center; transition: box-shadow 0.2s; }
        .skill.ready { border-color: #fff; box-shadow: 0 0 8px #fff; }
        .skill svg { width: 60%; height: 60%; fill: #fff; }
        .cooldown-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); color: white; display: flex; justify-content: center; align-items: center; font-size: 1.5em; font-weight: bold; pointer-events: none; opacity: 0; transition: opacity 0.1s; border-radius: 3px; }
        
        #game-message-container { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 5em; font-weight: bold; text-align: center; text-shadow: 0 0 20px #fff; z-index: 50; }
        
        #game-over-screen .panel, #leaderboard-screen .panel { text-align: center; }
        #winner-text { font-size: 3em; margin-bottom: 30px; }

        #leaderboard-table {
            width: 600px; max-height: 350px; overflow-y: auto; margin: 20px auto;
            text-align: left; font-size: 1.2em; border-collapse: collapse;
        }
        .leaderboard-header { display: flex; font-weight: bold; color: #00ffff; border-bottom: 2px solid #00ffff; padding: 10px; }
        .leaderboard-row { display: flex; padding: 10px; border-bottom: 1px solid #333; }
        .leaderboard-row:nth-child(odd) { background-color: rgba(0,0,0,0.2); }
        .leaderboard-row .rank, .leaderboard-header .rank { width: 15%; text-align: center; }
        .leaderboard-row .name, .leaderboard-header .name { width: 60%; }
        .leaderboard-row .score, .leaderboard-header .score { width: 25%; text-align: right; font-weight: bold; color: #fff; }
        
        #import-export-section { margin-top: 30px; border-top: 1px solid #00ffff; padding-top: 20px; }
        #import-data-area {
            width: 90%; height: 60px; background-color: #111; color: #eee; border: 1px solid #888;
            border-radius: 5px; padding: 10px; font-family: 'Consolas', monospace; margin-bottom: 10px;
        }
        #leaderboard-message { margin-top: 15px; height: 20px; color: #00ffff; }
        .io-buttons { display: flex; justify-content: center; gap: 20px; }
    </style>
</head>
<body>
    <div id="login-screen" class="screen active">
        <div class="panel">
            <h1 id="login-title">PLAYER 1 LOGIN</h1>
            <input type="text" id="login-nickname" placeholder="NICKNAME (3-10 chars)" maxlength="10" minlength="3">
            <input type="password" id="login-password" placeholder="PASSWORD (min 4 chars)" minlength="4">
            <p id="login-message">&nbsp;</p>
            <div class="login-buttons">
                 <button id="login-button" class="menu-button" style="width: 200px;">LOGIN</button>
                 <button id="signup-button" class="menu-button" style="width: 200px;">SIGN UP</button>
            </div>
        </div>
    </div>

    <div id="start-screen" class="screen">
        <div class="panel">
            <h1>CHROMA CORE ARENA</h1>
            <button id="start-classic-duel-button" class="menu-button">CLASSIC DUEL</button>
            <button id="start-rift-duel-button" class="menu-button">RIFT DUEL</button>
            <button id="leaderboard-button" class="menu-button">LEADERBOARD</button>
            <button id="settings-button" class="menu-button">SETTINGS</button>
        </div>
    </div>
    
    <div id="leaderboard-screen" class="screen">
        <div class="panel" style="width: 800px;">
            <h1>LEADERBOARD</h1>
            <div id="leaderboard-table"></div>
            <p id="leaderboard-message">&nbsp;</p>
            <div id="import-export-section">
                <textarea id="import-data-area" placeholder="Paste another player's exported data here to merge leaderboards..."></textarea>
                <div class="io-buttons">
                    <button id="import-leaderboard-button" class="menu-button" style="width: auto;">Import & Merge Data</button>
                    <button id="export-leaderboard-button" class="menu-button" style="width: auto;">Export My Data</button>
                </div>
            </div>
            <button id="leaderboard-back-button" class="menu-button" style="margin-top:20px;">BACK</button>
        </div>
    </div>

    <div id="settings-screen" class="screen">
        <div class="panel">
            <h1>SETTINGS</h1>
            <div class="settings-container">
                <div class="player-settings">
                    <h2 style="color:#00ffff;">PLAYER 1</h2>
                    <div class="keybind-row"><span>Forward:</span><button class="keybind-button" data-player="p1" data-action="forward">w</button></div>
                    <div class="keybind-row"><span>Backward:</span><button class="keybind-button" data-player="p1" data-action="backward">s</button></div>
                    <div class="keybind-row"><span>Left:</span><button class="keybind-button" data-player="p1" data-action="left">a</button></div>
                    <div class="keybind-row"><span>Right:</span><button class="keybind-button" data-player="p1" data-action="right">d</button></div>
                    <div class="keybind-row"><span>Basic Attack:</span><button class="keybind-button" data-player="p1" data-action="basicAttack"> </button></div>
                    <div class="keybind-row"><span>Skill 1:</span><button class="keybind-button" data-player="p1" data-action="skill1">q</button></div>
                    <div class="keybind-row"><span>Skill 2:</span><button class="keybind-button" data-player="p1" data-action="skill2">e</button></div>
                    <div class="keybind-row"><span>Skill 3:</span><button class="keybind-button" data-player="p1" data-action="skill3">r</button></div>
                </div>
                <div class="player-settings">
                    <h2 style="color:#ff00ff;">PLAYER 2</h2>
                    <div class="keybind-row"><span>Forward:</span><button class="keybind-button" data-player="p2" data-action="forward">i</button></div>
                    <div class="keybind-row"><span>Backward:</span><button class="keybind-button" data-player="p2" data-action="backward">k</button></div>
                    <div class="keybind-row"><span>Left:</span><button class="keybind-button" data-player="p2" data-action="left">j</button></div>
                    <div class="keybind-row"><span>Right:</span><button class="keybind-button" data-player="p2" data-action="right">l</button></div>
                     <div class="keybind-row"><span>Basic Attack:</span><button class="keybind-button" data-player="p2" data-action="basicAttack">enter</button></div>
                    <div class="keybind-row"><span>Skill 1:</span><button class="keybind-button" data-player="p2" data-action="skill1">u</button></div>
                    <div class="keybind-row"><span>Skill 2:</span><button class="keybind-button" data-player="p2" data-action="skill2">o</button></div>
                    <div class="keybind-row"><span>Skill 3:</span><button class="keybind-button" data-player="p2" data-action="skill3">p</button></div>
                </div>
            </div>
            <button id="settings-back-button" class="menu-button">BACK</button>
        </div>
    </div>

    <div id="char-select-screen" class="screen">
        <div class="panel">
            <h1>CHOOSE YOUR ECHO</h1>
            <div id="char-grid" class="char-grid"></div>
            <div id="char-select-footer">
                <p id="lock-in-status">Player 1: Click to select your Echo</p>
            </div>
        </div>
    </div>

    <div id="game-over-screen" class="screen">
        <div class="panel">
            <div id="winner-text"></div>
            <button id="restart-button" class="menu-button">RETURN TO MENU</button>
        </div>
    </div>

    <div id="ui-container">
        <div id="player1-hud" class="player-hud"></div>
        <div id="player2-hud" class="player-hud"></div>
    </div>
    <div id="game-message-container"><span id="countdown-text"></span></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        // --- 1. ALL VARIABLES, CONSTANTS, AND SETUP CODE ---
        let gameState = 'LOGIN_SCREEN';
        let gameMode = 'CLASSIC';
        let currentUserLogin = 'p1';
        let loggedInUsers = { p1: null, p2: null };
        let controls = { p1: { forward: 'w', backward: 's', left: 'a', right: 'd', basicAttack: ' ', skill1: 'q', skill2: 'e', skill3: 'r' }, p2: { forward: 'i', backward: 'k', left: 'j', right: 'l', basicAttack: 'enter', skill1: 'u', skill2: 'o', skill3: 'p' } };
        let currentlyBinding = null;
        const SKILL_ICONS = { "Basic Attack": `<svg viewBox="0 0 24 24"><path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/></svg>`, "Power Shot": `<svg viewBox="0 0 24 24"><path d="M5 11h14v2H5z"/><path d="M2 12l5-5v10z"/></svg>`, "Aegis Charge": `<svg viewBox="0 0 24 24"><path d="M12 2L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-3zm-1 14h-2v-4h2v4zm4 0h-2v-4h2v4z"/></svg>`, "Venom Blade": `<svg viewBox="0 0 24 24"><path d="M3 21l3.75-3.75L3 13.5V21zm18-18L13.5 6.75 17.25 3H21zM4.41 5.83L5.83 4.41 19.59 18.17l-1.42 1.42L4.41 5.83z"/></svg>`, "Targeting Array": `<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M20.94 11c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"/></svg>`, "Static Orb": `<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8"/><path d="M12 6v2l-1.5 3h3L12 15v-2l1.5-3h-3z"/></svg>`, "Corruption": `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9v-2h2v2zm0-4H9V7h2v5zm4 4h-2v-2h2v2z"/></svg>`, "Decimate": `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><path d="M15.59 7L12 10.59 8.41 7 7 8.41 10.59 12 7 15.59 8.41 17 12 13.41 15.59 17 17 15.59 13.41 12 17 8.41z"/></svg>`, "Temporal Anomaly": `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 14h-2v-2h2v2zm0-4h-2V7h2v5z"/></svg>`, "Empower": `<svg viewBox="0 0 24 24"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"/></svg>`, "Tailwind": `<svg viewBox="0 0 24 24"><path d="M12 4l1.41 1.41L7.83 11H20v2H7.83l5.58 5.59L12 20l-8-8z"/></svg>`, "Feedback Loop": `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9V8h2v8zm4 0h-2V8h2v8z"/></svg>`, "Phase Shift": `<svg viewBox="0 0 24 24"><path d="M4 12l5-5v3h6v4H9v3zM18 7l-5 5 5 5V7z"/></svg>`, "Static Field": `<svg viewBox="0 0 24 24"><path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20zm0 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16z"/><path d="M12 7v10m-5-5h10"/></svg>`, "Energy Shield": `<svg viewBox="0 0 24 24"><path d="M12 2L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-3z"/></svg>`, "Overload": `<svg viewBox="0 0 24 24"><path d="M11 5h2v6h-2zM11 13h2v2h-2z"/><path d="M12 2c-5.52 0-10 4.48-10 10s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>`, "Blink": `<svg viewBox="0 0 24 24"><path d="M8 4h2v2H8zM14 4h2v2h-2zM11 7h2v2h-2zM8 10h2v2H8zM14 10h2v2h-2zM11 13h2v2h-2zM8 16h2v2H8zM14 16h2v2h-2z"/></svg>`, "Cloak": `<svg viewBox="0 0 24 24"><path fill-opacity=".3" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/></svg>`, "Slowing Mine": `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 14H9v-2h2v2zm0-4H9V7h2v5zm4 4h-2v-2h2v2z"/></svg>`, "Laser Core": `<svg viewBox="0 0 24 24"><path d="M4 11h16v2H4z"/></svg>`, "Ball Lightning": `<svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8"/><path d="M11 15h2v2h-2zM11 7h2v6h-2z"/></svg>`, "Eye of the Storm": `<svg viewBox="0 0 24 24"><path d="M12 6c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/><path d="M2 12h2.5c.83 0 1.5.67 1.5 1.5v.5h-2v2h2v.5c0 .83-.67 1.5-1.5 1.5H2v-6zm18 0v6h2.5c.83 0 1.5-.67 1.5-1.5v-.5h-2v-2h2v-.5c0-.83-.67-1.5-1.5-1.5H20z"/></svg>`, "Rewind": `<svg viewBox="0 0 24 24"><path d="M12.5 8H8v5h4.5v-5zM19 12v-2h-2V7h-2v3h-2v2h2v3h2v-3h2zM12 4C7.58 4 4 7.58 4 12s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8z"/></svg>`, "Swap": `<svg viewBox="0 0 24 24"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/></svg>`, "Molten Shield": `<svg viewBox="0 0 24 24"><path d="M12 2L4 5v6.09c0 5.05 3.41 9.76 8 10.91 4.59-1.15 8-5.86 8-10.91V5l-8-3zm0 18c-3.19-1-6-4.52-6-8.09V6.28l6-2.26 6 2.26v4.81C18 15.48 15.19 19 12 20z"/><circle cx="12" cy="12" r="3"/></svg>`, "Shield Break": `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L4 5v6.09c0 5.05 3.41 9.76 8 10.91 4.59-1.15 8-5.86 8-10.91V5l-8-3z"/><path d="M5 12l-1.5-1.5M19 12l1.5 1.5M10.5 5.5l-1-1M14.5 18.5l1 1"/></svg>`, "Tectonic Slam": `<svg viewBox="0 0 24 24"><path d="M19 13.5V21h-2v-7.5c0-1.38-1.12-2.5-2.5-2.5S12 12.12 12 13.5V21h-2v-7.5c0-2.48 2.02-4.5 4.5-4.5s4.5 2.02 4.5 4.5zM5 21v-2h2v2H5zm4 0v-2h2v2H9z"/><path d="M21 3H3v2h18V3z"/></svg>`, "Unstoppable Force": `<svg viewBox="0 0 24 24"><path d="M4 12l8-8 8 8-8 8-8-8zm2.83 0L12 6.83 17.17 12 12 17.17 6.83 12zM12 22v-2h-2v2h2zm4 0v-2h-2v2h2zM8 22v-2H6v2h2z"/></svg>`,"Stasis Field":`<svg viewBox="0 0 24 24"><path d="M12 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"/><path d="M12 10h-2v4h4v-2h-2v-2z"/></svg>`,"Chrono Prison":`<svg viewBox="0 0 24 24"><path d="M6 2c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2H6zm0 2h12v16H6V4z"/><path d="M12 6c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/></svg>`,"Sentry Turret":`<svg viewBox="0 0 24 24"><path d="M8 23h8v-2H8v2zM19 5H5c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-7 12c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/></svg>`,"Energy Conduit":`<svg viewBox="0 0 24 24"><path d="M12 2L4 6v12l8 4 8-4V6l-8-4zm-1 16.59V10h2v8.59l-1 0.45-1-0.45zM12 4.41L17.59 7 12 9.59 6.41 7 12 4.41z"/></svg>`,"Bastion Protocol":`<svg viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-3zM5 11V6.3l7-3.11 7 3.11V11c0 4.52-2.84 8.52-7 9.82C7.84 19.52 5 15.52 5 11z"/></svg>`,"Wind Wall":`<svg viewBox="0 0 24 24"><path d="M15.5 14h-.79l-2.6-5H12V3h2v4h1.5v2H14v2h1.5zM22 12c0 5.52-4.48 10-10 10S2 17.52 2 12 6.48 2 12 2c.4 0 .78.04 1.16.09A5.94 5.94 0 0 1 12 6c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6h4z"/></svg>`,"Cyclone":`<svg viewBox="0 0 24 24"><path d="M12 4c-4.42 0-8 3.58-8 8h2c0-3.31 2.69-6 6-6s6 2.69 6 6c0 3.31-2.69 6-6 6v-2c2.21 0 4-1.79 4-4h-2c0 2.21-1.79 4-4 4s-4-1.79-4-4H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>`, "Spell Shield": `<svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><path d="M12.5 12.5l-3.5-3.5 1.41-1.41L12.5 9.68l3.59-3.59L17.5 7.5 14 11l3.5 3.5-1.41 1.41L12.5 12.41l-3.59 3.59L7.5 14.5 11 11z"/></svg>`, "Silence": `<svg viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>`};
        const CHARACTERS = { ECHO_PRIME: { name: "Echo Prime", hp: 100, speed: 8, color: 0x00ffff, attackType: 'RANGED', skills: { s1: {name:"Power Shot", cost: 25, cd: 3}, s2: {name:"Phase Shift", cost: 30, cd: 4}, s3: {name:"Static Field", cost: 50, cd: 12} } }, AEGIS: { name: "Aegis", hp: 150, speed: 6, color: 0xffa500, attackType: 'MELEE', skills: { s1: {name:"Aegis Charge", cost: 20, cd: 5}, s2: {name:"Energy Shield", cost: 40, cd: 8}, s3: {name:"Overload", cost: 100, cd: 15} } }, SPECTRE: { name: "Spectre", hp: 75, speed: 10, color: 0x9400d3, attackType: 'MELEE', skills: { s1: {name:"Venom Blade", cost: 15, cd: 4}, s2: {name:"Blink", cost: 25, cd: 3}, s3: {name:"Cloak", cost: 60, cd: 12} } }, JAVELIN: { name: "Javelin", hp: 90, speed: 7, color: 0x32cd32, attackType: 'RANGED', skills: { s1: {name:"Targeting Array", cost: 30, cd: 10}, s2: {name:"Slowing Mine", cost: 40, cd: 10}, s3: {name:"Laser Core", cost: 80, cd: 18} } }, TEMPEST: { name: "Tempest", hp: 100, speed: 8, color: 0x1e90ff, attackType: 'RANGED', skills: { s1: {name:"Static Orb", cost: 25, cd: 6}, s2: {name:"Ball Lightning", cost: 50, cd: 12}, s3: {name:"Eye of the Storm", cost: 70, cd: 20} } }, GLITCH: { name: "Glitch", hp: 100, speed: 8, color: 0xf0e68c, attackType: 'RANGED', skills: { s1: {name:"Corruption", cost: 30, cd: 8}, s2: {name:"Rewind", cost: 40, cd: 10}, s3: {name:"Swap", cost: 60, cd: 15} } }, COLOSSUS: { name: "Colossus", hp: 140, speed: 6.5, color: 0xdc143c, attackType: 'MELEE', skills: { s1: {name:"Decimate", cost: 10, cd: 3}, s2: {name:"Tectonic Slam", cost: 30, cd: 7}, s3: {name:"Unstoppable Force", cost: 80, cd: 20} } }, CHRONOMANCER: { name: "Chronomancer", hp: 95, speed: 8, color: 0x40e0d0, attackType: 'RANGED', skills: { s1: {name:"Temporal Anomaly", cost: 35, cd: 9}, s2: {name:"Stasis Field", cost: 40, cd: 12}, s3: {name:"Chrono Prison", cost: 75, cd: 18} } }, ORACLE: { name: "Oracle", hp: 110, speed: 7, color: 0xffffff, attackType: 'RANGED', skills: { s1: {name:"Empower", cost: 25, cd: 12}, s2: {name:"Sentry Turret", cost: 40, cd: 10}, s3: {name:"Bastion Protocol", cost: 60, cd: 18} } }, ZEPHYR: { name: "Zephyr", hp: 85, speed: 11, color: 0x90ee90, attackType: 'RANGED', skills: { s1: {name:"Tailwind", cost: 20, cd: 8}, s2: {name:"Wind Wall", cost: 40, cd: 10}, s3: {name:"Cyclone", cost: 70, cd: 15} } }, NULL: { name: "Null", hp: 100, speed: 8.5, color: 0xa020f0, attackType: 'RANGED', skills: { s1: {name:"Feedback Loop", cost: 30, cd: 7}, s2: {name:"Silence", cost: 40, cd: 12}, s3: {name:"Spell Shield", cost: 30, cd: 15} } } };
        const charKeys = Object.keys(CHARACTERS);
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        renderer.shadowMap.enabled = true;
        document.body.insertBefore(renderer.domElement, document.body.firstChild);
        const clock = new THREE.Clock();
        const keys = {}; 
        let audioReady = false;
        const sounds = {
            shoot: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(),
            hit: new Tone.PolySynth(Tone.MembraneSynth, { pitchDecay: 0.1, octaves: 4, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination(),
            death: new Tone.PolySynth(Tone.MetalSynth, { frequency: 50, envelope: { attack: 0.01, decay: 1, release: 0.5 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination(),
            shield: new Tone.PolySynth(Tone.NoiseSynth, { noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 } }).toDestination(),
            teleport: new Tone.PolySynth(Tone.PluckSynth, { attackNoise: 1, dampening: 4000, resonance: 0.7 }).toDestination(),
            laser: new Tone.PolySynth(Tone.FMSynth, { harmonicity: 1.2, modulationIndex: 10, envelope: { attack: 0.01, decay: 1, sustain: 0.1, release: 0.2 } }).toDestination(),
            explosion: new Tone.PolySynth(Tone.MembraneSynth, { pitchDecay: 0.5, octaves: 10, envelope: { attack: 0.01, decay: 0.8, sustain: 0 } }).toDestination(),
        };
        scene.add(new THREE.AmbientLight(0xffffff, 0.3));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(-15, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 25; dirLight.shadow.camera.bottom = -25;
        dirLight.shadow.camera.left = -25; dirLight.shadow.camera.right = 25;
        scene.add(dirLight);
        const arenaSize = 45;
        scene.add(new THREE.GridHelper(arenaSize, arenaSize, 0x00ffff, 0x333333));
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(arenaSize, arenaSize), new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 }));
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        const obstacles = [];
        const pylonGeo = new THREE.CylinderGeometry(1, 1, 6, 8);
        const pylonMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.3 });
        const pylonPositions = [new THREE.Vector3(10, 3, 10), new THREE.Vector3(-10, 3, -10), new THREE.Vector3(10, 3, -10), new THREE.Vector3(-10, 3, 10), new THREE.Vector3(0, 3, 0)];
        pylonPositions.forEach(pos => { const pylon = new THREE.Mesh(pylonGeo, pylonMat); pylon.position.copy(pos); pylon.castShadow = true; pylon.receiveShadow = true; scene.add(pylon); const pylonBox = new THREE.Box3().setFromObject(pylon); pylonBox.isPylon = true; obstacles.push(pylonBox); });
        let players = [], projectiles = [], specialObjects = [];
        let p1Select = -1, p2Select = -1; // -1 means not selected
        let p1Locked = false, p2Locked = false;

        // --- 2. ALL FUNCTIONS AND CLASSES ---
        
        // Login & Leaderboard Functions
        function getUsers() {
            try {
                // All user data (sign-ups) is stored in the browser's localStorage.
                // This makes it persistent, so it won't refresh or be deleted.
                return JSON.parse(localStorage.getItem('chromaCoreUsers')) || {};
            } catch (e) {
                return {};
            }
        }

        function saveUsers(users) {
            localStorage.setItem('chromaCoreUsers', JSON.stringify(users));
        }

        function displayLeaderboard() {
            const table = document.getElementById('leaderboard-table');
            const users = getUsers();
            const sortedPlayers = Object.entries(users)
                .map(([name, data]) => ({ name, wins: data.wins }))
                .sort((a, b) => b.wins - a.wins);

            let html = `<div class="leaderboard-header">
                            <div class="rank">RANK</div>
                            <div class="name">NICKNAME</div>
                            <div class="score">WINS</div>
                        </div>`;

            if (sortedPlayers.length === 0) {
                html += '<div class="leaderboard-row"><div class="name" style="width: 100%; text-align: center;">No games played yet.</div></div>';
            } else {
                sortedPlayers.forEach((player, index) => {
                    html += `<div class="leaderboard-row">
                                <div class="rank">#${index + 1}</div>
                                <div class="name">${player.name}</div>
                                <div class="score">${player.wins}</div>
                            </div>`;
                });
            }
            table.innerHTML = html;
        }

        function handleSuccessfulLogin(nickname) {
            loggedInUsers[currentUserLogin] = nickname;
            
            if (currentUserLogin === 'p1') {
                currentUserLogin = 'p2';
                document.getElementById('login-title').innerHTML = `<span style="color: #ff00ff;">PLAYER 2 LOGIN</span>`;
                document.getElementById('login-nickname').value = '';
                document.getElementById('login-password').value = '';
                document.getElementById('login-nickname').focus();
                 document.getElementById('login-message').textContent = `Welcome, ${nickname}! Player 2's turn.`;
            } else {
                // Both players logged in
                gameState = 'START_SCREEN';
                switchScreen('start-screen');
            }
        }

        function populateSettings() {
            document.querySelectorAll('.keybind-button').forEach(button => {
                const player = button.dataset.player;
                const action = button.dataset.action;
                let keyText = controls[player][action];
                if (keyText === ' ') keyText = 'space';
                button.textContent = keyText;
            });
        }
        
        function switchScreen(screenId) { 
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active')); 
            const screen = document.getElementById(screenId);
            if (screen) screen.classList.add('active'); 
        }

        function buildPlayerHUD(playerNum, character) {
            const hud = document.getElementById(`player${playerNum}-hud`);
            hud.className = 'player-hud';
            hud.style.borderColor = `#${new THREE.Color(character.color).getHexString()}`; 
            const playerName = loggedInUsers[`p${playerNum}`];
            hud.innerHTML = `
                <div class="portrait-container">
                    <div class="portrait" style="background-color: #${new THREE.Color(character.color).getHexString()};"></div>
                    <svg viewBox="0 0 36 36" class="circular-bars">
                        <path class="bar-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.83 a 15.9155 15.9155 0 0 1 0 -31.83" stroke-width="3" />
                        <path class="bar-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.83 a 15.9155 15.9155 0 0 1 0 -31.83" stroke-width="3" transform="scale(0.8) translate(4.5, 4.5)" />
                        <path id="p${playerNum}-health-bar-fill" class="bar-fill" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.83 a 15.9155 15.9155 0 0 1 0 -31.83" stroke-width="3" stroke-dasharray="100, 100" stroke-dashoffset="0"/>
                        <path id="p${playerNum}-energy-bar-fill" class="bar-fill" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.83 a 15.9155 15.9155 0 0 1 0 -31.83" stroke-width="3" stroke-dasharray="100, 100" stroke-dashoffset="0" transform="scale(0.8) translate(4.5, 4.5)" />
                    </svg>
                </div>
                <div class="hud-details">
                    <h2>${playerName} (${character.name})</h2>
                    <div class="skills-container">
                        <div class="skill" id="p${playerNum}-skill-basicAttack">${SKILL_ICONS['Basic Attack'] || ''}<div class="cooldown-overlay"></div></div>
                        <div class="skill" id="p${playerNum}-skill-s1">${SKILL_ICONS[character.skills.s1.name] || ''}<div class="cooldown-overlay"></div></div>
                        <div class="skill" id="p${playerNum}-skill-s2">${SKILL_ICONS[character.skills.s2.name] || ''}<div class="cooldown-overlay"></div></div>
                        <div class="skill" id="p${playerNum}-skill-s3">${SKILL_ICONS[character.skills.s3.name] || ''}<div class="cooldown-overlay"></div></div>
                    </div>
                </div>
            `;
        }

        function updateUI() { 
            if (players.length < 2) return; 
            players.forEach((p, i) => { 
                const playerNum = i + 1; 
                const healthBar = document.getElementById(`p${playerNum}-health-bar-fill`);
                const energyBar = document.getElementById(`p${playerNum}-energy-bar-fill`);
                
                if(healthBar) healthBar.style.strokeDashoffset = 100 - (p.hp / p.maxHp) * 100;
                if(energyBar) energyBar.style.strokeDashoffset = 100 - (p.energy / p.maxEnergy) * 100;

                for(const key of ['basicAttack', 's1', 's2', 's3']) {
                    if (!p.cooldowns.hasOwnProperty(key)) continue;

                    const skillEl = document.getElementById(`p${playerNum}-skill-${key}`);
                    if (!skillEl) continue; 
                    
                    const cdOverlay = skillEl.querySelector(`.cooldown-overlay`);
                    if (cdOverlay) { 
                        if(p.cooldowns[key] > 0) { 
                            cdOverlay.style.opacity = '1'; 
                            cdOverlay.textContent = p.cooldowns[key].toFixed(1); 
                            skillEl.classList.remove('ready'); 
                        } else { 
                            cdOverlay.style.opacity = '0'; 
                            skillEl.classList.add('ready'); 
                        } 
                    } 
                } 
            }); 
        }

        function setupCharSelect() {
            p1Select = -1; p2Select = -1;
            p1Locked = false; p2Locked = false;
            
            const grid = document.getElementById('char-grid');
            grid.innerHTML = '';
            charKeys.forEach((key, index) => {
                const char = CHARACTERS[key];
                const card = document.createElement('div');
                card.className = 'char-card';
                card.dataset.index = index;
                card.innerHTML = `
                    <div class="char-portrait" style="background-color: #${new THREE.Color(char.color).getHexString()};"></div>
                    <h3>${char.name}</h3>
                    <div class="skills-preview">
                        <p>Skill 1: ${char.skills.s1.name}</p>
                        <p>Skill 2: ${char.skills.s2.name}</p>
                        <p>Skill 3: ${char.skills.s3.name}</p>
                    </div>`;
                card.addEventListener('click', () => handleCardClick(index));
                grid.appendChild(card);
            });
            updateSelectors();
        }

        function handleCardClick(index) {
            if (gameState !== 'CHAR_SELECT') return;

            if (!p1Locked) {
                p1Select = index;
                p1Locked = true;
            } else if (!p2Locked) {
                if (index === p1Select) return;
                p2Select = index;
                p2Locked = true;
                document.getElementById('lock-in-status').textContent = 'Both players selected. Starting match...';
                setTimeout(startGame, 1500);
            }
            updateSelectors();
        }

        function updateSelectors() {
            document.querySelectorAll('.char-card').forEach(card => {
                card.classList.remove('locked-by-p1', 'locked-by-p2');
            });
            
            const statusText = document.getElementById('lock-in-status');

            if (p1Locked) {
                document.querySelector(`.char-card[data-index='${p1Select}']`).classList.add('locked-by-p1');
            }
            if (p2Locked) {
                document.querySelector(`.char-card[data-index='${p2Select}']`).classList.add('locked-by-p2');
            }
            
            if (!p1Locked) {
                 statusText.innerHTML = `<span style="color:#00ffff;">${loggedInUsers.p1}:</span> Click to select your Echo`;
            } else if (!p2Locked) {
                 statusText.innerHTML = `<span style="color:#ff00ff;">${loggedInUsers.p2}:</span> Click to select your Echo`;
            }
        }

        function startGame() {
            if (!p1Locked || !p2Locked) return;
            
            camera.position.set(0, 35, 0.1);
            camera.lookAt(0, 0, 0);

            gameState = 'COUNTDOWN';
            switchScreen('');
            document.getElementById('ui-container').style.opacity = 1;

            const p1CharKey = charKeys[p1Select];
            const p2CharKey = charKeys[p2Select];
            
            players.push(new Player(1, p1CharKey));
            players.push(new Player(2, p2CharKey));

            players.forEach(p => {
                specialObjects.push(new SpawnEffect(p.mesh.position, CHARACTERS[p.characterKey].color));
            });

            if (gameMode === 'RIFT') {
                specialObjects.push(new Rift());
            }

            buildPlayerHUD(1, CHARACTERS[p1CharKey]);
            buildPlayerHUD(2, CHARACTERS[p2CharKey]);

            const countdownText = document.getElementById('countdown-text');
            let count = 3;
            countdownText.textContent = count;
            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownText.textContent = count;
                } else {
                    countdownText.textContent = 'FIGHT!';
                    gameState = 'ACTIVE';
                    setTimeout(() => countdownText.textContent = '', 1000);
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }
        
        function createPlayerModel(character) {
            const group = new THREE.Group();
            const bodyGeo = new THREE.CapsuleGeometry(1, 2, 4, 16);
            const bodyMat = new THREE.MeshStandardMaterial({
                color: character.color,
                metalness: 0.4,
                roughness: 0.6
            });
            bodyMat.emissive = new THREE.Color(0x000000);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 2;
            body.castShadow = true;
            group.add(body);
            
            const headGeo = new THREE.IcosahedronGeometry(0.7, 0);
            const headMat = bodyMat.clone();
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 3.8;
            head.castShadow = true;
            group.add(head);

            return group;
        }

        class Player {
             constructor(playerNum, characterKey) {
                this.playerNum = playerNum;
                this.characterKey = characterKey;
                const data = CHARACTERS[characterKey];
                this.mesh = createPlayerModel(data);
                this.mesh.position.set(playerNum === 1 ? -15 : 15, 0, 0);
                scene.add(this.mesh);
                
                this.collider = new THREE.Box3();
                this.collider.setFromObject(this.mesh);

                this.maxHp = data.hp;
                this.hp = this.maxHp;
                this.maxEnergy = 100;
                this.energy = this.maxEnergy; // Start with full energy
                this.speed = data.speed;
                this.skills = data.skills;
                this.attackType = data.attackType;
                this.attackRange = this.attackType === 'MELEE' ? 3.5 : 0;
                this.status = { 
                    slowed: 0, 
                    rooted: 0, 
                    silenced: 0,
                    shielded: 0,
                    spellShield: 0,
                    unstoppable: 0,
                    cloaked: 0, 
                    empowered: 0, 
                    venom: 0,
                    corruption: 0,
                    feedbackLoop: 0,
                    isCharging: 0,
                    riftBuff: 0,
                    nextAttackVenom: false,
                    targetingArray: 0,
                };
                this.statusMeshes = {};
                this.riftLight = null;
                this.cooldowns = { basicAttack: 0, s1: 0, s2: 0, s3: 0 };
                this.velocity = new THREE.Vector3();
                this.aimDirection = new THREE.Vector3();
                this.rewindPositions = [];
                this.rewindTimer = 0;

                // Add character-specific aura
                this.aura = null;
                switch (characterKey) {
                    case 'ECHO_PRIME': case 'TEMPEST':
                        this.aura = new PlayerAura(this, 30, data.color, 0.8, 0.1); break;
                    case 'AEGIS': case 'COLOSSUS':
                        this.aura = new PlayerAura(this, 20, data.color, 0.3, 0.15); break;
                    case 'SPECTRE': case 'NULL':
                        this.aura = new PlayerAura(this, 40, data.color, 0.5, 0.1, true); break; // Inward effect
                    case 'JAVELIN':
                        this.aura = new PlayerAura(this, 15, data.color, 1.2, 0.08); break;
                    case 'GLITCH': case 'CHRONOMANCER':
                        this.aura = new PlayerAura(this, 25, data.color, 0.6, 0.1); break;
                    case 'ORACLE':
                         this.aura = new PlayerAura(this, 50, data.color, 0.2, 0.12); break;
                    case 'ZEPHYR':
                        this.aura = new PlayerAura(this, 40, data.color, 1.5, 0.09); break;
                }
                if (this.aura) {
                    specialObjects.push(this.aura);
                }

                // Add visuals for status effects
                this.statusVisuals = {
                    empowered: new StatusEffectVisual(this, 'empowered', 0xffff00),
                    venom: new StatusEffectVisual(this, 'venom', 0x00ff00, 30, 'drip'),
                    corruption: new StatusEffectVisual(this, 'corruption', 0x800080, 40, 'cloud')
                };
                specialObjects.push(...Object.values(this.statusVisuals));
             }

             update(delta, opponent) {
                // Cooldowns and Status Timers
                for (const key in this.cooldowns) {
                    this.cooldowns[key] = Math.max(0, this.cooldowns[key] - delta);
                }
                for (const key in this.status) {
                    if (typeof this.status[key] === 'number') {
                        this.status[key] = Math.max(0, this.status[key] - delta);
                    }
                }
                
                if (this.status.venom > 0) this.takeDamage(10 * delta, true);
                if (this.status.feedbackLoop > 0 && opponent.energy < opponent.maxEnergy) {
                    opponent.takeDamage(15 * delta, true);
                }

                this.energy = Math.min(this.maxEnergy, this.energy + (this.status.riftBuff > 0 ? 25 : 5) * delta);

                // Movement
                const moveDirection = new THREE.Vector3(0,0,0);
                if (this.status.rooted <= 0) {
                    const playerControls = controls[`p${this.playerNum}`];
                    if(keys[playerControls.forward]) moveDirection.z -= 1;
                    if(keys[playerControls.backward]) moveDirection.z += 1;
                    if(keys[playerControls.left]) moveDirection.x -= 1;
                    if(keys[playerControls.right]) moveDirection.x += 1;
                }

                if (moveDirection.lengthSq() > 0) {
                    moveDirection.normalize();
                    let currentSpeed = this.speed * (this.status.riftBuff > 0 ? 1.5 : 1);
                    if(this.status.slowed > 0 && this.status.unstoppable <= 0) currentSpeed *= 0.5;
                    this.velocity.add(moveDirection.clone().multiplyScalar(currentSpeed * delta * 20));
                }
                
                if(this.status.isCharging > 0) {
                     let chargeSpeed = this.characterKey === 'AEGIS' ? 40 : 35;
                     this.velocity.copy(this.aimDirection).multiplyScalar(chargeSpeed);
                }

                this.mesh.position.add(this.velocity.clone().multiplyScalar(delta));
                this.velocity.multiplyScalar(1 - 15 * delta); 
                
                this.mesh.position.x = Math.max(-arenaSize/2 + 1, Math.min(arenaSize/2 - 1, this.mesh.position.x));
                this.mesh.position.z = Math.max(-arenaSize/2 + 1, Math.min(arenaSize/2 - 1, this.mesh.position.z));
                
                this.aimDirection.subVectors(opponent.mesh.position, this.mesh.position).normalize();
                const lookAtPos = this.mesh.position.clone().add(this.aimDirection);
                lookAtPos.y = this.mesh.position.y;
                this.mesh.lookAt(lookAtPos);
                
                this.collider.setFromObject(this.mesh);

                // Collisions
                obstacles.forEach(obs => { if (this.collider.intersectsBox(obs)) this.resolveCollision(obs); });
                if (this.collider.intersectsBox(opponent.collider)) {
                    if(this.status.isCharging > 0) {
                        opponent.takeDamage(25);
                        const knockback = this.aimDirection.clone().multiplyScalar(20);
                        opponent.velocity.add(knockback);
                        this.status.isCharging = 0;
                    }
                    this.resolveCollision(opponent.collider, 0.5);
                    opponent.resolveCollision(this.collider, 0.5);
                }

                this.rewindTimer += delta;
                if(this.rewindTimer > 0.25) {
                    this.rewindTimer = 0;
                    this.rewindPositions.push({pos: this.mesh.position.clone(), hp: this.hp, energy: this.energy });
                    if(this.rewindPositions.length > 20) this.rewindPositions.shift();
                }

                // Visuals
                this.updateStatusVisuals();
                this.mesh.traverse(child => {
                    if (child.material) {
                        child.material.transparent = this.status.cloaked > 0;
                        child.material.opacity = this.status.cloaked > 0 ? 0.3 : 1.0;
                    }
                });
             }
            
             updateStatusVisuals() {
                // Rooted
                if (this.status.rooted > 0 && !this.statusMeshes.root) {
                    const geo = new THREE.TorusGeometry(1.2, 0.05, 8, 32);
                    const mat = new THREE.MeshBasicMaterial({color: 0xff0000});
                    this.statusMeshes.root = new THREE.Mesh(geo, mat);
                    this.statusMeshes.root.rotation.x = Math.PI / 2;
                    scene.add(this.statusMeshes.root);
                } else if (this.status.rooted <= 0 && this.statusMeshes.root) {
                    scene.remove(this.statusMeshes.root);
                    this.statusMeshes.root.geometry.dispose();
                    this.statusMeshes.root.material.dispose();
                    this.statusMeshes.root = null;
                }
                if(this.statusMeshes.root) {
                    this.statusMeshes.root.position.copy(this.mesh.position);
                    this.statusMeshes.root.position.y = 0.1;
                }
                // Slowed
                if (this.status.slowed > 0 && !this.statusMeshes.slow) {
                    const geo = new THREE.TorusGeometry(1.3, 0.05, 8, 32);
                    const mat = new THREE.MeshBasicMaterial({color: 0x0000ff});
                    this.statusMeshes.slow = new THREE.Mesh(geo, mat);
                    this.statusMeshes.slow.rotation.x = Math.PI / 2;
                    scene.add(this.statusMeshes.slow);
                } else if (this.status.slowed <= 0 && this.statusMeshes.slow) {
                    scene.remove(this.statusMeshes.slow);
                    this.statusMeshes.slow.geometry.dispose();
                    this.statusMeshes.slow.material.dispose();
                    this.statusMeshes.slow = null;
                }
                if(this.statusMeshes.slow) {
                    this.statusMeshes.slow.position.copy(this.mesh.position);
                    this.statusMeshes.slow.position.y = 0.15;
                }
                // Rift Buff
                if (this.status.riftBuff > 0 && !this.riftLight) {
                    this.riftLight = new THREE.PointLight(0xff00ff, 5, 5);
                    this.mesh.add(this.riftLight);
                } else if (this.status.riftBuff <= 0 && this.riftLight) {
                    this.mesh.remove(this.riftLight);
                    this.riftLight = null;
                }
             }

            resolveCollision(otherBox, pushFactor = 1.0) {
                if(this.status.isCharging > 0 && otherBox.isPylon) {
                    this.status.isCharging = 0;
                    this.status.rooted = 1.5; // Self-stun
                    this.velocity.set(0,0,0);
                }

                const centerPlayer = new THREE.Vector3();
                this.collider.getCenter(centerPlayer);
                const centerObs = new THREE.Vector3();
                otherBox.getCenter(centerObs);

                const sizePlayer = new THREE.Vector3();
                this.collider.getSize(sizePlayer);
                const sizeObs = new THREE.Vector3();
                otherBox.getSize(sizeObs);

                const dx = centerObs.x - centerPlayer.x;
                const penetrationX = (sizePlayer.x / 2 + sizeObs.x / 2) - Math.abs(dx);
                const dz = centerObs.z - centerPlayer.z;
                const penetrationZ = (sizePlayer.z / 2 + sizeObs.z / 2) - Math.abs(dz);

                if (penetrationX > 0 && penetrationZ > 0) {
                    if (penetrationX < penetrationZ) {
                        this.mesh.position.x -= penetrationX * Math.sign(dx) * pushFactor;
                    } else {
                        this.mesh.position.z -= penetrationZ * Math.sign(dz) * pushFactor;
                    }
                    this.collider.setFromObject(this.mesh);
                }
            }

             takeDamage(amount, isDoT = false) {
                if (this.status.shielded > 0 && !isDoT) return;
                if (this.status.spellShield > 0 && !isDoT) { this.status.spellShield = 0; return; }

                let finalDamage = amount;
                if(this.status.corruption > 0) finalDamage *= 1.3;
                if(this.status.empowered > 0) finalDamage *= 0.7;

                this.hp = Math.max(0, this.hp - finalDamage);

                if (!isDoT) {
                    specialObjects.push(new ParticleExplosion(this.mesh.position.clone().setY(2), new THREE.Color(0xffffff), 20, 0.5));
                    if (audioReady) sounds.hit.triggerAttackRelease("C2", "8n");
                    this.mesh.traverse(c => { if(c.material && c.material.emissive) c.material.emissive.setHex(0xffffff); });
                    setTimeout(() => { this.mesh.traverse(c => { if(c.material && c.material.emissive) c.material.emissive.setHex(0x000000); }); }, 150);
                }
                if (this.hp <= 0) this.die();
             }

             die() {
                specialObjects.push(new ParticleExplosion(this.mesh.position.clone().setY(2), this.mesh.children[0].material.color, 200, 1.5));
                if (audioReady) sounds.death.triggerAttackRelease("8n");
                endGame(this.playerNum === 1 ? 2 : 1);
             }
             
             destroy() {
                scene.remove(this.mesh);
                Object.values(this.statusMeshes).forEach(m => {
                    if (m) scene.remove(m);
                });
                for (let i = specialObjects.length - 1; i >= 0; i--) {
                    if (specialObjects[i].owner === this) {
                        specialObjects[i].destroy();
                        specialObjects.splice(i, 1);
                    }
                }
             }

             useSkill(skillKey) {
                if (this.cooldowns[skillKey] > 0 || this.status.silenced > 0) return;
                
                const fireDirection = this.aimDirection.clone();
                const opponent = players.find(p => p !== this);

                if (skillKey === 'basicAttack') {
                    this.cooldowns.basicAttack = 0.5;
                    let effects = null;
                    if (this.status.nextAttackVenom) {
                        effects = { venom: 3 };
                        this.status.nextAttackVenom = false;
                    }

                    if (this.attackType === 'RANGED') {
                        const isPiercing = this.status.targetingArray > 0;
                        projectiles.push(new Projectile(this, fireDirection, 10, 20, { effects, piercing: isPiercing }));
                    } else { // MELEE
                        if (opponent && opponent.mesh.position.distanceTo(this.mesh.position) < this.attackRange) {
                            opponent.takeDamage(10);
                            if (effects) Object.assign(opponent.status, effects);
                        }
                        specialObjects.push(new MeleeSlash(this, this.mesh.children[0].material.color));
                    }
                    return;
                }

                const skill = this.skills[skillKey];
                if (!skill || this.energy < skill.cost) return;
                
                this.cooldowns[skillKey] = skill.cd;
                this.energy -= skill.cost;
                
                switch(skill.name) {
                    case "Power Shot": projectiles.push(new Projectile(this, fireDirection, 25, 35, {})); break;
                    case "Phase Shift": this.velocity.add(this.aimDirection.clone().multiplyScalar(20)); if(audioReady) sounds.teleport.triggerAttackRelease("C5", "8n"); break;
                    case "Static Field": specialObjects.push(new StaticField(this)); break;
                    case "Aegis Charge": this.status.isCharging = 0.5; break;
                    case "Energy Shield": this.status.shielded = 5; specialObjects.push(new ShieldEffect(this, 5, 0xADD8E6)); break;
                    case "Overload": specialObjects.push(new ExpandingRing(this.mesh.position, this.mesh.children[0].material.color, 8, 0.5)); if(opponent.mesh.position.distanceTo(this.mesh.position) < 8) { opponent.takeDamage(40); } if(audioReady) sounds.explosion.triggerAttackRelease("G2", "2n"); break;
                    case "Venom Blade": this.status.nextAttackVenom = true; break;
                    case "Blink": const blinkPos = this.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(8)); this.mesh.position.copy(blinkPos); if(audioReady) sounds.teleport.triggerAttackRelease("C6", "16n"); break;
                    case "Cloak": this.status.cloaked = 5; break;
                    case "Slowing Mine": specialObjects.push(new SlowingMine(this, this.mesh.position.clone())); break;
                    case "Laser Core": specialObjects.push(new LaserCore(this, opponent)); if(audioReady) sounds.laser.triggerAttackRelease("C4", "1n"); break;
                    case "Corruption": projectiles.push(new Projectile(this, fireDirection, 5, 20, { effects: { corruption: 5 }})); break;
                    case "Rewind": if(this.rewindPositions.length > 0) { const lastState = this.rewindPositions[0]; this.mesh.position.copy(lastState.pos); this.hp = lastState.hp; this.energy = lastState.energy; } if(audioReady) sounds.teleport.triggerAttackRelease("A5", "8n"); break;
                    case "Swap": const myPos = this.mesh.position.clone(); this.mesh.position.copy(opponent.mesh.position); opponent.mesh.position.copy(myPos); if(audioReady) sounds.teleport.triggerAttackRelease("F4", "8n"); break;
                    case "Decimate": specialObjects.push(new Decimate(this)); break;
                    case "Tectonic Slam": specialObjects.push(new TectonicSlam(this)); break;
                    case "Unstoppable Force": this.status.unstoppable = 4; this.status.isCharging = 0.5; break;
                    case "Temporal Anomaly": projectiles.push(new Projectile(this, fireDirection, 10, 15, { effects: { slowed: 3 }})); break;
                    case "Stasis Field": specialObjects.push(new StasisField(this, this.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(10)))); break;
                    case "Chrono Prison": if(opponent) { opponent.status.rooted = 3; specialObjects.push(new ShieldEffect(opponent, 3, 0x40e0d0));} break;
                    case "Empower": this.status.empowered = 4; break;
                    case "Sentry Turret": specialObjects.push(new SentryTurret(this)); break;
                    case "Bastion Protocol": this.status.shielded = 10; specialObjects.push(new ShieldEffect(this, 10, 0xffffff)); break;
                    case "Tailwind": this.velocity.add(this.aimDirection.clone().multiplyScalar(-20)); if(audioReady) sounds.teleport.triggerAttackRelease("C5", "8n"); break;
                    case "Wind Wall": const wallPos = this.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(3)); specialObjects.push(new WindWall(this, wallPos, this.mesh.quaternion)); break;
                    case "Cyclone": specialObjects.push(new Cyclone(this)); break;
                    case "Feedback Loop": projectiles.push(new Projectile(this, fireDirection, 10, 20, { effects: { feedbackLoop: 5 }})); break;
                    case "Silence": projectiles.push(new Projectile(this, fireDirection, 10, 20, { effects: { silenced: 3 }})); break;
                    case "Spell Shield": this.status.spellShield = 10; specialObjects.push(new ShieldEffect(this, 10, 0xa020f0)); break;
                    case "Targeting Array": this.status.targetingArray = 5; specialObjects.push(new StatusAura(this, 5, this.mesh.children[0].material.color.getHex())); break;
                    case "Static Orb": projectiles.push(new Projectile(this, fireDirection, 25, 20, { size: 0.6, life: 2 })); break;
                    case "Ball Lightning": projectiles.push(new Projectile(this, fireDirection, 15, 10, { size: 0.8, life: 4, piercing: true })); break;
                    case "Eye of the Storm": specialObjects.push(new EyeOfTheStorm(this)); break;
                    default: break;
                }
             }
        }
        
        class Projectile {
            constructor(owner, direction, damage, speed, { size = 0.3, life = 3, effects = null, piercing = false } = {}) {
                this.owner = owner;
                this.damage = owner.status.riftBuff > 0 ? damage * 1.5 : damage;
                this.speed = speed;
                this.direction = direction;
                this.life = life;
                this.effects = effects; 
                this.piercing = piercing;
                this.hitPlayers = new Set();
                this.gracePeriod = 0.1;

                const geo = new THREE.SphereGeometry(size, 8, 8);
                const mat = new THREE.MeshBasicMaterial({ color: (owner instanceof Player) ? owner.mesh.children[0].material.color : owner.owner.mesh.children[0].material.color });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(owner.mesh.position).add(new THREE.Vector3(0, 2, 0));
                
                const light = new THREE.PointLight(this.mesh.material.color, 2, 5);
                this.mesh.add(light);

                scene.add(this.mesh);
                if(audioReady) sounds.shoot.triggerAttackRelease("C5", "16n");
            }

            update(delta) {
                this.life -= delta;
                this.gracePeriod -= delta;
                if (this.life <= 0) { this.destroy(); return; }

                this.mesh.position.add(this.direction.clone().multiplyScalar(this.speed * delta));

                if (this.gracePeriod > 0) return;

                const projectilePos2D = new THREE.Vector2(this.mesh.position.x, this.mesh.position.z);

                for (const p of players) {
                    if (p !== this.owner && !this.hitPlayers.has(p)) {
                        const playerPos2D = new THREE.Vector2(p.mesh.position.x, p.mesh.position.z);
                        if (projectilePos2D.distanceTo(playerPos2D) < 1.5) {
                            p.takeDamage(this.damage);
                            if (this.effects) { Object.assign(p.status, this.effects); }
                            
                            if(!this.piercing) { this.destroy(); return; }
                            this.hitPlayers.add(p);
                        }
                    }
                }

                for (const obs of obstacles) { if (obs.containsPoint(this.mesh.position)) { this.destroy(); return; } }
                for (const obj of specialObjects) { if (obj.blocksProjectiles && obj.owner !== this.owner && obj.collider && obj.collider.containsPoint(this.mesh.position)) { this.destroy(); return; } }
            }

            destroy() {
                specialObjects.push(new ParticleExplosion(this.mesh.position, this.mesh.material.color, 10, 0.3));
                const index = projectiles.indexOf(this);
                if (index > -1) projectiles.splice(index, 1);
                scene.remove(this.mesh);
            }
        }
        
        class SpecialObject {
             constructor(owner, duration) {
                this.owner = owner;
                this.duration = duration;
                this.initialDuration = duration;
                this.mesh = null;
                this.collider = null;
                this.blocksProjectiles = false;
             }
             update(delta, players, projectiles) { this.duration -= delta; }
             destroy() { if(this.mesh) scene.remove(this.mesh); }
        }

        class SpawnEffect extends SpecialObject {
            constructor(position, color) {
                super(null, 1.5); // Effect lasts 1.5 seconds
                const ringCount = 5;
                this.rings = [];
                for(let i=0; i < ringCount; i++) {
                    const geo = new THREE.TorusGeometry(1, 0.05, 8, 32);
                    const mat = new THREE.MeshBasicMaterial({ color, transparent: true });
                    const ring = new THREE.Mesh(geo, mat);
                    ring.position.copy(position);
                    ring.position.y = (i * 0.8); // Start at different heights
                    ring.rotation.x = Math.PI / 2;
                    ring.scale.set(3, 3, 3);
                    scene.add(ring);
                    this.rings.push(ring);
                }
            }

            update(delta) {
                super.update(delta);
                const progress = 1 - (this.duration / this.initialDuration);
                this.rings.forEach((ring, i) => {
                    ring.position.y = (i * 0.8) * (1 - progress); // Move down
                    ring.scale.set(3 * (1 - progress), 3 * (1 - progress), 3 * (1 - progress)); // Shrink
                    ring.material.opacity = 1 - progress; // Fade out
                });
            }

            destroy() {
                this.rings.forEach(ring => scene.remove(ring));
            }
        }

        class PlayerAura extends SpecialObject {
            constructor(owner, particleCount, color, speed, size, inward = false) {
                super(owner, Infinity); 
                this.particles = [];
                this.inward = inward;
                const particleMat = new THREE.PointsMaterial({
                    color: color,
                    size: size,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false
                });

                const particleGeo = new THREE.BufferGeometry();
                const vertices = [];

                for (let i = 0; i < particleCount; i++) {
                    const x = (Math.random() - 0.5) * 4;
                    const y = this.inward ? 4 : Math.random() * 4;
                    const z = (Math.random() - 0.5) * 4;
                    vertices.push(x, y, z);

                    this.particles.push({
                        position: new THREE.Vector3(x, y, z),
                        velocity: new THREE.Vector3(0, (Math.random() * speed) * (this.inward ? -1 : 1), 0)
                    });
                }

                particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                this.mesh = new THREE.Points(particleGeo, particleMat);
                this.owner.mesh.add(this.mesh); 
            }

            update(delta) {
                const positions = this.mesh.geometry.attributes.position.array;
                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    p.position.add(p.velocity.clone().multiplyScalar(delta));
                    if (p.position.y > 4 && !this.inward) p.position.y = 0;
                    if (p.position.y < 0 && this.inward) p.position.y = 4;
                    
                    positions[i * 3 + 1] = p.position.y;
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
            }

            destroy() {
                if (this.owner && this.owner.mesh) {
                    this.owner.mesh.remove(this.mesh);
                }
                if(this.mesh) {
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }
            }
        }

        class StatusEffectVisual extends SpecialObject {
            constructor(owner, statusKey, color, particleCount = 20, style = 'swirl') {
                super(owner, Infinity); 
                this.statusKey = statusKey;
                this.style = style;

                const pointsGeo = new THREE.BufferGeometry();
                const vertices = [];
                this.particles = [];

                for (let i = 0; i < particleCount; i++) {
                    vertices.push(0, 0, 0); 
                    this.particles.push({
                        position: new THREE.Vector3(),
                        velocity: this.getRandomVelocity(),
                        life: Math.random() * 1.5,
                    });
                }
                pointsGeo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

                const pointsMat = new THREE.PointsMaterial({
                    color: color,
                    size: 0.2,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false,
                });

                this.mesh = new THREE.Points(pointsGeo, pointsMat);
                this.mesh.visible = false; 
                scene.add(this.mesh);
            }

            getRandomVelocity() {
                switch(this.style) {
                    case 'drip':
                        return new THREE.Vector3( (Math.random() - 0.5) * 0.5, -Math.random() * 2, (Math.random() - 0.5) * 0.5 );
                    case 'cloud':
                        return new THREE.Vector3( (Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5);
                    case 'swirl':
                    default:
                        return new THREE.Vector3( (Math.random() - 0.5) * 2, Math.random() * 1.5, (Math.random() - 0.5) * 2 );
                }
            }

            update(delta) {
                if (!this.owner || this.owner.hp <= 0 || this.owner.status[this.statusKey] <= 0) {
                    this.mesh.visible = false;
                    return;
                }

                this.mesh.visible = true;
                const positions = this.mesh.geometry.attributes.position.array;

                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    p.position.add(p.velocity.clone().multiplyScalar(delta));
                    p.life -= delta;

                    if (p.life <= 0) {
                        p.position.set(0, 2, 0); // Start from player center
                        p.velocity = this.getRandomVelocity();
                        p.life = Math.random() * 1.5;
                    }

                    const worldPos = this.owner.mesh.position.clone().add(p.position);
                    positions[i * 3] = worldPos.x;
                    positions[i * 3 + 1] = worldPos.y;
                    positions[i * 3 + 2] = worldPos.z;
                }
                this.mesh.geometry.attributes.position.needsUpdate = true;
            }

            destroy() {
                scene.remove(this.mesh);
                if(this.mesh) {
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }
            }
        }


        class Rift extends SpecialObject {
            constructor() {
                super(null, Infinity);
                this.state = 'COOLDOWN';
                this.timer = 5; // Initial cooldown
                
                const geo = new THREE.TorusKnotGeometry(1.5, 0.2, 100, 16);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.visible = false;
                scene.add(this.mesh);

                this.light = new THREE.PointLight(0xff00ff, 5, 10);
                this.mesh.add(this.light);
            }
            update(delta, players) {
                this.timer -= delta;
                
                if (this.state === 'COOLDOWN' && this.timer <= 0) {
                    this.state = 'ACTIVE';
                    this.timer = 10; // Active for 10 seconds
                    const x = (Math.random() - 0.5) * (arenaSize - 10);
                    const z = (Math.random() - 0.5) * (arenaSize - 10);
                    this.mesh.position.set(x, 2, z);
                    this.mesh.visible = true;
                } else if (this.state === 'ACTIVE') {
                    this.mesh.rotation.y += delta * 2;
                    this.mesh.rotation.x += delta * 0.5;

                    if(this.timer <= 0) {
                        this.state = 'COOLDOWN';
                        this.timer = 15;
                        this.mesh.visible = false;
                        return;
                    }

                    for(const p of players) {
                        if (p.mesh.position.distanceTo(this.mesh.position) < 3) {
                            p.status.riftBuff = 8;
                            this.state = 'COOLDOWN';
                            this.timer = 15;
                            this.mesh.visible = false;
                            break;
                        }
                    }
                }
            }
        }

        class ParticleExplosion extends SpecialObject {
            constructor(position, color, count = 20, duration = 1) {
                super(null, duration);
                this.particles = [];
                const particleMat = new THREE.MeshBasicMaterial({ color });

                for (let i = 0; i < count; i++) {
                    const particleGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const particle = new THREE.Mesh(particleGeo, particleMat);
                    particle.position.copy(position);
                    particle.velocity = new THREE.Vector3( (Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5) ).normalize().multiplyScalar(Math.random() * 15);
                    this.particles.push(particle);
                    scene.add(particle);
                }
            }
            update(delta) {
                super.update(delta);
                this.particles.forEach(p => {
                    p.position.add(p.velocity.clone().multiplyScalar(delta));
                    p.velocity.multiplyScalar(1 - 5 * delta);
                });
                if(this.duration < this.initialDuration / 2) {
                     this.particles.forEach(p => {
                          p.material.opacity = this.duration / (this.initialDuration / 2);
                          p.material.transparent = true;
                     });
                }
            }
            destroy() { this.particles.forEach(p => scene.remove(p)); }
        }
        
        class ExpandingRing extends SpecialObject {
            constructor(position, color, maxRadius, duration) {
                super(null, duration);
                const geo = new THREE.TorusGeometry(maxRadius, 0.1, 8, 48);
                const mat = new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide, transparent: true });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(position);
                this.mesh.position.y = 0.5;
                this.mesh.rotation.x = Math.PI / 2;
                this.mesh.scale.set(0.01, 0.01, 0.01);
                scene.add(this.mesh);
            }
            update(delta) {
                super.update(delta);
                const progress = 1 - (this.duration / this.initialDuration);
                this.mesh.scale.set(progress, progress, progress);
                this.mesh.material.opacity = 1 - progress;
            }
        }

        class StaticField extends SpecialObject {
            constructor(owner) {
                super(owner, 5);
                const geo = new THREE.CylinderGeometry(4, 4, 0.5, 32, 1, true);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(owner.mesh.position);
                this.mesh.position.y = 0.25;
                scene.add(this.mesh);
                this.damageInterval = 0.5;
                this.damageTimer = 0;
            }

            update(delta, players) {
                super.update(delta);
                this.damageTimer -= delta;
                if (this.damageTimer <= 0) {
                    this.damageTimer = this.damageInterval;
                    players.forEach(p => {
                        if (p !== this.owner && p.mesh.position.distanceTo(this.mesh.position) < 4) {
                            p.takeDamage(5);
                        }
                    });
                }
            }
        }
        
        class ShieldEffect extends SpecialObject {
            constructor(owner, duration, color = 0xADD8E6) {
                super(owner, duration);
                const geo = new THREE.SphereGeometry(2, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4, side: THREE.DoubleSide});
                this.mesh = new THREE.Mesh(geo, mat);
                scene.add(this.mesh);
            }
            update(delta) {
                super.update(delta);
                if(this.owner) {
                    this.mesh.position.copy(this.owner.mesh.position);
                    this.mesh.position.y = 2;
                } else {
                    this.duration = 0;
                }
            }
        }

        class SlowingMine extends SpecialObject {
            constructor(owner, position) {
                super(owner, 20);
                const geo = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16);
                const mat = new THREE.MeshStandardMaterial({ color: 0x32cd32 });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(position);
                this.mesh.position.y = 0.1;
                scene.add(this.mesh);
                this.armed = false;
                setTimeout(() => { this.armed = true; }, 1000);
            }
            update(delta, players) {
                super.update(delta);
                if (!this.armed) return;

                players.forEach(p => {
                    if (p !== this.owner && p.mesh.position.distanceTo(this.mesh.position) < 2) {
                        p.status.slowed = 3;
                        this.duration = 0;
                        if(audioReady) sounds.explosion.triggerAttackRelease("A3", "4n");
                    }
                });
            }
        }
        
        class LaserCore extends SpecialObject {
             constructor(owner, target) {
                 super(owner, 2.5);
                 this.target = target;
                 const distance = owner.mesh.position.distanceTo(target.mesh.position);
                 const geo = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
                 const mat = new THREE.MeshBasicMaterial({ color: 0x32cd32, transparent: true, opacity: 0.8 });
                 this.mesh = new THREE.Mesh(geo, mat);
                 scene.add(this.mesh);
                 this.damageInterval = 0.2;
                 this.damageTimer = 0;
             }
             update(delta, players) {
                super.update(delta);
                if(!this.target || !this.owner) { this.duration = 0; return; }

                const start = this.owner.mesh.position;
                const end = this.target.mesh.position;
                const distance = start.distanceTo(end);
                this.mesh.scale.y = distance;
                this.mesh.position.copy(start).lerp(end, 0.5);
                this.mesh.position.y = 2;

                const up = new THREE.Vector3(0, 1, 0);
                const axis = new THREE.Vector3().subVectors(end, start).normalize();
                this.mesh.quaternion.setFromUnitVectors(up, axis);

                 this.damageTimer -= delta;
                if (this.damageTimer <= 0) {
                    this.damageTimer = this.damageInterval;
                    this.target.takeDamage(3);
                }
             }
        }

        class WindWall extends SpecialObject {
            constructor(owner, position, quaternion) {
                super(owner, 6);
                const geo = new THREE.PlaneGeometry(8, 5);
                const mat = new THREE.MeshBasicMaterial({ color: 0x90ee90, transparent: true, opacity: 0.4, side: THREE.DoubleSide});
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(position);
                this.mesh.position.y = 2.5;
                this.mesh.quaternion.copy(quaternion);
                scene.add(this.mesh);
                
                const helper = new THREE.BoxHelper(this.mesh);
                helper.update();
                this.collider = new THREE.Box3().setFromObject(helper);

                this.blocksProjectiles = true;
            }
             update(delta) { super.update(delta); }
        }
        
        class StasisField extends SpecialObject {
            constructor(owner, position) {
                super(owner, 5);
                 const geo = new THREE.SphereGeometry(3, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ color: 0x40e0d0, transparent: true, opacity: 0.3});
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(position);
                this.mesh.position.y = 2;
                scene.add(this.mesh);
            }
            update(delta, players) {
                super.update(delta);
                 players.forEach(p => {
                    if (p !== this.owner && p.mesh.position.distanceTo(this.mesh.position) < 3) {
                        p.status.rooted = 0.5; // Constantly re-apply root
                    }
                });
            }
        }
        
        class Cyclone extends SpecialObject {
            constructor(owner) {
                super(owner, 4);
            }
            update(delta, players) {
                super.update(delta);
                const opponent = players.find(p => p !== this.owner);
                if(opponent) {
                    const pullDirection = new THREE.Vector3().subVectors(this.owner.mesh.position, opponent.mesh.position);
                    if(pullDirection.length() < 12) {
                        pullDirection.normalize();
                        opponent.velocity.add(pullDirection.multiplyScalar(15 * delta));
                    }
                }
            }
        }

        class Decimate extends SpecialObject {
            constructor(owner) {
                super(owner, 0.5);
                const geo = new THREE.TorusGeometry( 3, 0.2, 8, 32 );
                const mat = new THREE.MeshBasicMaterial({color: 0xdc143c});
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(owner.mesh.position);
                this.mesh.rotation.x = Math.PI / 2;
                this.mesh.scale.set(0.1, 0.1, 0.1);
                scene.add(this.mesh);
                this.hit = false;
            }
            update(delta, players){
                super.update(delta);
                const scale = (1 - (this.duration / this.initialDuration)) * 1.2;
                this.mesh.scale.set(scale, scale, scale);

                if(!this.hit) {
                    const opponent = players.find(p => p !== this.owner);
                    if(opponent && opponent.mesh.position.distanceTo(this.mesh.position) < (3 * scale)){
                        opponent.takeDamage(20);
                        this.hit = true;
                    }
                }
            }
        }
        
        class MeleeSlash extends SpecialObject {
            constructor(owner, color) {
                super(owner, 0.4);
                const shape = new THREE.Shape();
                shape.moveTo(0, -2.5);
                shape.absarc(0, 0, 2.5, -Math.PI / 2.5, Math.PI / 2.5, false);
                shape.lineTo(0, -2.5);

                const geo = new THREE.ShapeGeometry(shape);
                const mat = new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide, transparent: true });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.position.copy(owner.mesh.position);
                this.mesh.position.y = 2;
                this.mesh.quaternion.copy(owner.mesh.quaternion);
                this.mesh.position.add(owner.aimDirection.clone().multiplyScalar(0.5));
                
                scene.add(this.mesh);
            }
             update(delta) { 
                 super.update(delta);
                 this.mesh.material.opacity = this.duration / this.initialDuration;
            }
        }


        class TectonicSlam extends SpecialObject {
             constructor(owner) {
                super(owner, 1);
                 const opponent = players.find(p => p !== this.owner);
                 if(opponent && opponent.mesh.position.distanceTo(owner.mesh.position) < 5) {
                    opponent.takeDamage(15);
                    opponent.status.slowed = 2;
                 }
                 if(audioReady) sounds.explosion.triggerAttackRelease("C2", "2n");
             }
             update(delta) { super.update(delta); }
        }

        class SentryTurret extends SpecialObject {
            constructor(owner) {
                super(owner, 4); // 4 second duration
                
                const baseGeo = new THREE.CylinderGeometry(0.5, 0.7, 1, 8);
                const baseMat = new THREE.MeshStandardMaterial({ color: owner.mesh.children[0].material.color.clone().multiplyScalar(0.7) });
                const base = new THREE.Mesh(baseGeo, baseMat);

                const headGeo = new THREE.SphereGeometry(0.4, 8, 8);
                const headMat = new THREE.MeshStandardMaterial({ color: owner.mesh.children[0].material.color });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.7;

                this.mesh = new THREE.Group();
                this.mesh.add(base);
                this.mesh.add(head);
                
                this.mesh.position.copy(owner.mesh.position).add(owner.aimDirection.clone().multiplyScalar(2));
                this.mesh.position.y = 0.5;
                
                scene.add(this.mesh);
                
                this.fireRate = 0.75;
                this.fireTimer = 0;
                this.head = head; // Reference to the head for aiming
            }

            update(delta, players) {
                super.update(delta);
                this.fireTimer -= delta;

                const opponent = players.find(p => p !== this.owner);
                if (!opponent) return;

                // Aim at the opponent
                const targetPosition = opponent.mesh.position.clone();
                this.head.lookAt(targetPosition);

                if (this.fireTimer <= 0) {
                    this.fireTimer = this.fireRate;
                    
                    const startPosition = new THREE.Vector3();
                    this.head.getWorldPosition(startPosition);
                    
                    const fireDirection = new THREE.Vector3().subVectors(opponent.mesh.position, startPosition).normalize();

                    const proj = new Projectile(this.owner, fireDirection, 5, 25, {});
                    proj.mesh.position.copy(startPosition);
                    projectiles.push(proj);
                }
            }
        }

        class StatusAura extends SpecialObject {
            constructor(owner, duration, color) {
                super(owner, duration);
                const geo = new THREE.TorusGeometry(1.5, 0.05, 8, 48);
                const mat = new THREE.MeshBasicMaterial({ color, transparent: true });
                this.mesh = new THREE.Mesh(geo, mat);
                this.mesh.rotation.x = Math.PI / 2;
                scene.add(this.mesh);
            }
            update(delta) {
                super.update(delta);
                if (this.owner && this.owner.hp > 0) {
                    this.mesh.position.copy(this.owner.mesh.position);
                    this.mesh.position.y = 0.1;
                    this.mesh.material.opacity = this.duration / this.initialDuration;
                } else {
                    this.duration = 0;
                }
            }
        }

        class EyeOfTheStorm extends SpecialObject {
            constructor(owner) {
                super(owner, 6);
                this.damageInterval = 0.5;
                this.damageTimer = 0;
                this.pullRadius = 15;
                this.damageRadius = 6;
                
                const stormGeo = new THREE.TorusGeometry(this.damageRadius, 0.2, 16, 100);
                const stormMat = new THREE.MeshBasicMaterial({ color: 0x1e90ff, blending: THREE.AdditiveBlending, transparent: true });
                this.mesh = new THREE.Mesh(stormGeo, stormMat);
                this.mesh.rotation.x = Math.PI / 2;
                scene.add(this.mesh);
            }

            update(delta, players) {
                super.update(delta);
                if (!this.owner || this.owner.hp <= 0) {
                    this.duration = 0;
                    return;
                }

                this.mesh.position.copy(this.owner.mesh.position);
                this.mesh.position.y = 0.2;
                this.mesh.rotation.z += delta * 3;
                this.mesh.material.opacity = 0.5 + Math.sin(this.duration * 5) * 0.25;


                const opponent = players.find(p => p !== this.owner);
                if (opponent) {
                    const pullDirection = new THREE.Vector3().subVectors(this.owner.mesh.position, opponent.mesh.position);
                    const distance = pullDirection.length();

                    if (distance < this.pullRadius) {
                        pullDirection.normalize();
                        opponent.velocity.add(pullDirection.multiplyScalar(35 * delta * (1 - distance / this.pullRadius)));
                    }
                }
                
                this.damageTimer -= delta;
                if (this.damageTimer <= 0) {
                    this.damageTimer = this.damageInterval;
                    players.forEach(p => {
                        if (p.mesh.position.distanceTo(this.mesh.position) < this.damageRadius) {
                            if (p !== this.owner) p.takeDamage(8, true); // Damage over time
                        }
                    });
                }
            }
        }


        function endGame(winnerNum) {
            gameState = 'GAME_OVER';
            const winnerData = CHARACTERS[players[winnerNum - 1].characterKey];
            const winnerNickname = loggedInUsers[winnerNum === 1 ? 'p1' : 'p2'];

            // Update winner's score in persistent localStorage
            const users = getUsers();
            if (users[winnerNickname]) {
                users[winnerNickname].wins++;
                saveUsers(users);
            }
            
            document.getElementById('winner-text').innerHTML = `<span style="color: #${new THREE.Color(winnerData.color).getHexString()}">${winnerNickname} (${winnerData.name}) WINS!</span>`;
            switchScreen('game-over-screen');
        }

        function resetGame(returnToMenu = false) {
             players.forEach(p => p.destroy());
             projectiles.forEach(p => p.destroy());
             specialObjects.forEach(o => o.destroy());

             players = [];
             projectiles = [];
             specialObjects = [];

             p1Select = -1; p2Select = -1;
             p1Locked = false; p2Locked = false;

             document.getElementById('ui-container').style.opacity = 0;
             if (returnToMenu) {
                 gameState = 'START_SCREEN';
                 switchScreen('start-screen');
             }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (gameState === 'ACTIVE' && players.length === 2) {
                const [p1, p2] = players;
                p1.update(delta, p2);
                p2.update(delta, p1);

                for(let i = projectiles.length - 1; i >= 0; i--) projectiles[i].update(delta);
                for(let i = specialObjects.length - 1; i >= 0; i--) {
                    specialObjects[i].update(delta, players, projectiles);
                    if(specialObjects[i].duration <= 0) {
                        specialObjects[i].destroy();
                        specialObjects.splice(i, 1);
                    }
                }

                updateUI();
                
                const p1Pos = players[0].mesh.position;
                const p2Pos = players[1].mesh.position;
                const midPoint = new THREE.Vector3().addVectors(p1Pos, p2Pos).multiplyScalar(0.5);
                const distance = Math.max(15, p1Pos.distanceTo(p2Pos));
                const zoomLevel = Math.min(40, distance * 1.2);
                const newCamPos = new THREE.Vector3(midPoint.x, zoomLevel, midPoint.z + (zoomLevel * 0.5));
                camera.position.lerp(newCamPos, 0.05);
                camera.lookAt(midPoint);

            } else if (gameState !== 'COUNTDOWN') {
                const time = clock.getElapsedTime();
                camera.position.set(Math.sin(time * 0.1) * 25, 15, Math.cos(time * 0.1) * 25);
                camera.lookAt(0, 0, 0);
            }
            renderer.render(scene, camera);
        }
        
        // --- 3. EXECUTION CODE (EVENT LISTENERS AND INITIAL CALL) ---
        
        window.addEventListener('DOMContentLoaded', () => {
            const loginNickInput = document.getElementById('login-nickname');
            const loginPassInput = document.getElementById('login-password');
            const loginMsg = document.getElementById('login-message');
            const leaderboardMsg = document.getElementById('leaderboard-message');

            document.getElementById('signup-button').addEventListener('click', () => {
                const nick = loginNickInput.value.trim();
                const pass = loginPassInput.value.trim();
                
                if (nick.length < 3) { loginMsg.textContent = "Nickname must be at least 3 characters."; return; }
                if (pass.length < 4) { loginMsg.textContent = "Password must be at least 4 characters."; return; }
                if (nick === loggedInUsers.p1) { loginMsg.textContent = "Player 2 cannot have the same nickname."; return; }

                const users = getUsers();
                if (users[nick]) {
                    loginMsg.textContent = "Nickname is already taken.";
                } else {
                    users[nick] = { password: pass, wins: 0 };
                    saveUsers(users);
                    loginMsg.textContent = "Sign up successful! Now logging in...";
                    setTimeout(() => handleSuccessfulLogin(nick), 1000);
                }
            });

            document.getElementById('login-button').addEventListener('click', () => {
                const nick = loginNickInput.value.trim();
                const pass = loginPassInput.value.trim();

                if (!nick || !pass) { loginMsg.textContent = "Please enter nickname and password."; return; }
                if (nick === loggedInUsers.p1) { loginMsg.textContent = "Player 2 cannot have the same nickname."; return; }

                const users = getUsers();
                if (users[nick] && users[nick].password === pass) {
                    loginMsg.textContent = "Login successful!";
                    setTimeout(() => handleSuccessfulLogin(nick), 500);
                } else {
                    loginMsg.textContent = "Invalid nickname or password.";
                }
            });

             document.getElementById('export-leaderboard-button').addEventListener('click', () => {
                const users = getUsers();
                const jsonString = JSON.stringify(users);
                const base64String = btoa(unescape(encodeURIComponent(jsonString)));
                navigator.clipboard.writeText(base64String).then(() => {
                    leaderboardMsg.textContent = "Data exported and copied to clipboard!";
                }, () => {
                    leaderboardMsg.textContent = "Failed to copy to clipboard.";
                });
            });

            document.getElementById('import-leaderboard-button').addEventListener('click', () => {
                const importArea = document.getElementById('import-data-area');
                const base64String = importArea.value.trim();
                if (!base64String) {
                    leaderboardMsg.textContent = "Paste data into the text box first.";
                    return;
                }
                try {
                    const decodedJson = decodeURIComponent(escape(atob(base64String)));
                    const importedUsers = JSON.parse(decodedJson);
                    const localUsers = getUsers();
                    
                    // Merge logic
                    let mergedCount = 0;
                    for (const [name, importedData] of Object.entries(importedUsers)) {
                        if (localUsers[name]) {
                            // User exists, merge by taking the max wins
                            if (importedData.wins > localUsers[name].wins) {
                                localUsers[name].wins = importedData.wins;
                                mergedCount++;
                            }
                        } else {
                            // New user, just add them
                            localUsers[name] = importedData;
                            mergedCount++;
                        }
                    }
                    saveUsers(localUsers);
                    displayLeaderboard();
                    importArea.value = '';
                    leaderboardMsg.textContent = `Successfully merged ${mergedCount} player record(s)!`;

                } catch (error) {
                    leaderboardMsg.textContent = "Error: Invalid or corrupted data string.";
                    console.error("Import failed:", error);
                }
            });
            
            document.getElementById('start-classic-duel-button').addEventListener('click', () => { 
                gameMode = 'CLASSIC';
                gameState = 'CHAR_SELECT'; 
                switchScreen('char-select-screen'); 
                setupCharSelect(); 
            });
            document.getElementById('start-rift-duel-button').addEventListener('click', () => { 
                gameMode = 'RIFT';
                gameState = 'CHAR_SELECT'; 
                switchScreen('char-select-screen'); 
                setupCharSelect(); 
            });
            document.getElementById('leaderboard-button').addEventListener('click', () => {
                gameState = 'LEADERBOARD';
                leaderboardMsg.textContent = '\u00A0'; // Reset message
                displayLeaderboard();
                switchScreen('leaderboard-screen');
            });
            document.getElementById('leaderboard-back-button').addEventListener('click', () => {
                gameState = 'START_SCREEN';
                switchScreen('start-screen');
            });

            document.getElementById('settings-button').addEventListener('click', () => { 
                gameState = 'SETTINGS'; 
                switchScreen('settings-screen'); 
            });
            document.getElementById('settings-back-button').addEventListener('click', () => { 
                if (currentlyBinding) {
                   const waitingButton = document.querySelector('.keybind-button.waiting');
                   if (waitingButton) waitingButton.classList.remove('waiting');
                   currentlyBinding = null;
                   populateSettings();
                }
                gameState = 'START_SCREEN'; 
                switchScreen('start-screen'); 
            });
            document.querySelectorAll('.keybind-button').forEach(button => { 
                button.addEventListener('click', () => { 
                    if(currentlyBinding) { 
                        const waitingButton = document.querySelector('.keybind-button.waiting');
                        if(waitingButton) waitingButton.classList.remove('waiting'); 
                    } 
                    currentlyBinding = { player: button.dataset.player, action: button.dataset.action }; 
                    button.textContent = '...'; 
                    button.classList.add('waiting'); 
                }); 
            });
            document.getElementById('restart-button').addEventListener('click', () => resetGame(true));
            
            populateSettings();
            animate();
        });

        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (currentlyBinding) {
                e.preventDefault();
                controls[currentlyBinding.player][currentlyBinding.action] = key;
                currentlyBinding = null;
                const waitingButton = document.querySelector('.keybind-button.waiting');
                if (waitingButton) waitingButton.classList.remove('waiting');
                populateSettings();
                return;
            }

            keys[key] = true;

            if (gameState === 'ACTIVE' && players.length === 2) {
                 let actionTaken = false;
                 // Check if the key pressed is one of the action keys
                 for(const player in controls) {
                     for(const action in controls[player]) {
                         if(controls[player][action] === key) {
                             actionTaken = true;
                             break;
                         }
                     }
                     if(actionTaken) break;
                 }


                 if(actionTaken) {
                    e.preventDefault();
                    const [p1, p2] = players;
                     if (key === controls.p1.basicAttack) p1.useSkill('basicAttack');
                     if (key === controls.p1.skill1) p1.useSkill('s1');
                     if (key === controls.p1.skill2) p1.useSkill('s2');
                     if (key === controls.p1.skill3) p1.useSkill('s3');
                     
                     if (key === controls.p2.basicAttack) p2.useSkill('basicAttack');
                     if (key === controls.p2.skill1) p2.useSkill('s1');
                     if (key === controls.p2.skill2) p2.useSkill('s2');
                     if (key === controls.p2.skill3) p2.useSkill('s3');
                 }
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        document.body.addEventListener('click', async () => {
            if (!audioReady) {
                await Tone.start();
                audioReady = true;
                console.log("Audio context started.");
            }
        }, { once: true });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

