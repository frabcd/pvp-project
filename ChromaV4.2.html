<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chroma Core Arena — V5.2 (Camera & Minimap Fix)</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

  <!-- Three.js import map -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
      }
    }
  </script>

  <style>
    body { margin: 0; padding: 0; background-color: #000; color: #fff; font-family: 'Orbitron', 'Consolas', monospace; overflow: hidden; }
    canvas { position: absolute; top: 0; left: 0; z-index: 1; }
    .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(5, 5, 10, 0.8); z-index: 200; transition: opacity 0.5s, visibility 0s 0.5s; opacity: 0; visibility: hidden; backdrop-filter: blur(10px); }
    .screen.active { opacity: 1; visibility: visible; transition-delay: 0s; }
    .panel { background: rgba(10, 20, 30, 0.7); border: 1px solid #00ffff; border-radius: 10px; padding: 40px; box-shadow: 0 0 25px rgba(0, 255, 255, 0.5); text-align: center; max-width: 90vw; width: 900px; }
    .menu-button { padding: 15px 40px; font-size: 1.2em; background-color: #111; border: 2px solid #fff; color: #fff; cursor: pointer; border-radius: 6px; transition: all 0.2s; font-family: 'Orbitron', sans-serif; margin: 8px; width: 350px; text-align: center; }
    .menu-button:hover:not(:disabled) { background-color: #fff; color: #000; box-shadow: 0 0 15px #fff; }
    .menu-button:disabled { cursor: not-allowed; opacity: 0.5; }
    input { padding: 12px; font-size: 1.1em; background-color: #111; border: 2px solid #fff; color: #fff; border-radius: 6px; width: 350px; margin: 6px auto; display: block; text-align: center; }
    #login-message, #leaderboard-message, #room-status { min-height: 20px; color: #00ffff; }
    #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 10; }
    .player-hud { position: absolute; bottom: 20px; display: flex; align-items: center; gap: 12px; background: rgba(10, 20, 30, 0.7); border-radius: 10px; padding: 10px; border: 1px solid #555; backdrop-filter: blur(5px); }
    #player1-hud { left: 20px; }
    #player2-hud { right: 20px; flex-direction: row-reverse; }
    .portrait-container { position: relative; width: 100px; height: 100px; }
    .portrait { width: 100%; height: 100%; border-radius: 50%; border: 3px solid; object-fit: cover; }
    .portrait-canvas { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 160px; height: 160px; z-index: -1; }
    .circular-bars svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: rotate(-90deg); }
    .bar-bg { fill: none; stroke: rgba(0,0,0,0.3); }
    .bar-fill { fill: none; transition: stroke-dashoffset 0.3s ease; }
    #p1-health-bar-fill, #p2-health-bar-fill { stroke: #0f0; }
    #p1-energy-bar-fill, #p2-energy-bar-fill { stroke: #ff0; }
    .hud-details { display: flex; flex-direction: column; }
    .skills-container { display: flex; gap: 8px; margin-bottom: 5px; }
    .skill { width: 40px; height: 40px; border: 2px solid #888; border-radius: 6px; position: relative; background-color: #222; display: flex; justify-content: center; align-items: center; font-size: 1.1em; font-weight: bold; }
    .skill.ready { border-color: #fff; box-shadow: 0 0 8px #fff; }
    .cooldown-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.85); color: white; display: flex; justify-content: center; align-items: center; font-size: 1.1em; font-weight: bold; pointer-events: none; opacity: 0; transition: opacity 0.1s; border-radius: 4px; }
    #game-message-container { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: 4.5em; font-weight: 900; text-shadow: 0 0 20px #fff; z-index: 50; }

    /* Styles for floating damage text */
    .damage-text {
        position: absolute;
        font-size: 1.5em;
        font-weight: bold;
        color: #ff4444; /* Red color for damage */
        text-shadow: 0 0 5px #000;
        pointer-events: none;
        user-select: none;
        z-index: 150;
        transition: transform 1s ease-out, opacity 1s ease-out; /* Animation */
        transform: translate(-50%, 0); /* Start centered horizontally */
    }

    /* Styles for Minimap Canvas */
    #minimap {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 200px; /* Canvas width */
        height: 200px; /* Canvas height */
        /* Background/border applied directly for better control */
        background-color: rgba(10, 20, 30, 0.7);
        border: 1px solid #00ffff;
        border-radius: 50%; /* Make the container circular */
        z-index: 100;
        opacity: 0.8;
        overflow: hidden; /* Clip contents to the circle */
    }

    /* NEW: Tutorial Styles */
    #tutorial-overlay {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 9998;
        display: none; /* Hidden by default */
        pointer-events: none; /* Allow clicks through */
    }
    #tutorial-box {
        position: absolute;
        background: rgba(10, 20, 30, 0.9);
        border: 1px solid #00ffff;
        border-radius: 10px;
        padding: 25px;
        box-shadow: 0 0 25px rgba(0, 255, 255, 0.5);
        font-size: 1.3em;
        line-height: 1.6;
        max-width: 500px;
        z-index: 9999;
        text-align: center;
        /* Position will be set by JS */
    }
    #tutorial-arrow {
        position: absolute;
        width: 60px;
        height: 60px;
        z-index: 9999;
        font-size: 60px;
        color: #00ffff;
        text-shadow: 0 0 10px #00ffff;
        transform-origin: center;
        /* Position and rotation will be set by JS */
    }

    .tabs { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin: 10px 0 16px; }
    .tab { padding: 8px 12px; border: 1px solid #888; border-radius: 6px; cursor: pointer; }
    .tab.active { border-color: #00ffff; color: #00ffff; box-shadow: 0 0 8px #00ffff; }
    #char-select-screen .panel { max-width: 95vw; width: 1500px; }
    .char-grid { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; width: 100%; margin-bottom: 20px; max-height: 60vh; overflow-y: auto; padding: 10px;}
    .char-card { width: 220px; height: 340px; border: 2px solid #555; border-radius: 10px; background: rgba(17,17,17,.85); padding: 10px; transition: all .2s; display: flex; flex-direction: column; justify-content: space-between; cursor: pointer; }
    .char-card:not(.locked-by-p1):not(.locked-by-p2):hover { border-color: #fff; box-shadow: 0 0 10px #fff; transform: translateY(-3px); }
    .char-portrait { width: 100%; height: 40%; border-radius: 5px; background-size: cover; background-position: center; }
    .char-card.locked-by-p1 { border-color: #00ffff; box-shadow: 0 0 15px #00ffff; transform: scale(1.04); }
    .char-card.locked-by-p2 { border-color: #ff00ff; box-shadow: 0 0 15px #ff00ff; transform: scale(1.04); }
    .leaderboard-header, .leaderboard-row { display: flex; padding: 10px; }
    .leaderboard-header { font-weight: bold; color: #00ffff; border-bottom: 2px solid #00ffff; }
    .leaderboard-row { border-bottom: 1px solid #333; }
    .leaderboard-row:nth-child(odd) { background-color: rgba(0,0,0,0.2); }
    .rank { width: 15%; text-align: center; }
    .name { width: 60%; }
    .score { width: 25%; text-align: right; font-weight: bold; color: #fff; }
    #import-data-area { width: 90%; height: 60px; background-color: #111; color: #eee; border: 1px solid #888; border-radius: 5px; padding: 10px; font-family: 'Consolas', monospace; margin-bottom: 10px; }
  </style>
</head>
<body>
  <!-- LOGIN -->
  <div id="login-screen" class="screen active">
    <div class="panel">
      <h1 id="login-title">PLAYER LOGIN</h1>
      <input id="login-nickname" type="text" placeholder="NICKNAME (3-10 chars)" maxlength="10" minlength="3">
      <input id="login-password" type="password" placeholder="PASSWORD (min 4 chars)" minlength="4">
      <p id="login-message">&nbsp;</p>
      <div style="display:flex;justify-content:center;gap:18px">
        <button id="login-button" class="menu-button" style="width:200px;">LOGIN</button>
        <button id="signup-button" class="menu-button" style="width:200px;">SIGN UP</button>
      </div>
        <button id="guest-login-button" class="menu-button" style="width:200px; margin-top: 10px;">Play as Guest</button>
    </div>
  </div>

  <!-- NEW: TUTORIAL PROMPT -->
  <div id="tutorial-prompt-screen" class="screen">
    <div class="panel">
      <h1>WELCOME TO CHROMA CORE!</h1>
      <p style="font-size: 1.2em; margin-bottom: 30px;">We see you're new here. Would you like a quick tutorial to learn the controls?</p>
      <div style="display:flex;justify-content:center;gap:18px">
        <button id="tutorial-start-button" class="menu-button" style="width:250px;">Start Tutorial</button>
        <button id="tutorial-skip-button" class="menu-button" style="width:250px;">Skip</button>
      </div>
    </div>
  </div>

  <!-- START -->
  <div id="start-screen" class="screen">
    <div class="panel">
      <h1>CHROMA CORE ARENA V5</h1>
      <div class="tabs" id="mode-tabs">
        <div class="tab active" data-mode="LOCAL_CLASSIC">Local Classic Duel</div>
        <div class="tab" data-mode="LOCAL_RIFT">Local Rift Duel</div>
        <div class="tab" data-mode="ONLINE_CLASSIC">Online Classic Duel</div>
        <div class="tab" data-mode="ONLINE_RIFT">Online Rift Duel</div>
      </div>
      <button id="start-button" class="menu-button">START LOCAL DUEL</button>
      <button id="leaderboard-button" class="menu-button">LEADERBOARD</button>
      <button id="settings-button" class="menu-button">SETTINGS</button>

      <!-- Matchmaking UI -->
      <div id="online-controls" style="display:none;margin-top:14px">
        <button id="find-match-button" class="menu-button">Find Online Match</button>
        <button id="cancel-match-button" class="menu-button" style="display:none; background-color:#c00;">Cancel Search</button>
        <p id="room-status">&nbsp;</p>
      </div>
    </div>
  </div>

  <!-- LEADERBOARD -->
  <div id="leaderboard-screen" class="screen">
    <div class="panel" style="width: 900px;">
      <h1>LEADERBOARD</h1>
      <div class="tabs" id="lb-tabs">
        <div class="tab active" data-lb="LOCAL_CLASSIC">Local Classic</div>
        <div class="tab" data-lb="LOCAL_RIFT">Local Rift</div>
        <div class="tab" data-lb="ONLINE_CLASSIC">Online Classic</div>
        <div class="tab" data-lb="ONLINE_RIFT">Online Rift</div>
      </div>
      <div id="leaderboard-table"></div>
      <p id="leaderboard-message">&nbsp;</p>
      <div id="import-export-section" style="margin-top:20px;border-top:1px solid #00ffff;padding-top:12px">
        <textarea id="import-data-area" placeholder="Paste exported leaderboard snapshot JSON here (optional)…"></textarea>
        <div style="display:flex;gap:12px;justify-content:center">
          <button id="import-leaderboard-button" class="menu-button" style="width:auto;">Import Snapshot</button>
          <button id="export-leaderboard-button" class="menu-button" style="width:auto;">Export Snapshot</button>
        </div>
      </div>
      <button id="leaderboard-back-button" class="menu-button" style="margin-top: 16px;">BACK</button>
    </div>
  </div>

  <!-- SETTINGS -->
  <div id="settings-screen" class="screen">
    <div class="panel">
      <h1>SETTINGS</h1>
      <p style="margin-bottom: 25px;">Player controls for local multiplayer mode. Online mode uses Player 1 controls.</p>
      <div class="settings-container" style="display:flex;gap:50px;flex-wrap:wrap;justify-content:center">
        <div class="player-settings">
          <h2 style="color:#00ffff;">PLAYER 1 (WASD)</h2>
          <div>Forward: W</div><div>Backward: S</div><div>Left: A</div><div>Right: D</div>
          <div>Basic: Space</div><div>Skill 1: Q</div><div>Skill 2: E</div><div>Skill 3: R</div><div>Skill 4 (Ult): F</div>
        </div>
        <div class="player-settings">
          <h2 style="color:#ff00ff;">PLAYER 2 (IJKL)</h2>
          <div>Forward: I</div><div>Backward: K</div><div>Left: J</div><div>Right: L</div>
          <div>Basic: Enter</div><div>Skill 1: U</div><div>Skill 2: O</div><div>Skill 3: P</div><div>Skill 4 (Ult): H</div>
        </div>
      </div>
      <button id="settings-back-button" class="menu-button">BACK</button>
    </div>
  </div>

  <!-- CHAR SELECT -->
  <div id="char-select-screen" class="screen">
    <div class="panel">
      <h1>CHOOSE YOUR ECHO</h1>
      <div id="char-grid" class="char-grid"></div>
      <div id="char-select-footer">
        <p id="lock-in-status">Player 1: Click to select your Echo</p>
      </div>
    </div>
  </div>

  <!-- GAME OVER -->
  <div id="game-over-screen" class="screen">
    <div class="panel">
      <div id="winner-text" style="font-size: 2.4em; margin-bottom: 20px;"></div>
      <button id="restart-button" class="menu-button">RETURN TO MENU</button>
    </div>
  </div>

  <!-- HUD & Countdowns -->
  <div id="ui-container">
    <canvas id="minimap" width="200" height="200"></canvas>
    <div id="player1-hud" class="player-hud"></div>
    <div id="player2-hud" class="player-hud"></div>
  </div>
  <div id="game-message-container"><span id="countdown-text"></span></div>

  <!-- NEW: Tutorial Overlay -->
  <div id="tutorial-overlay">
    <div id="tutorial-arrow">⬇</div>
    <div id="tutorial-box">
      <span id="tutorial-text">Welcome to the tutorial!</span>
    </div>
  </div>

  <!-- Audio -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-app.js";
    import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, updateProfile, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, updateDoc, collection, query, orderBy, limit, getDocs, serverTimestamp, onSnapshot, increment, where, deleteDoc, addDoc, writeBatch } from "https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore.js";
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    // --- ADDED ORBIT CONTROLS IMPORT ---
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    /*
    * ======================================
    * V5.2 "CAMERA & MINIMAP FIX" UPDATE
    * ======================================
    * - Added OrbitControls for camera movement in menus.
    * - Camera automatically circles the arena in menus.
    * - Fixed "forever white" bug on player damage/death.
    * - Corrected minimap drawing logic.
    * - Inherited fixes from V5.1 (internal patch).
    * ======================================
    * V5.0 "LEGACY" UPDATE
    * ======================================
    * - FEATURE: PASSIVE ABILITIES
    * - FEATURE: 4-SKILL SYSTEM & ULTIMATES
    * - GRAPHICS: CHARACTER MODEL OVERHAUL
    * - UI: Updated HUD, Char Select, Settings
    * - BALANCE: Rebalanced costs/cooldowns
    * - BUGFIX: Online mode fixes, memory leaks, error handling
    */

    /********** Firebase Init **********/
    const firebaseConfig = {
      apiKey: "AIzaSyCuBgpaWTxOxpFLxe7GfQY8UytWb3LkpvY",
      authDomain: "chroma-core-arena.firebaseapp.com",
      projectId: "chroma-core-arena",
      storageBucket: "chroma-core-arena.firebasestorage.app",
      messagingSenderId: "314470360799",
      appId: "1:314470360799:web:55cfee1b216fcf51072b6a"
    };
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    window.CCA = window.CCA || {};
    CCA.firebase = { auth, db, serverTimestamp, doc, setDoc, getDoc, updateDoc, collection, query, orderBy, limit, getDocs, onSnapshot, increment, addDoc, deleteDoc, writeBatch };
    const $$ = id => document.getElementById(id);

    const MODES = {
      LOCAL_CLASSIC:  { key:'LOCAL_CLASSIC',  rift:false },
      LOCAL_RIFT:     { key:'LOCAL_RIFT',     rift:true  },
      ONLINE_CLASSIC: { key:'ONLINE_CLASSIC', rift:false },
      ONLINE_RIFT:    { key:'ONLINE_RIFT',    rift:true  }
    };
    CCA.MODES = MODES;
    let currentMode = MODES.LOCAL_CLASSIC;
    let isOnline = false;

    function sanitizeNick(n){ return (n||'').toLowerCase().replace(/[^a-z0-9]/g,'').slice(0,30); }
    function emailFromNick(n){ return `${sanitizeNick(n)}@chroma.local`; }

    async function signupNickname(nick, pass){
      const email = emailFromNick(nick);
      const cred = await createUserWithEmailAndPassword(auth, email, pass);
      await updateProfile(cred.user, { displayName: nick });
      await setDoc(doc(db, "users", cred.user.uid), {
        nickname: nick,
        createdAt: serverTimestamp(),
        wins: { LOCAL_CLASSIC:0, LOCAL_RIFT:0, ONLINE_CLASSIC:0, ONLINE_RIFT:0 },
        isNewAccount: true // NEW: Flag for tutorial
      }, { merge:true });
      return cred.user;
    }
    async function loginNickname(nick, pass){
      const email = emailFromNick(nick);
      const cred  = await signInWithEmailAndPassword(auth, email, pass);
      if(!cred.user.displayName){ await updateProfile(cred.user, { displayName: nick }); }
      return cred.user;
    }
    function explainAuthError(e){
      $$('login-message').textContent = e?.message || 'Authentication failed.';
    }

    async function addWin(uid, modeKey){
      try {
        const userRef = doc(db, "users", uid);
        await updateDoc(userRef, { [`wins.${modeKey}`]: increment(1) });
        const snap = await getDoc(userRef);
        const nickname = snap.data()?.nickname || 'Guest';
        const lbRef = doc(db, "leaderboards", modeKey, "scores", uid);
        await setDoc(lbRef, { nickname, wins: increment(1), updatedAt: serverTimestamp() }, { merge: true });
      } catch (e) {
        console.error(`Failed to add win for user ${uid} in mode ${modeKey}:`, e);
      }
    }
    async function fetchLeaderboard(modeKey, topN=50){
      const q = query(collection(db, "leaderboards", modeKey, "scores"), orderBy("wins","desc"), limit(topN));
      const snap = await getDocs(q);
      return snap.docs.map((d,i)=>({ rank:i+1, name:d.data().nickname, wins:d.data().wins }));
    }
    CCA.lb = { addWin, fetchLeaderboard };

    const ROOMS = collection(db, 'rooms');
    const QUEUE = collection(db, 'matchmaking');
    let queueDocId = null;
    let eventsListenerUnsub = null;

    async function findMatch(modeKey) {
      try {
        if (!auth.currentUser) {
            $$('room-status').textContent = 'Error: You must be logged in to find a match.';
            return;
        }
        const userId = auth.currentUser.uid;
        const userNick = auth.currentUser.displayName || 'Guest';
        $$('find-match-button').disabled = true;
        $$('cancel-match-button').style.display = 'inline-block';
        $$('room-status').textContent = 'Searching for an opponent...';

        const q = query(QUEUE, where("mode", "==", modeKey), where("hostId", "!=", userId), limit(1));
        const snap = await getDocs(q);

        if (snap.empty) {
            const newQueueDoc = await addDoc(QUEUE, {
                mode: modeKey,
                hostId: userId,
                hostNick: userNick,
                createdAt: serverTimestamp()
            });
            queueDocId = newQueueDoc.id;
            online.isHost = true;
            $$('room-status').textContent = 'Waiting for an opponent...';
            listenQueueDoc(queueDocId);
        } else {
            const openQueueDoc = snap.docs[0];
            queueDocId = openQueueDoc.id;
            online.isHost = false;

            const newRoom = await addDoc(ROOMS, {
                mode: modeKey,
                createdAt: serverTimestamp(),
                host: { id: openQueueDoc.data().hostId, nick: openQueueDoc.data().hostNick, charKey: null },
                guest: { id: userId, nick: userNick, charKey: null },
                state: { p1CharKey: null, p2CharKey: null, started: false, winner: null }
            });

            await updateDoc(doc(QUEUE, queueDocId), { roomId: newRoom.id, guestId: userId });
            online.code = newRoom.id;
            wireRoomListener();
        }
      } catch (e) {
        console.error("Matchmaking Error:", e);
        $$('room-status').textContent = 'Error: Could not search. Check Firebase permissions.';
        $$('find-match-button').disabled = false;
        $$('cancel-match-button').style.display = 'none';
      }
    }

    function listenQueueDoc(id) {
        if(online.unsub) online.unsub();
        online.unsub = onSnapshot(doc(QUEUE, id), async (docSnap) => {
            if (docSnap.exists() && docSnap.data().roomId) {
                online.code = docSnap.data().roomId;
                if(online.unsub) online.unsub();
                online.unsub = null;
                await deleteDoc(doc(QUEUE, id));
                queueDocId = null;
                wireRoomListener();
            }
        });
    }

    async function cancelMatchmaking() {
        if(online.unsub) online.unsub();
        online.unsub = null;
        if(queueDocId) {
            await deleteDoc(doc(QUEUE, queueDocId));
            queueDocId = null;
        }
        $$('find-match-button').disabled = false;
        $$('cancel-match-button').style.display = 'none';
        $$('room-status').textContent = '';
    }

    function listenRoom(code, cb){ return onSnapshot(doc(ROOMS, code), snap => cb(snap.exists()?snap.data():null)); }
    async function setStarted(code){ await updateDoc(doc(ROOMS, code), { 'state.started': true }); }

    async function pushState(code, isHost, payload) {
        // FIX: Add guard in case this is called with an empty code
        if (!code) { /* console.warn("pushState called with no code."); */ return; }

        const pathPrefix = isHost ? 'state.p1' : 'state.p2';
        const updates = {};
        Object.keys(payload).forEach(key => {
            updates[`${pathPrefix}.${key}`] = payload[key];
        });
        if (Object.keys(updates).length > 0) {
           try {
             await updateDoc(doc(ROOMS, code), updates);
           } catch (e) {
             console.error("Error pushing state:", e);
           }
        }
    }

    async function pushSkillEvent(skillKey) {
        if (!isOnline || !online.code) return;
        try {
            const eventCollection = collection(db, 'rooms', online.code, 'events');
            await addDoc(eventCollection, {
                by: online.isHost ? 'host' : 'guest',
                key: skillKey,
                timestamp: serverTimestamp()
            });
        } catch (e) {
            console.error("Failed to push skill event:", e);
        }
    }
    window.pushSkillEvent = pushSkillEvent;

    function wireEventsListener() {
        if (eventsListenerUnsub) eventsListenerUnsub();

        const eventCollection = collection(db, 'rooms', online.code, 'events');
        const myIdentifier = online.isHost ? 'host' : 'guest';

        eventsListenerUnsub = onSnapshot(eventCollection, (snapshot) => {
            const batch = writeBatch(db);
            let changesProcessed = 0;
            snapshot.docChanges().forEach(change => {
                if (change.type === 'added') {
                    const event = change.data();
                    if (event.by && event.by !== myIdentifier && event.key) {
                        const opponent = online.isHost ? window.players?.[1] : window.players?.[0];
                        if (opponent && typeof opponent.useSkillRemote === 'function') {
                            console.log(`Received skill event: ${event.key} from opponent`);
                            opponent.useSkillRemote(event.key);
                        } else {
                            console.warn("Opponent or useSkillRemote not found for event:", event);
                        }
                    } else if (!event.key) {
                        console.warn("Received event without key:", event);
                    }
                    batch.delete(change.doc.ref);
                    changesProcessed++;
                }
            });
            if (changesProcessed > 0) {
                batch.commit().catch(e => console.error("Failed to clear events:", e));
            }
        }, (error) => {
            console.error("Error in events listener:", error);
        });
        console.log("Events listener wired for room:", online.code);
    }

    async function setWinner(code, winner){ await updateDoc(doc(ROOMS, code), { 'state.winner': winner }); }
    async function selectCharacterOnline(code, isHost, charKey) {
        const path = isHost ? 'state.p1CharKey' : 'state.p2CharKey';
        await updateDoc(doc(ROOMS, code), { [path]: charKey });
    }
    CCA.online = { listenRoom, setStarted, pushState, setWinner, selectCharacterOnline };

    let gameState = 'LOGIN_SCREEN';
    let loggedInUser = null;
    CCA.flow = {
        get gameState(){ return gameState; },
        set gameState(v){ gameState=v; },
        tutorialActive: false, // NEW: Tutorial state
        tutorialStep: 0,
        isGuest: false,
        tutorialMoveTimer: 0
    };
    CCA.playersMeta = { get loggedInUser(){ return loggedInUser; } };

    function switchScreen(id){ document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active')); if(id) document.getElementById(id).classList.add('active'); }

    const modeTabs = document.querySelectorAll('#mode-tabs .tab');
    modeTabs.forEach(t => t.addEventListener('click', ()=>{
      modeTabs.forEach(x=>x.classList.remove('active')); t.classList.add('active');
      currentMode = MODES[t.dataset.mode];
      isOnline = (currentMode===MODES.ONLINE_CLASSIC || currentMode===MODES.ONLINE_RIFT);
      $$('online-controls').style.display = isOnline ? 'block' : 'none';
      $$('start-button').style.display = isOnline ? 'none' : 'inline-block';

      if (CCA.flow.tutorialActive && CCA.flow.tutorialStep === 0 && currentMode.key === 'LOCAL_CLASSIC') {
          updateTutorial(1);
      }
    }));

    const lbTabs = document.querySelectorAll('#lb-tabs .tab');
    lbTabs.forEach(t => t.addEventListener('click', ()=>{
      lbTabs.forEach(x=>x.classList.remove('active')); t.classList.add('active');
      loadLeaderboard(t.dataset.lb);
    }));

    async function loadLeaderboard(modeKey){
        const table = $$('leaderboard-table');
        table.innerHTML = `
            <div class="leaderboard-header">
            <div class="rank">RANK</div><div class="name">NICKNAME</div><div class="score">WINS</div>
            </div>`;
        const rows = await CCA.lb.fetchLeaderboard(modeKey).catch(e=>{ console.error('LB err', e); return []; });
        if(rows.length===0){
            table.innerHTML += '<div class="leaderboard-row"><div class="name" style="width:100%;text-align:center;">No games played yet.</div></div>';
        }else{
            rows.forEach(r=>{
            const row = document.createElement('div'); row.className='leaderboard-row';
            row.innerHTML = `<div class="rank">#${r.rank}</div><div class="name">${r.name}</div><div class="score">${r.wins}</div>`;
            table.appendChild(row);
            });
        }
    }

    $$('start-button').addEventListener('click', ()=>{
      if(!isOnline){
        window.loggedInUsers = { p1: 'Player 1', p2: 'Player 2' };
        CCA.flow.gameState='CHAR_SELECT';
        switchScreen('char-select-screen');
        window.setupCharSelect(null);
        if (CCA.flow.tutorialActive && CCA.flow.tutorialStep === 1) {
            updateTutorial(2);
        }
      }
    });
    $$('leaderboard-button').addEventListener('click', ()=>{ CCA.flow.gameState='LEADERBOARD'; switchScreen('leaderboard-screen'); loadLeaderboard('LOCAL_CLASSIC'); });
    $$('leaderboard-back-button').addEventListener('click', ()=>{ CCA.flow.gameState='START_SCREEN'; switchScreen('start-screen'); });
    $$('settings-button').addEventListener('click', ()=>{ CCA.flow.gameState='SETTINGS'; switchScreen('settings-screen'); });
    $$('settings-back-button').addEventListener('click', ()=>{ CCA.flow.gameState='START_SCREEN'; switchScreen('start-screen'); });

    let online = { code:null, isHost:false, unsub:null, ready:false };
    $$('find-match-button').addEventListener('click', () => findMatch(currentMode.key));
    $$('cancel-match-button').addEventListener('click', cancelMatchmaking);

    function wireRoomListener(){
      // FIX: Add guard in case this is called with an empty code
      if (!online.code) {
          console.error("wireRoomListener called with no code.");
          return;
      }

      if(online.unsub) online.unsub();
      console.log("Wiring room listener for room:", online.code);
      online.unsub = listenRoom(online.code, (room)=>{
        if(!room) {
            console.log("Room data is null, detaching listener for:", online.code);
            if (online.unsub) online.unsub();
            online.unsub = null;
            if(CCA.flow.gameState !== 'START_SCREEN' && CCA.flow.gameState !== 'LOGIN_SCREEN' && CCA.flow.gameState !== 'GAME_OVER') {
                console.error("Room connection lost. Returning to main menu.");
                const statusElement = $$('room-status') || $$('login-message');
                if (statusElement) {
                    statusElement.textContent = "Room connection lost. Returning to menu...";
                }
                setTimeout(() => resetGame(true), 1500);
            }
            return;
        }
        console.log("Received room update:", room);

        if (CCA.flow.gameState === 'CHAR_SELECT') {
            window.setupCharSelect(room.state);
        }

        if(room.host.id && room.guest.id && !room.state.started && CCA.flow.gameState!=='CHAR_SELECT'){
          console.log("Both players joined, moving to char select");
          window.loggedInUsers = { p1: room.host.nick, p2: room.guest.nick };
          CCA.flow.gameState='CHAR_SELECT'; switchScreen('char-select-screen'); window.setupCharSelect(room.state);
        }

        if (room.state.p1CharKey && room.state.p2CharKey && CCA.flow.gameState === 'CHAR_SELECT') {
            console.log("Both players locked in, starting game and wiring events listener");
            wireEventsListener();
            window.startGame(room.state.p1CharKey, room.state.p2CharKey);
        }

        if(CCA.flow.gameState==='ACTIVE' && room.state.started){
          const oppState = online.isHost ? room.state.p2 : room.state.p1;
          const opp = online.isHost ? window.players?.[1] : window.players?.[0];
          if(opp && oppState){
            if(oppState.pos){
              opp.networkTargetPosition.set(oppState.pos.x, oppState.pos.y, oppState.pos.z);
            }
            if (typeof oppState.energy !== 'undefined') opp.energy = oppState.energy;

            // Client is authoritative for its own HP
            // if (typeof oppState.hp !== 'undefined' && opp.hp !== oppState.hp) {
            //     console.log(`Opponent HP updated via network: ${opp.hp} -> ${oppState.hp}`);
            //     opp.hp = oppState.hp;
            //     if (opp.hp <= 0 && !opp.isDead) {
            //         opp.die();
            //     }
            // }
          }

          const meState = online.isHost ? room.state.p1 : room.state.p2;
          const me = online.isHost ? window.players?.[0] : window.players?.[1];
          if(me && meState && !me.isDead) {
              // Only apply network HP state if it's lower (e.g., from opponent's DoT)
              // But block it from "healing" us if our local state is lower
              if (typeof meState.hp !== 'undefined' && me.hp > meState.hp) {
                  console.log(`My HP updated via network (lower): ${me.hp} -> ${meState.hp}`);
                  me.hp = meState.hp;
                  if (me.hp <= 0) {
                      me.die();
                  }
              }
          }
        }
        if(room.state.winner && CCA.flow.gameState!=='GAME_OVER'){
            console.log("Winner declared via network:", room.state.winner);
            window.endGame(room.state.winner);
        }
      }, (error) => {
          console.error("Error in room listener:", error);
          if (CCA.flow.gameState !== 'START_SCREEN' && CCA.flow.gameState !== 'LOGIN_SCREEN') {
             console.error("Error connecting to room. Returning to main menu.");
             const statusElement = $$('room-status') || $$('login-message');
             if (statusElement) {
                 statusElement.textContent = "Error connecting to room. Returning to menu...";
             }
             setTimeout(() => resetGame(true), 1500);
          }
      });
    }

    // Client is authoritative for its own HP
    // This interval now sends our HP *and* position/energy
    setInterval(()=>{
      if(!isOnline || CCA.flow.gameState!=='ACTIVE' || !online.code) return;
      const me = online.isHost ? window.players?.[0] : window.players?.[1];
      if(!me || me.isDead) return;
      pushState(online.code, online.isHost, {
        pos:{ x:me.mesh.position.x, y:me.mesh.position.y, z:me.mesh.position.z },
        energy: me.energy,
        hp: me.hp // Send our HP
      }).catch(()=>{});
    }, 100);

    $$('signup-button').addEventListener('click', async ()=>{
      const nick = ($$('login-nickname')?.value||'').trim(), pass = ($$('login-password')?.value||'').trim();
      if(nick.length<3 || pass.length<4){ $$('login-message').textContent='Invalid nickname or password.'; return; }
      try{
        await signupNickname(nick, pass);
        await loginNickname(nick, pass);
        CCA.flow.isGuest = false;
        handleSuccessfulLogin();
      }catch(e){ explainAuthError(e); }
    });
    $$('login-button').addEventListener('click', async ()=>{
      const nick = ($$('login-nickname')?.value||'').trim(), pass = ($$('login-password')?.value||'').trim();
      if(!nick||!pass){ $$('login-message').textContent='Enter nickname and password.'; return; }
      try{
        await loginNickname(nick, pass);
        CCA.flow.isGuest = false;
        handleSuccessfulLogin();
      }catch(e){ explainAuthError(e); }
    });
    $$('guest-login-button').addEventListener('click', async () => {
        try {
            const userCred = await signInAnonymously(auth);
            const guestName = `Guest${Math.floor(Math.random()*1000)}`;
            await updateProfile(userCred.user, { displayName: guestName });
            await setDoc(doc(db, "users", userCred.user.uid), {
                nickname: guestName,
                createdAt: serverTimestamp(),
                wins: { LOCAL_CLASSIC:0, LOCAL_RIFT:0, ONLINE_CLASSIC:0, ONLINE_RIFT:0 },
                isNewAccount: false // Guests don't have persistent new accounts
            }, { merge:true });
            CCA.flow.isGuest = true; // NEW: Set guest flag
            handleSuccessfulLogin();
        } catch(e) { explainAuthError(e); }
    });

    async function handleSuccessfulLogin(){
      loggedInUser = auth.currentUser;

      let isNew = false;
      if (!CCA.flow.isGuest && loggedInUser) {
          try {
              const userDoc = await getDoc(doc(db, "users", loggedInUser.uid));
              if (userDoc.exists() && userDoc.data().isNewAccount === true) {
                  isNew = true;
              }
          } catch (e) {
              console.error("Error checking user doc for tutorial:", e);
          }
      }

      if (isNew || CCA.flow.isGuest) {
          // Show tutorial prompt screen
          CCA.flow.gameState='TUTORIAL_PROMPT';
          switchScreen('tutorial-prompt-screen');
      } else {
          // Go to start screen
          CCA.flow.gameState='START_SCREEN';
          switchScreen('start-screen');
      }
    }

    // NEW: Tutorial prompt buttons
    $$('tutorial-start-button').addEventListener('click', () => {
        CCA.flow.tutorialActive = true;
        CCA.flow.tutorialStep = 0;
        if (loggedInUser && !CCA.flow.isGuest) {
            updateDoc(doc(db, "users", loggedInUser.uid), { isNewAccount: false }).catch(console.error);
        }
        CCA.flow.gameState='START_SCREEN';
        switchScreen('start-screen');
        updateTutorial(0);
    });
    $$('tutorial-skip-button').addEventListener('click', () => {
        CCA.flow.tutorialActive = false;
        if (loggedInUser && !CCA.flow.isGuest) {
            updateDoc(doc(db, "users", loggedInUser.uid), { isNewAccount: false }).catch(console.error);
        }
        CCA.flow.gameState='START_SCREEN';
        switchScreen('start-screen');
    });

    window.mode = { get current(){ return currentMode; }, get isOnline(){ return isOnline; }, onlineState: online };
    window.switchScreen = switchScreen;
    window.addWin = addWin;
    window.firebaseAuth = auth;

    document.body.addEventListener('click', async () => {
        if(window.audioInitialized) return;
        window.audioInitialized = true;
        if (Tone.context.state !== 'running') {
            await Tone.start().catch(e => {
                console.warn("Tone.js worklet failed to load, audio might be limited.", e);
            });
        }
        window.initSounds();
    }, { once: true });

    /********** Constants & structures **********/
    window.loggedInUsers = { p1: 'Player 1', p2: 'Player 2' };

    const controlsP1P2 = { // Renamed to avoid conflict with OrbitControls variable
      p1: { forward: 'w', backward: 's', left: 'a', right: 'd', basicAttack: ' ', skill1: 'q', skill2: 'e', skill3: 'r', skill4: 'f' },
      p2: { forward: 'i', backward: 'k', left: 'j', right: 'l', basicAttack: 'enter', skill1: 'u', skill2: 'o', skill3: 'p', skill4: 'h' }
    };
    const keys = {};

    const particleTexture = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABGklEQVRYR+2VwQ2DMAxFr9sN2IAt2A3YgG3YDbpBG7QbsAGb4A17Q1JISklK/4mH/2mSb49fEuA/AhzwCMiAHfC8vYICuAI2Z4bCzcCFBoDd0hMgoA+gUWgZAFVoeQLoFGp+Bugu1LwAej9UfA96PxQ8D/pAFDwP+kAUfA/6QBT8DhpAFHwO2kAUfAqaQBR8CphAFHwJmkAUfAqaQBR8CphAFHwJmkAUfAqaQBR8CphAFHwJmkAUfApqgSi4FNQAqfAqqAFT4FVQAzV4FXwCarwKvgaqwCvwHFSBK/AgqgZX4EVQDC/AiqAaW4CVQDazAS6AaWIFbYBZYgVtgFVgBL/AGrAALeAO2YAH+AF9jAUkP/AnrAAAAAElFTkSuQmCC');

    const CHARACTERS = {
      ECHO_PRIME: {
        name: "Echo Prime", hp: 100, speed: 8, color: 0x00ffff, attackType: 'RANGED',
        passive: { name: "Resonance", desc: "Every 3rd basic attack deals 15 bonus damage and restores 10 energy." },
        skills: {
          s1: {name:"Power Shot", cost: 25, cd: 4},
          s2: {name:"Phase Shift", cost: 30, cd: 5},
          s3: {name:"Static Field", cost: 50, cd: 12},
          s4: {name:"Overcharge", cost: 80, cd: 40}
        }
      },
      AEGIS: {
        name: "Aegis", hp: 140, speed: 6, color: 0xffa500, attackType: 'MELEE',
        passive: { name: "Fortress", desc: "Standing still for 2s grants a 20HP shield (decays after moving)." },
        skills: {
          s1: {name:"Aegis Charge", cost: 20, cd: 5},
          s2: {name:"Energy Shield", cost: 40, cd: 8},
          s3: {name:"Overload", cost: 60, cd: 12}, // Buffed old ult to be S3
          s4: {name:"Righteous Stand", cost: 70, cd: 35}
        }
      },
      SPECTRE: {
        name: "Spectre", hp: 85, speed: 10, color: 0x9400d3, attackType: 'MELEE',
        passive: { name: "Shadowstrike", desc: "Basic attacks on an enemy from behind deal 15% bonus damage." },
        skills: {
          s1: {name:"Venom Blade", cost: 15, cd: 4},
          s2: {name:"Blink", cost: 25, cd: 5},
          s3: {name:"Cloak", cost: 60, cd: 12},
          s4: {name:"Death Mark", cost: 90, cd: 50}
        }
      },
      JAVELIN: {
        name: "Javelin", hp: 90, speed: 7, color: 0x32cd32, attackType: 'RANGED',
        passive: { name: "Sharpshooter", desc: "Damage increases with distance, up to +20%." },
        skills: {
          s1: {name:"Targeting Array", cost: 30, cd: 10},
          s2: {name:"Slowing Mine", cost: 40, cd: 10},
          s3: {name:"Laser Core", cost: 80, cd: 18}, // Kept old ult as S3
          s4: {name:"Orbital Strike", cost: 100, cd: 60}
        }
      },
      TEMPEST: {
        name: "Tempest", hp: 100, speed: 8, color: 0x1e90ff, attackType: 'RANGED',
        passive: { name: "Static Charge", desc: "Skills apply Static. At 3 stacks, the next skill stuns for 0.5s." },
        skills: {
          s1: {name:"Static Orb", cost: 25, cd: 6},
          s2: {name:"Ball Lightning", cost: 50, cd: 12},
          s3: {name:"Cyclone", cost: 70, cd: 15}, // Zephyr's old S3, fits Tempest
          s4: {name:"Eye of the Storm", cost: 90, cd: 45} // Old S3 is now Ult
        }
      },
      GLITCH: {
        name: "Glitch", hp: 100, speed: 8, color: 0xf0e68c, attackType: 'RANGED',
        passive: { name: "Firewall", desc: "Once every 20s, block one enemy skill." },
        skills: {
          s1: {name:"Corruption", cost: 30, cd: 8},
          s2: {name:"Rewind", cost: 40, cd: 10},
          s3: {name:"Swap", cost: 60, cd: 20},
          s4: {name:"System Crash", cost: 75, cd: 40}
        }
      },
      COLOSSUS: {
        name: "Colossus", hp: 150, speed: 6.5, color: 0xdc143c, attackType: 'MELEE',
        passive: { name: "Juggernaut", desc: "Have +10% HP, but 20% slower energy regen." },
        skills: {
          s1: {name:"Decimate", cost: 20, cd: 3},
          s2: {name:"Tectonic Slam", cost: 30, cd: 7},
          s3: {name:"Unstoppable Force", cost: 60, cd: 16}, // Old ult is S3
          s4: {name:"Pulverize", cost: 100, cd: 50}
        }
      },
      CHRONOMANCER: {
        name: "Chronomancer", hp: 95, speed: 8, color: 0x40e0d0, attackType: 'RANGED',
        passive: { name: "Time Flux", desc: "Gain 5% cooldown reduction on all skills." },
        skills: {
          s1: {name:"Temporal Anomaly", cost: 35, cd: 9},
          s2: {name:"Stasis Field", cost: 40, cd: 12},
          s3: {name:"Chrono Prison", cost: 75, cd: 18},
          s4: {name:"Time Stop", cost: 100, cd: 60}
        }
      },
      ORACLE: {
        name: "Oracle", hp: 110, speed: 7, color: 0xffffff, attackType: 'RANGED',
        passive: { name: "Foresight", desc: "You and allies near your Turret gain 10% move speed." },
        skills: {
          s1: {name:"Empower", cost: 25, cd: 12},
          s2: {name:"Sentry Turret", cost: 40, cd: 10},
          s3: {name:"Bastion Protocol", cost: 60, cd: 18},
          s4: {name:"Salvation", cost: 80, cd: 45}
        }
      },
      ZEPHYR: {
        name: "Zephyr", hp: 90, speed: 11.5, color: 0x90ee90, attackType: 'RANGED',
        passive: { name: "Swiftness", desc: "Gain 5% bonus movement speed." },
        skills: {
          s1: {name:"Tailwind", cost: 20, cd: 8},
          s2: {name:"Wind Wall", cost: 40, cd: 10},
          s3: {name:"Phase Shift", cost: 30, cd: 6}, // Echo's old S2
          s4: {name:"Gale Force", cost: 80, cd: 40}
        }
      },
      NULL: {
        name: "Null", hp: 100, speed: 8.5, color: 0xa020f0, attackType: 'RANGED',
        passive: { name: "Mana Burn", desc: "Your basic attacks burn 5 energy from the target." },
        skills: {
          s1: {name:"Feedback Loop", cost: 30, cd: 7},
          s2: {name:"Silence", cost: 40, cd: 12},
          s3: {name:"Spell Shield", cost: 30, cd: 15},
          s4: {name:"Energy Void", cost: 60, cd: 30}
        }
      },
      VORTEX: {
        name: "Vortex", hp: 120, speed: 8.5, color: 0x6a0dad, attackType: 'RANGED',
        passive: { name: "Event Horizon", desc: "Skills apply Gravity Mark (stacking) for 4s. At 3 stacks, marks are consumed to Stun target for 1.5s & pull them 5 units. Basic attacks also apply Gravity Marks." },
        skills: {
          s1: {name:"Crushing Singularity", cost: 25, cd: 7}, // Proj + Orb
          s2: {name:"Graviton Pulse", cost: 30, cd: 8}, // Proj
          s3: {name:"Implosion", cost: 45, cd: 12}, // Target Debuff -> AoE
          s4: {name:"Black Hole", cost: 70, cd: 40} // Placed AoE
        }
      },
      MIRAGE: { // Renamed from Emperor for consistency
        name: "Emperor", hp: 80, speed: 9, color: 0xffd700, attackType: 'RANGED', // Azir is RANGED
        passive: { name: "Imperial Will", desc: "Soldier attacks grant 20% bonus attack speed for 3s, stacking 3x." },
        skills: {
          s1: {name:"Arise!", cost: 30, cd: 5}, // Summons a soldier
          s2: {name:"Conquering Sands", cost: 40, cd: 8}, // Soldier dash
          s3: {name:"Shifting Sands", cost: 25, cd: 10}, // Player dash to soldier
          s4: {name:"Emperor's Divide", cost: 100, cd: 60} // Wall
        }
      },
      FORGE: {
        name: "Forge", hp: 120, speed: 6.5, color: 0xcd7f32, attackType: 'MELEE',
        passive: { name: "Scrap Collector", desc: "Destroyed constructs drop scrap, restoring 20 energy." },
        skills: {
          s1: {name:"Build Turret", cost: 40, cd: 10},
          s2: {name:"Barrier Wall", cost: 30, cd: 12},
          s3: {name:"Siege Mode", cost: 60, cd: 16},
          s4: {name:"Anvil Turret", cost: 100, cd: 60}
        }
      },
      CATALYST: {
        name: "Catalyst", hp: 90, speed: 8, color: 0x00ff7f, attackType: 'RANGED',
        passive: { name: "Corrosion", desc: "Caustic Blast's slow duration is increased by 0.5s per Venom stack on the target." },
        skills: {
          s1: {name:"Caustic Blast", cost: 20, cd: 5},
          s2: {name:"Adrenal Haze", cost: 45, cd: 14},
          s3: {name:"Venom Blade", cost: 20, cd: 6}, // Spectre's old S1
          s4: {name:"Plague Cloud", cost: 75, cd: 45} // Old S3 is now Ult
        }
      },
      RONIN: {
        name: "Ronin", hp: 85, speed: 10.5, color: 0xff4500, attackType: 'MELEE',
        passive: { name: "Way of the Blade", desc: "After using a skill, your next basic attack has bonus range & damage." },
        skills: {
          s1: {name:"Iaijutsu Dash", cost: 20, cd: 4},
          s2: {name:"Parry Stance", cost: 30, cd: 9},
          s3: {name:"Blade Fury", cost: 65, cd: 15},
          s4: {name:"Shadow Strike", cost: 90, cd: 50}
        }
      }
    };
    const charKeys = Object.keys(CHARACTERS);

    const SKILL_ICONS = {
        basicAttack: 'ATK',
        // S1
        "Power Shot": 'PS', "Aegis Charge": 'AC', "Venom Blade": 'VB', "Targeting Array": 'TA', "Static Orb": 'SO',
        "Corruption": 'CR', "Decimate": 'DC', "Temporal Anomaly": 'TA', "Empower": 'EM', "Tailwind": 'TW',
        "Feedback Loop": 'FL', "Crushing Singularity": 'CS', "Doppelganger": 'DG', "Build Turret": 'BT', "Caustic Blast": 'CB',
        "Iaijutsu Dash": 'ID', "Arise!": 'SND',
        // S2
        "Phase Shift": 'SH', "Energy Shield": 'ES', "Blink": 'BL', "Slowing Mine": 'SM', "Ball Lightning": 'BL',
        "Rewind": 'RW', "Tectonic Slam": 'TS', "Stasis Field": 'SF', "Sentry Turret": 'ST', "Wind Wall": 'WW',
        "Silence": 'SL', "Graviton Pulse": 'GP', "Shimmer": 'SH', "Barrier Wall": 'BW', "Adrenal Haze": 'AH',
        "Parry Stance": 'PS', "Conquering Sands": 'DSH',
        // S3
        "Static Field": 'SF', "Overload": 'OV', "Cloak": 'CL', "Laser Core": 'LC', "Cyclone": 'CY',
        "Swap": 'SW', "Unstoppable Force": 'UF', "Chrono Prison": 'CP', "Bastion Protocol": 'BP',
        "Spell Shield": 'SS', "Siege Mode": 'SM', "Blade Fury": 'BF', "Shifting Sands": 'TP',
        // S4 (Ultimates)
        "Overcharge": 'OC', "Righteous Stand": 'RS', "Death Mark": 'DM', "Orbital Strike": 'OS', "Eye of the Storm": 'ES',
        "System Crash": 'SC', "Pulverize": 'PV', "Time Stop": 'TS', "Salvation": 'SV', "Gale Force": 'GF',
        "Energy Void": 'EV', "Black Hole": 'BH', "Army of Shadows": 'AS', "Emperor's Divide": 'WAL',
        "Anvil Turret": 'AT', "Plague Cloud": 'PC', "Shadow Strike": 'SS'
    };

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x000000, 0);
    renderer.shadowMap.enabled = true;
    document.body.insertBefore(renderer.domElement, document.body.firstChild);

    // --- ADDED ORBIT CONTROLS ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 15; // Adjusted min distance
    controls.maxDistance = 60; // Adjusted max distance
    controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent looking directly down or flipping under
    controls.enabled = true; // Enable initially for menu view
    controls.autoRotate = true; // Enable auto-rotation for menu
    controls.autoRotateSpeed = 0.5; // Slow rotation speed
    controls.target.set(0, 2, 0); // Look slightly above the ground

    // Post-processing (Bloom)
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.6, 0.5, 0.85); // (resolution, strength, radius, threshold)
    const composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    const clock = new THREE.Clock();
    const arenaSize = 45;
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
    dirLight.position.set(-15, 20, 10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024; // Default is 512
    dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far = 50;
    scene.add(dirLight);

    const gridHelper = new THREE.GridHelper(arenaSize, arenaSize, 0x00ffff, 0x333333)
    gridHelper.position.y = 0.01; // Lift slightly to avoid z-fighting
    scene.add(gridHelper);

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(arenaSize, arenaSize), new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 }));
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const obstacles = [];
    const pylonGeo = new THREE.CylinderGeometry(1,1,6,8);
    const pylonMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.3 });
    [new THREE.Vector3(10,3,10), new THREE.Vector3(-10,3,-10), new THREE.Vector3(10,3,-10), new THREE.Vector3(-10,3,10), new THREE.Vector3(0,3,0)]
    .forEach(pos => { const pylon = new THREE.Mesh(pylonGeo, pylonMat); pylon.position.copy(pos); pylon.castShadow = true; pylon.receiveShadow = true; scene.add(pylon); const box = new THREE.Box3().setFromObject(pylon); box.isPylon=true; obstacles.push(box); });

    // Sound setup
    let audioReady = false;
    let sounds = {};
    window.initSounds = () => {
        sounds = {
          shoot: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(),
          hit: new Tone.PolySynth(Tone.MembraneSynth, { pitchDecay: 0.1, octaves: 4, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination(),
          death: new Tone.PolySynth(Tone.MetalSynth, { frequency: 50, envelope: { attack: 0.01, decay: 1, release: 0.5 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination(),
          shield: new Tone.PolySynth(Tone.NoiseSynth, { noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 } }).toDestination(),
          teleport: new Tone.PolySynth(Tone.PluckSynth, { attackNoise: 1, dampening: 4000, resonance: 0.7 }).toDestination(),
          laser: new Tone.PolySynth(Tone.FMSynth, { harmonicity: 1.2, modulationIndex: 10, envelope: { attack: 0.01, decay: 1, sustain: 0.1, release: 0.2 } }).toDestination(),
          explosion: new Tone.PolySynth(Tone.MembraneSynth, { pitchDecay: 0.5, octaves: 10, envelope: { attack: 0.01, decay: 0.8, sustain: 0 } }).toDestination(),
          charge: new Tone.PolySynth(Tone.FMSynth, { harmonicity: 0.5, modulationIndex: 10, envelope: { attack: 0.2, decay: 0.3, sustain: 0.1, release: 0.1 } }).toDestination(),
          ult: new Tone.PolySynth(Tone.FMSynth, { harmonicity: 2, modulationIndex: 20, envelope: { attack: 0.1, decay: 1.5, sustain: 0.1, release: 0.5 } }).toDestination(),
        };
        sounds.shoot.volume.value = -12;
        sounds.hit.volume.value = -6;
        sounds.teleport.volume.value = -6;
        sounds.ult.volume.value = -3;
        audioReady = true;
    };

    // Game lists
    window.players = [];
    let projectiles = [];
    let specialObjects = [];
    let p1Select=-1, p2Select=-1, p1Locked=false, p2Locked=false;

    // HUD 3D Portrait Renderers
    let hudScenes = { p1: null, p2: null };
    let hudCameras = { p1: null, p2: null };
    let hudModels = { p1: null, p2: null };

    // NEW: Tutorial helper function
    function updateTutorial(step) {
        if (!CCA.flow.tutorialActive) return;

        CCA.flow.tutorialStep = step;
        const overlay = $$('tutorial-overlay');
        const box = $$('tutorial-box');
        const text = $$('tutorial-text');
        const arrow = $$('tutorial-arrow');

        overlay.style.display = 'block';
        arrow.style.display = 'none'; // Hide by default
        box.style.top = '50%';
        box.style.left = '50%';
        box.style.transform = 'translate(-50%, -50%)';
        arrow.style.transform = 'rotate(0deg)';

        const positionEl = (el, targetSelector, xOffset = 0, yOffset = 0) => {
            const target = document.querySelector(targetSelector);
            if (!target) return;
            const rect = target.getBoundingClientRect();
            el.style.top = `${rect.top + yOffset}px`;
            el.style.left = `${rect.left + xOffset}px`;
            el.style.transform = 'translate(0, 0)';
        };

        const pointArrow = (targetSelector, rotation = 0, xOffset = 0, yOffset = 0) => {
            const target = document.querySelector(targetSelector);
            if (!target) return;
            arrow.style.display = 'block';
            const rect = target.getBoundingClientRect();
            arrow.style.top = `${rect.top + yOffset}px`;
            arrow.style.left = `${rect.left + xOffset}px`;
            arrow.style.transform = `rotate(${rotation}deg)`;
        };

        switch(step) {
            case 0:
                text.textContent = "Welcome! Let's learn to play. Please select 'Local Classic Duel' to begin.";
                positionEl(box, '.tab[data-mode="LOCAL_CLASSIC"]', 0, 80);
                pointArrow('.tab[data-mode="LOCAL_CLASSIC"]', 0, 70, -60);
                break;
            case 1:
                text.textContent = "Great! Now click 'START LOCAL DUEL'.";
                positionEl(box, '#start-button', 0, 80);
                pointArrow('#start-button', 0, 150, -60);
                break;
            case 2:
                text.textContent = "Choose your character. Click on any portrait to select them.";
                positionEl(box, '.char-card', -100, 150);
                pointArrow('.char-card', 0, 100, -60);
                break;
            case 3:
                text.textContent = "Now, choose a character for Player 2.";
                positionEl(box, '.char-card:nth-child(2)', -100, 150);
                pointArrow('.char-card:nth-child(2)', 0, 100, -60);
                break;
            case 4:
                text.textContent = "Get ready to fight! The game will begin shortly.";
                box.style.top = '60%';
                break;
            case 5:
                text.textContent = "Use W, A, S, D to move Player 1.";
                box.style.top = '50%';
                box.style.left = '25%';
                CCA.flow.tutorialMoveTimer = 2; // Need 2 seconds of movement
                break;
            case 6:
                text.textContent = "This is your HUD. Watch your Health (green) and Energy (yellow).";
                positionEl(box, '#player1-hud', 0, -100);
                pointArrow('#player1-hud', 90, -70, 40);
                break;
            case 7:
                text.textContent = "Press 'Spacebar' to use your Basic Attack.";
                positionEl(box, '#p1-skill-basicAttack', 80, -80);
                pointArrow('#p1-skill-basicAttack', 0, -60, 10);
                break;
            case 8:
                text.textContent = "Press 'Q', 'E', 'R', and 'F' to use your skills. Skills cost energy!";
                positionEl(box, '#p1-skill-s2', 0, -80);
                pointArrow('#p1-skill-s2', 0, -60, 10);
                break;
            case 9:
                text.textContent = "Your opponent is Player 2 (on the right). Defeat them to win! Tutorial complete.";
                box.style.top = '50%';
                box.style.left = '50%';
                pointArrow('#player2-hud', 270, 20, -50);
                break;
            case 10:
                CCA.flow.tutorialActive = false;
                overlay.style.display = 'none';
                break;
        }
    }
    window.updateTutorial = updateTutorial; // Make global

    // HUD functions
    function buildPlayerHUD(playerNum, character){
        const hud = document.getElementById(`player${playerNum}-hud`);
        hud.className='player-hud';
        hud.style.borderColor = `#${new THREE.Color(character.color).getHexString()}`;
        const playerName = window.loggedInUsers[`p${playerNum}`] || `Player ${playerNum}`;
        const sk = character.skills;

        const hudScene = new THREE.Scene();
        hudScene.background = new THREE.Color(0x112233);
        const hudCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
        hudCamera.position.set(0, 2.5, 4.5);
        hudCamera.lookAt(0, 2, 0);
        hudScene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const hudLight = new THREE.DirectionalLight(0xffffff, 1);
        hudLight.position.set(1, 1, 1);
        hudScene.add(hudLight);

        const hudModel = createCharacterModel(character, false);
        hudModel.position.set(0, 0, 0);
        hudScene.add(hudModel);

        const canvas = document.createElement('canvas');
        canvas.className = 'portrait-canvas';

        hudScenes[`p${playerNum}`] = hudScene;
        hudCameras[`p${playerNum}`] = hudCamera;
        hudModels[`p${playerNum}`] = hudModel;

        hud.innerHTML = `
            <div class="portrait-container">
                <svg viewBox="0 0 36 36" class="circular-bars">
                    <path class="bar-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.83 a 15.9155 15.9155 0 0 1 0 -31.83" stroke-width="3" />
                    <path class="bar-bg" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.83 a 15.9155 15.9155 0 0 1 0 -31.83" stroke-width="3" transform="scale(0.8) translate(4.5, 4.5)" />
                    <path id="p${playerNum}-health-bar-fill" class="bar-fill" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.83 a 15.9155 15.9155 0 0 1 0 -31.83" stroke-width="3" stroke-dasharray="100, 100" stroke-dashoffset="0"/>
                    <path id="p${playerNum}-energy-bar-fill" class="bar-fill" d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.83 a 15.9155 15.9155 0 0 1 0 -31.83" stroke-width="3" stroke-dasharray="100, 100" stroke-dashoffset="0" transform="scale(0.8) translate(4.5, 4.5)" />
                </svg>
            </div>
            <div class="hud-details">
            <h2 style="margin:0 0 5px 0; font-size:1.1em">${playerName} (${character.name})</h2>
            <div class="skills-container">
                <div class="skill" id="p${playerNum}-skill-basicAttack">${SKILL_ICONS.basicAttack || ''}<div class="cooldown-overlay"></div></div>
                <div class="skill" id="p${playerNum}-skill-s1">${SKILL_ICONS[sk.s1.name] || ''}<div class="cooldown-overlay"></div></div>
                <div class="skill" id="p${playerNum}-skill-s2">${SKILL_ICONS[sk.s2.name] || ''}<div class="cooldown-overlay"></div></div>
                <div class="skill" id="p${playerNum}-skill-s3">${SKILL_ICONS[sk.s3.name] || ''}<div class="cooldown-overlay"></div></div>
                <div class="skill" id="p${playerNum}-skill-s4" style="border-color:#ffD700;">${SKILL_ICONS[sk.s4.name] || ''}<div class="cooldown-overlay"></div></div>
            </div>
            </div>`;

        hud.querySelector('.portrait-container').appendChild(canvas);
    }

    function renderHUDs(delta) {
        for (const playerNum of [1, 2]) {
            const hudScene = hudScenes[`p${playerNum}`];
            const hudCamera = hudCameras[`p${playerNum}`];
            const hudModel = hudModels[`p${playerNum}`];
            const hud = document.getElementById(`player${playerNum}-hud`);
            const canvas = hud?.querySelector('.portrait-canvas');

            if (hudScene && hudCamera && hudModel && canvas) {
                hudModel.rotation.y += delta * 0.5;

                const rect = canvas.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    if (canvas.width !== rect.width || canvas.height !== rect.height) {
                        canvas.width = rect.width;
                        canvas.height = rect.height;
                        hudCamera.aspect = rect.width / rect.height;
                        hudCamera.updateProjectionMatrix();
                    }

                    const mainCanvasRect = renderer.domElement.getBoundingClientRect();
                    const left = rect.left - mainCanvasRect.left;
                    const bottom = mainCanvasRect.bottom - rect.bottom;

                    renderer.setScissorTest(true);
                    renderer.setScissor(left, bottom, rect.width, rect.height);
                    renderer.setViewport(left, bottom, rect.width, rect.height);

                    renderer.render(hudScene, hudCamera);
                }
            }
        }
        renderer.setScissorTest(false);
        renderer.setViewport(0, 0, renderer.domElement.clientWidth, renderer.domElement.clientHeight);
    }

    function updateUI(){
        if(window.players.length<2) return;
        window.players.forEach((p,i)=>{
            const n=i+1;
            const hb=document.getElementById(`p${n}-health-bar-fill`);
            const eb=document.getElementById(`p${n}-energy-bar-fill`);
            if(hb) hb.style.strokeDashoffset = 100 - (p.hp / p.maxHp) * 100;
            if(eb) eb.style.strokeDashoffset = 100 - (p.energy / p.maxEnergy) * 100;

            for(const key of ['basicAttack','s1','s2','s3','s4']){
            if(!p.cooldowns.hasOwnProperty(key)) continue;
            const el=document.getElementById(`p${n}-skill-${key}`); if(!el) continue;
            const overlay=el.querySelector('.cooldown-overlay');
            if(!overlay) continue;
            if(p.cooldowns[key] > 0){ overlay.style.opacity='1'; overlay.textContent=p.cooldowns[key].toFixed(1); el.classList.remove('ready'); }
            else { overlay.style.opacity='0'; el.classList.add('ready'); }
            }
        });
    }

    // MINIMAP RE-IMPLEMENTATION (CORRECTED)
    function updateMinimap() {
        const map = $$('minimap');
        if (!map || CCA.flow.gameState !== 'ACTIVE') return;
        const ctx = map.getContext('2d');
        if (!ctx) return;

        const mapSize = 200; // Canvas dimensions
        const mapRadius = mapSize / 2;
        const mapScale = mapRadius / (arenaSize / 2); // Scale world radius to map radius

        // Transform world coordinates (relative to center 0,0) to map coordinates (relative to center 100,100)
        const tx = (x) => mapRadius + x * mapScale;
        const ty = (z) => mapRadius + z * mapScale; // Use world Z for map Y

        // Clear the entire canvas
        ctx.clearRect(0, 0, mapSize, mapSize);

        // --- Draw circular background and border (optional, CSS handles this now) ---
        // ctx.fillStyle = 'rgba(10, 20, 30, 0.7)';
        // ctx.strokeStyle = '#00ffff';
        // ctx.lineWidth = 1;
        // ctx.beginPath();
        // ctx.arc(mapRadius, mapRadius, mapRadius - 1, 0, Math.PI * 2); // Draw slightly inside border
        // ctx.fill();
        // ctx.stroke();

        // Clip subsequent drawing to the circle
        ctx.save();
        ctx.beginPath();
        ctx.arc(mapRadius, mapRadius, mapRadius, 0, Math.PI * 2);
        ctx.clip();

        // Draw grid lines (optional)
        // ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
        // ctx.lineWidth = 0.5;
        // for (let i = -arenaSize / 2; i <= arenaSize / 2; i += 5) {
        //   ctx.beginPath(); ctx.moveTo(tx(i), ty(-arenaSize / 2)); ctx.lineTo(tx(i), ty(arenaSize / 2)); ctx.stroke(); // Vertical
        //   ctx.beginPath(); ctx.moveTo(tx(-arenaSize / 2), ty(i)); ctx.lineTo(tx(arenaSize / 2), ty(i)); ctx.stroke(); // Horizontal
        // }

        // Draw obstacles (pylons)
        ctx.fillStyle = '#555';
        obstacles.forEach(obs => {
            const center = new THREE.Vector3();
            obs.getCenter(center);
            const size = new THREE.Vector3();
            obs.getSize(size);
            // Center pylon is at 0,0
            const mapX = tx(center.x - size.x / 2);
            const mapY = ty(center.z - size.z / 2); // Use Z for Y
            const mapW = size.x * mapScale;
            const mapH = size.z * mapScale; // Use Z size for height
            ctx.fillRect(mapX, mapY, mapW, mapH);
        });

        // Draw players
        window.players.forEach((p, index) => {
            if (p.isDead) return;

            const mapX = tx(p.mesh.position.x);
            const mapY = ty(p.mesh.position.z); // Use world Z for map Y

            // Player dot
            ctx.fillStyle = (p.playerNum === 1) ? '#00ffff' : '#ff00ff';
            ctx.beginPath();
            ctx.arc(mapX, mapY, 5, 0, Math.PI * 2);
            ctx.fill();

            // Player aim direction
            const aim = p.aimDirection; // Normalized world direction
            const lineLength = 10; // Length of aim line on map
            const endX = mapX + aim.x * lineLength;
            const endY = mapY + aim.z * lineLength; // Use Z component for map Y direction

            ctx.strokeStyle = ctx.fillStyle; // Use same color
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(mapX, mapY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        });

        // Restore clipping context
        ctx.restore();
    }


    /********** Character select **********/
    window.setupCharSelect = function setupCharSelect(onlineState){
      const grid = document.getElementById('char-grid');
      if(CCA.flow.gameState !== 'CHAR_SELECT') grid.innerHTML='';
      charKeys.forEach((key, index)=>{
        let card = grid.querySelector(`.char-card[data-index='${index}']`);
        if(!card) {
            card = document.createElement('div');
            card.className='char-card'; card.dataset.index=index;
            const char = CHARACTERS[key];
            card.innerHTML = `
            <div class="char-portrait" style="background-color:#${new THREE.Color(char.color).getHexString()};"></div>
            <h3 style="margin:8px 0; font-size: 1.1em;">${char.name}</h3>
            <div class="skills-preview" style="font-size:.75em;color:#aaa; text-align: left; padding: 0 5px;">
                <div style="color:#00ffff; font-weight:bold;">P: ${char.passive.name}</div>
                <div style="font-size:.9em; margin-bottom: 5px;">${char.passive.desc}</div>
                <div>Q: ${char.skills.s1.name}</div>
                <div>E: ${char.skills.s2.name}</div>
                <div>R: ${char.skills.s3.name}</div>
                <div style="color:#ffD700; font-weight:bold;">F: ${char.skills.s4.name}</div>
            </div>`;
            card.addEventListener('click', ()=>handleCardClick(index));
            grid.appendChild(card);
        }
      });
      updateSelectors(onlineState);

      if (CCA.flow.tutorialActive && CCA.flow.tutorialStep === 2) {
          // Add pointer events for tutorial
          grid.querySelectorAll('.char-card').forEach(c => c.style.pointerEvents = 'auto');
      }
    };
    function handleCardClick(index){
      if(CCA.flow.gameState!=='CHAR_SELECT') return;

      if(window.mode.isOnline) {
          const { code, isHost } = window.mode.onlineState;
          CCA.online.selectCharacterOnline(code, isHost, charKeys[index]);
      } else {
          const localPlayerNum = p1Locked ? 2 : 1;
          if (localPlayerNum === 1 && !p1Locked) {
              p1Select = index; p1Locked = true;
              if (CCA.flow.tutorialActive && CCA.flow.tutorialStep === 2) {
                  updateTutorial(3);
              }
          } else if (localPlayerNum === 2 && !p2Locked) {
              if(index === p1Select) return;
              p2Select = index; p2Locked = true;
              if (CCA.flow.tutorialActive && CCA.flow.tutorialStep === 3) {
                  updateTutorial(4);
              }
          }
          if (p1Locked && p2Locked) {
              window.startGame(charKeys[p1Select], charKeys[p2Select]);
          }
          updateSelectors(null);
      }
    }
    function updateSelectors(onlineState){
        const cards = document.querySelectorAll('.char-card');
        cards.forEach(card => card.classList.remove('locked-by-p1','locked-by-p2'));
        const status = document.getElementById('lock-in-status');

        let p1Name = window.loggedInUsers.p1 || 'Player 1';
        let p2Name = window.loggedInUsers.p2 || 'Player 2';

        if (window.mode.isOnline && onlineState) {
            const myTurn = (window.mode.onlineState.isHost && !onlineState.p1CharKey) || (!window.mode.onlineState.isHost && !onlineState.p2CharKey);
            if (onlineState.p1CharKey) cards[charKeys.indexOf(onlineState.p1CharKey)]?.classList.add('locked-by-p1');
            if (onlineState.p2CharKey) cards[charKeys.indexOf(onlineState.p2CharKey)]?.classList.add('locked-by-p2');

            if (myTurn) {
                status.innerHTML = `<span style="color:${window.mode.onlineState.isHost ? '#00ffff' : '#ff00ff'};">Select Your Echo</span>`;
            } else {
                status.textContent = 'Waiting for opponent to select...';
            }
        } else {
            if(p1Locked) cards[p1Select]?.classList.add('locked-by-p1');
            if(p2Locked) cards[p2Select]?.classList.add('locked-by-p2');

            if(!p1Locked) status.innerHTML = `<span style="color:#00ffff;">${p1Name}:</span> Click to select your Echo`;
            else if(!p2Locked) status.innerHTML = `<span style="color:#ff00ff;">${p2Name}:</span> Click to select your Echo`;
        }
    }

    /********** Character Models (Overhauled V5) **********/
    function createCharacterModel(character, inGame = true) {
        const group = new THREE.Group();
        const color = new THREE.Color(character.color);
        const mat = new THREE.MeshStandardMaterial({
            color: color,
            metalness: .4,
            roughness: .6,
            emissive: 0x000000
        });
        const emissiveMat = (c, intensity = 0.5) => new THREE.MeshStandardMaterial({
            color: c,
            metalness: .4,
            roughness: .6,
            emissive: c,
            emissiveIntensity: intensity
        });

        const castShadow = inGame;

        // Helper function for body parts
        const createPart = (geo, mat, pos, rot = [0, 0, 0]) => {
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(pos[0], pos[1], pos[2]);
            mesh.rotation.set(rot[0], rot[1], rot[2]);
            mesh.castShadow = castShadow;
            return mesh;
        };

        switch (character.name) {
            case "Echo Prime":
                group.add(createPart(new THREE.CapsuleGeometry(0.8, 1.5, 4, 12), mat, [0, 2.2, 0])); // Torso
                group.add(createPart(new THREE.IcosahedronGeometry(0.7, 0), mat, [0, 3.6, 0])); // Head
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [-1, 2.2, 0], [0, 0, 0.5])); // L Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [1, 2.2, 0], [0, 0, -0.5])); // R Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.0, 4, 8), mat, [-0.5, 0.8, 0])); // L Leg
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.0, 4, 8), mat, [0.5, 0.8, 0])); // R Leg
                const ring = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.1, 8, 32), emissiveMat(color));
                ring.position.y = 2.5; ring.rotation.x = Math.PI / 2.5; group.add(ring);
                break;

            case "Aegis":
                group.add(createPart(new THREE.BoxGeometry(2, 2.5, 1.5), mat, [0, 2.2, 0])); // Torso
                group.add(createPart(new THREE.OctahedronGeometry(0.8), mat, [0, 4, 0])); // Head
                group.add(createPart(new THREE.BoxGeometry(0.6, 2, 0.8), mat, [-1.3, 2.2, 0])); // L Arm
                group.add(createPart(new THREE.BoxGeometry(0.6, 2, 0.8), mat, [1.3, 2.2, 0])); // R Arm
                group.add(createPart(new THREE.CylinderGeometry(0.4, 0.3, 1.2, 8), mat, [-0.6, 0.6, 0])); // L Leg
                group.add(createPart(new THREE.CylinderGeometry(0.4, 0.3, 1.2, 8), mat, [0.6, 0.6, 0])); // R Leg
                const shield = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2.5, 2.5), emissiveMat(0xffffff, 0.3));
                shield.position.set(-1.8, 2.5, 0.5); shield.rotation.y = Math.PI / 6; group.add(shield);
                break;

            case "Spectre":
                group.add(createPart(new THREE.CapsuleGeometry(0.6, 2.0, 4, 10), mat, [0, 2.5, 0])); // Torso
                group.add(createPart(new THREE.SphereGeometry(0.5), mat, [0, 4.1, 0])); // Head
                group.add(createPart(new THREE.CapsuleGeometry(0.15, 1.5, 4, 8), mat, [-0.8, 2.5, 0], [0, 0, 0.4])); // L Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.15, 1.5, 4, 8), mat, [0.8, 2.5, 0], [0, 0, -0.4])); // R Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [-0.3, 0.9, 0])); // L Leg
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [0.3, 0.9, 0])); // R Leg
                const blade = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 3), emissiveMat(color));
                blade.position.set(0.9, 2.5, 1); blade.rotation.x = -Math.PI / 4; group.add(blade);
                break;

            case "Javelin":
                group.add(createPart(new THREE.BoxGeometry(1.5, 2.8, 1.5), mat, [0, 2, 0])); // Torso
                group.add(createPart(new THREE.SphereGeometry(0.7), mat, [0, 4, 0])); // Head
                group.add(createPart(new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8), emissiveMat(color), [0.8, 2.8, 0.8], [Math.PI/2, 0, 0])); // Gun
                group.add(createPart(new THREE.BoxGeometry(0.4, 1.8, 0.6), mat, [-0.9, 2.5, 0])); // L Arm
                group.add(createPart(new THREE.BoxGeometry(0.4, 1.8, 0.6), mat, [0.9, 2.5, 0])); // R Arm (holding gun)
                group.add(createPart(new THREE.BoxGeometry(0.5, 1.2, 0.5), mat, [-0.4, 0.6, 0])); // L Leg
                group.add(createPart(new THREE.BoxGeometry(0.5, 1.2, 0.5), mat, [0.4, 0.6, 0])); // R Leg
                break;

            case "Tempest":
                group.add(createPart(new THREE.CapsuleGeometry(0.8, 1.5, 4, 12), mat, [0, 2.2, 0])); // Torso
                group.add(createPart(new THREE.IcosahedronGeometry(0.7, 0), mat, [0, 3.6, 0])); // Head
                group.add(createPart(new THREE.SphereGeometry(0.3), mat, [-1.2, 2.8, 0])); // L Hand (floating)
                group.add(createPart(new THREE.SphereGeometry(0.3), mat, [1.2, 2.8, 0])); // R Hand (floating)
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.0, 4, 8), mat, [-0.5, 0.8, 0])); // L Leg
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.0, 4, 8), mat, [0.5, 0.8, 0])); // R Leg
                const ringT = new THREE.Mesh(new THREE.TorusGeometry(1.2, 0.05, 8, 32), emissiveMat(color));
                ringT.position.y = 2.5; ringT.rotation.x = Math.PI / 2; group.add(ringT);
                const ringT2 = ringT.clone(); ringT2.rotation.y = Math.PI/2; group.add(ringT2);
                break;

            case "Glitch":
                group.add(createPart(new THREE.BoxGeometry(1.2, 2, 1), mat, [0, 2.5, 0])); // Torso
                group.add(createPart(new THREE.BoxGeometry(1, 1, 1), mat, [0, 4, 0])); // Head
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [-0.8, 2.5, 0], [0, 0, 0.3])); // L Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [0.8, 2.5, 0], [0, 0, -0.3])); // R Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.2, 4, 8), mat, [-0.3, 0.9, 0])); // L Leg
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.2, 4, 8), mat, [0.3, 0.9, 0])); // R Leg
                const backpack = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.5, 1.5), emissiveMat(color));
                backpack.position.set(0, 2.5, -0.8); group.add(backpack);
                break;

            case "Colossus":
                group.add(createPart(new THREE.CylinderGeometry(1.5, 1.2, 3.0, 8), mat, [0, 2.0, 0])); // Torso
                group.add(createPart(new THREE.BoxGeometry(1.2, 1.2, 1.2), mat, [0, 4.2, 0])); // Head
                group.add(createPart(new THREE.BoxGeometry(0.8, 2.2, 1), mat, [-1.3, 2.0, 0])); // L Arm
                group.add(createPart(new THREE.BoxGeometry(0.8, 2.2, 1), mat, [1.3, 2.0, 0])); // R Arm
                group.add(createPart(new THREE.CylinderGeometry(0.6, 0.4, 1.4, 8), mat, [-0.7, 0.7, 0])); // L Leg
                group.add(createPart(new THREE.CylinderGeometry(0.6, 0.4, 1.4, 8), mat, [0.7, 0.7, 0])); // R Leg
                const shoulder = new THREE.Mesh(new THREE.BoxGeometry(3.4, 1, 1.2), mat);
                shoulder.position.y = 3.2; group.add(shoulder);
                break;

            case "Chronomancer":
                group.add(createPart(new THREE.CapsuleGeometry(0.7, 1.8, 4, 12), mat, [0, 2.4, 0])); // Torso
                group.add(createPart(new THREE.SphereGeometry(0.6), mat, [0, 3.8, 0])); // Head
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [-1, 2.4, 0], [0, 0, 0.5])); // L Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [1, 2.4, 0], [0, 0, -0.5])); // R Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.0, 4, 8), mat, [-0.4, 0.8, 0])); // L Leg
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.0, 4, 8), mat, [0.4, 0.8, 0])); // R Leg
                const clockMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.1, 12), emissiveMat(color));
                clockMesh.position.set(0, 2.5, -0.6); clockMesh.rotation.x = Math.PI / 3; group.add(clockMesh);
                break;

            case "Oracle":
                group.add(createPart(new THREE.ConeGeometry(1.2, 3, 16), mat, [0, 2, 0])); // Body
                group.add(createPart(new THREE.SphereGeometry(0.7), mat, [0, 4, 0])); // Head
                group.add(createPart(new THREE.BoxGeometry(0.2, 1.5, 0.2), mat, [-1, 2.5, 0])); // L Arm
                group.add(createPart(new THREE.BoxGeometry(0.2, 1.5, 0.2), mat, [1, 2.5, 0])); // R Arm
                const halo = new THREE.Mesh(new THREE.TorusGeometry(1, 0.05, 8, 32), emissiveMat(0xffffff));
                halo.position.y = 4.5; halo.rotation.x = Math.PI / 2; group.add(halo);
                break;

            case "Zephyr":
                group.add(createPart(new THREE.CapsuleGeometry(0.7, 2.5, 4, 12), mat, [0, 2.5, 0])); // Torso
                group.add(createPart(new THREE.SphereGeometry(0.5), mat, [0, 4.3, 0])); // Head
                group.add(createPart(new THREE.CapsuleGeometry(0.15, 1.5, 4, 8), mat, [-0.9, 2.5, 0], [0, 0, 0.4])); // L Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.15, 1.5, 4, 8), mat, [0.9, 2.5, 0], [0, 0, -0.4])); // R Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [-0.3, 0.9, 0])); // L Leg
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [0.3, 0.9, 0])); // R Leg
                const wing1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2, 1.2), emissiveMat(color, 0.3));
                wing1.position.set(0, 3, -0.8); wing1.rotation.y = Math.PI / 4; group.add(wing1);
                const wing2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2, 1.2), emissiveMat(color, 0.3));
                wing2.position.set(0, 3, -0.8); wing2.rotation.y = -Math.PI / 4; group.add(wing2);
                break;

            case "Null":
                group.add(createPart(new THREE.CapsuleGeometry(0.8, 1.5, 4, 12), mat, [0, 2.2, 0])); // Torso
                group.add(createPart(new THREE.OctahedronGeometry(0.7), mat, [0, 3.6, 0])); // Head
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [-1, 2.2, 0], [0, 0, 0.5])); // L Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [1, 2.2, 0], [0, 0, -0.5])); // R Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.0, 4, 8), mat, [-0.5, 0.8, 0])); // L Leg
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.0, 4, 8), mat, [0.5, 0.8, 0])); // R Leg
                const ringN = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.1, 8, 32), emissiveMat(color, 0.2));
                ringN.position.y = 2.5; ringN.rotation.x = Math.PI / 1.5; group.add(ringN);
                break;

            case "Vortex":
                group.add(createPart(new THREE.CapsuleGeometry(0.9, 1.8, 4, 12), mat, [0, 2.5, 0])); // Larger torso
                const headV = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), emissiveMat(0x000000, 0.8)); // More prominent black hole head
                headV.position.y = 4.0; group.add(headV);
                
                // Add accretion disk around head
                const disk1 = new THREE.Mesh(new THREE.RingGeometry(0.9, 1.2, 32), emissiveMat(color, 0.6));
                disk1.position.y = 4.0; disk1.rotation.x = Math.PI / 2; group.add(disk1);
                
                const disk2 = new THREE.Mesh(new THREE.RingGeometry(1.0, 1.3, 32), emissiveMat(0xffffff, 0.4));
                disk2.position.y = 4.0; disk2.rotation.x = Math.PI / 2.5; group.add(disk2);
                
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.5, 4, 8), mat, [-1.2, 2.5, 0], [0, 0, 0.6])); // L Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.5, 4, 8), mat, [1.2, 2.5, 0], [0, 0, -0.6])); // R Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.3, 1.2, 4, 8), mat, [-0.6, 0.9, 0])); // L Leg
                group.add(createPart(new THREE.CapsuleGeometry(0.3, 1.2, 4, 8), mat, [0.6, 0.9, 0])); // R Leg
                
                // Add gravitational effect rings
                const ringV1 = new THREE.Mesh(new THREE.TorusGeometry(1.2, 0.08, 8, 32), emissiveMat(color, 0.7));
                ringV1.position.y = 3.8; ringV1.rotation.x = Math.PI / 2; group.add(ringV1);
                
                const ringV2 = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.06, 8, 32), emissiveMat(0xffffff, 0.5));
                ringV2.position.y = 3.8; ringV2.rotation.x = Math.PI / 2.2; group.add(ringV2);
                
                // Add particle effect points to show gravitational pull
                const particle1 = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), emissiveMat(color, 1));
                particle1.position.set(-0.8, 3.5, 0.5); group.add(particle1);
                
                const particle2 = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), emissiveMat(color, 1));
                particle2.position.set(0.8, 3.5, -0.5); group.add(particle2);
                break;

            case "Emperor": // Replaces Mirage
                group.add(createPart(new THREE.CapsuleGeometry(0.7, 1.8, 4, 12), mat, [0, 2.4, 0])); // Torso
                group.add(createPart(new THREE.SphereGeometry(0.6), mat, [0, 3.8, 0])); // Head
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [-1, 2.4, 0], [0, 0, 0.5])); // L Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [1, 2.4, 0], [0, 0, -0.5])); // R Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.0, 4, 8), mat, [-0.4, 0.8, 0])); // L Leg
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.0, 4, 8), mat, [0.4, 0.8, 0])); // R Leg
                const staff = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 4, 8), emissiveMat(color));
                staff.position.set(1.0, 2.0, 0.5); staff.rotation.z = -Math.PI / 6; group.add(staff);
                const staffHead = new THREE.Mesh(new THREE.IcosahedronGeometry(0.3, 0), emissiveMat(color, 1));
                staffHead.position.set(1.0, 4.0, 0.5); group.add(staffHead);
                break;

            case "Forge":
                group.add(createPart(new THREE.BoxGeometry(2, 2.5, 1.5), mat, [0, 2.2, 0])); // Torso
                group.add(createPart(new THREE.BoxGeometry(1, 1, 1), mat, [0, 4, 0])); // Head
                group.add(createPart(new THREE.CylinderGeometry(0.4, 0.4, 1.8, 8), mat, [-1.2, 2.2, 0])); // L Arm
                group.add(createPart(new THREE.CylinderGeometry(0.4, 0.4, 1.8, 8), mat, [1.2, 2.2, 0])); // R Arm
                group.add(createPart(new THREE.BoxGeometry(0.6, 1.2, 0.6), mat, [-0.6, 0.6, 0])); // L Leg
                group.add(createPart(new THREE.BoxGeometry(0.6, 1.2, 0.6), mat, [0.6, 0.6, 0])); // R Leg
                const hammer = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 0.5), emissiveMat(color, 0.2));
                hammer.position.set(1.2, 2.2, 1); group.add(hammer);
                break;

            case "Catalyst":
                group.add(createPart(new THREE.CapsuleGeometry(0.8, 1.5, 4, 12), mat, [0, 2.2, 0])); // Torso
                group.add(createPart(new THREE.SphereGeometry(0.7), mat, [0, 3.6, 0])); // Head
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [-1, 2.2, 0], [0, 0, 0.5])); // L Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [1, 2.2, 0], [0, 0, -0.5])); // R Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.0, 4, 8), mat, [-0.5, 0.8, 0])); // L Leg
                group.add(createPart(new THREE.CapsuleGeometry(0.25, 1.0, 4, 8), mat, [0.5, 0.8, 0])); // R Leg
                const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8), emissiveMat(color));
                tank.position.set(0, 2.5, -0.8); group.add(tank);
                break;

            case "Ronin":
                group.add(createPart(new THREE.CapsuleGeometry(0.7, 2.2, 4, 10), mat, [0, 2.5, 0])); // Torso
                group.add(createPart(new THREE.SphereGeometry(0.6), mat, [0, 4.2, 0])); // Head
                group.add(createPart(new THREE.CapsuleGeometry(0.15, 1.5, 4, 8), mat, [-0.9, 2.5, 0], [0, 0, 0.4])); // L Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.15, 1.5, 4, 8), mat, [0.9, 2.5, 0], [0, 0, -0.4])); // R Arm
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [-0.3, 0.9, 0])); // L Leg
                group.add(createPart(new THREE.CapsuleGeometry(0.2, 1.2, 4, 8), mat, [0.3, 0.9, 0])); // R Leg
                const katana = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 3.5), emissiveMat(0xffffff));
                katana.position.set(1.0, 2.5, 0.5); katana.rotation.z = -Math.PI / 4; group.add(katana);
                break;

            default: // Fallback
                group.add(createPart(new THREE.CapsuleGeometry(1, 2, 4, 16), mat, [0, 2, 0]));
                group.add(createPart(new THREE.IcosahedronGeometry(.7, 0), mat, [0, 3.8, 0]));
                break;
        }

        // Add a base under all models
        const baseMat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.3 });
        const base = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.1, 16), baseMat);
        base.position.y = 0.05;
        if (inGame) group.add(base);

        return group;
    }

    /********** GAMEPLAY CLASSES **********/
    class SpecialObject { constructor(owner, duration){ this.owner=owner; this.duration=duration; this.initialDuration=duration; this.mesh=null; this.collider=null; this.blocksProjectiles=false; } update(delta){ this.duration -= delta; } destroy(){ if(this.mesh) { scene.remove(this.mesh); if(this.mesh.geometry) this.mesh.geometry.dispose(); if(this.mesh.material && typeof this.mesh.material.dispose === 'function') this.mesh.material.dispose(); } } }

    // --- Floating Damage Text ---
    class FloatingDamageText extends SpecialObject {
        constructor(text, position3D) {
            super(null, 1.0); // Lasts for 1 second
            this.text = text;
            this.position3D = position3D.clone();

            this.element = document.createElement('div');
            this.element.className = 'damage-text';
            this.element.textContent = Math.round(this.text); // Display rounded damage
            document.body.appendChild(this.element);

            this.updatePosition(); // Initial position

            // Start animation (move up and fade out)
            requestAnimationFrame(() => { // Ensure styles are applied before transition starts
               if (this.element) {
                   this.element.style.transform = `translate(-50%, -80px)`; // Move up 80px
                   this.element.style.opacity = '0';
               }
            });
        }

        updatePosition() {
             if (!this.element) return;
             // Convert 3D position to 2D screen position
             const screenPos = this.position3D.clone().project(camera);
             const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
             const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
             this.element.style.left = `${x}px`;
             this.element.style.top = `${y}px`;
        }

        update(delta) {
            super.update(delta);
            this.updatePosition(); // Keep updating position in case camera moves
        }

        destroy() {
            if (this.element && this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
            this.element = null;
        }
    }

    class ParticleSystem extends SpecialObject {
        constructor(position, {
            count = 50, duration = 1, speed = 10, size = 0.1, gravity = 0, emissionShape = 'sphere',
            startColor = new THREE.Color(0xffffff), endColor = new THREE.Color(0x000000),
            startSize = 0.1, endSize = 0, direction = null
        } = {}) {
            super(null, duration);
            this.particles = [];
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const material = new THREE.PointsMaterial({
                map: particleTexture,
                size: startSize,
                color: startColor,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false,
                sizeAttenuation: true
            });
            this.startColor = startColor; this.endColor = endColor;
            this.startSize = startSize; this.endSize = endSize;
            this.gravity = new THREE.Vector3(0, gravity, 0);

            for (let i = 0; i < count; i++) {
                vertices.push(position.x, position.y, position.z);
                let velocity;
                if (emissionShape === 'sphere') {
                    velocity = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(Math.random() * speed);
                } else if (emissionShape === 'cone' && direction) {
                    const angle = Math.random() * Math.PI * 0.25;
                    const s = Math.sin(angle);
                    const c = Math.cos(angle);
                    const phi = Math.random() * Math.PI * 2;
                    velocity = new THREE.Vector3(Math.cos(phi) * s, Math.sin(phi) * s, c)
                        .applyQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction))
                        .normalize()
                        .multiplyScalar(Math.random() * speed + speed * 0.5);
                } else {
                    velocity = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(Math.random() * speed);
                }

                this.particles.push({
                    position: position.clone(),
                    velocity: velocity,
                    life: Math.random() * duration,
                    startLife: duration
                });
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            this.mesh = new THREE.Points(geometry, material);
            scene.add(this.mesh);
        }

        update(delta) {
            super.update(delta);
             if (!this.mesh || !this.mesh.geometry || !this.mesh.material) return;
            const positions = this.mesh.geometry.attributes.position;
            const lifeRatio = Math.max(0, this.duration / this.initialDuration);

            this.mesh.material.color.lerpColors(this.endColor, this.startColor, lifeRatio);
            this.mesh.material.size = this.endSize + (this.startSize - this.endSize) * lifeRatio;
            this.mesh.material.opacity = lifeRatio;

            for (let i = 0; i < this.particles.length; i++) {
                const p = this.particles[i];
                if (p.life > 0) {
                    p.life -= delta;
                    p.velocity.add(this.gravity.clone().multiplyScalar(delta));
                    p.position.add(p.velocity.clone().multiplyScalar(delta));
                    positions.setXYZ(i, p.position.x, p.position.y, p.position.z);
                } else {
                    positions.setXYZ(i, -9999, -9999, -9999);
                }
            }
            positions.needsUpdate = true;
        }
        destroy() {
             if (this.mesh) {
                 scene.remove(this.mesh);
                 if (this.mesh.geometry) this.mesh.geometry.dispose();
                 if (this.mesh.material && typeof this.mesh.material.dispose === 'function') this.mesh.material.dispose();
                 this.mesh = null;
             }
        }
    }

    class ExpandingRing extends SpecialObject { constructor(position,color,maxRadius,duration){ super(null,duration); const geo=new THREE.TorusGeometry(maxRadius,.1,8,48), mat=new THREE.MeshBasicMaterial({color,side:THREE.DoubleSide,transparent:true}); this.mesh=new THREE.Mesh(geo,mat); this.mesh.position.copy(position); this.mesh.position.y=.5; this.mesh.rotation.x=Math.PI/2; this.mesh.scale.set(.01,.01,.01); scene.add(this.mesh); } update(delta){ super.update(delta); const p=1-(this.duration/this.initialDuration); this.mesh.scale.set(p,p,p); this.mesh.material.opacity=1-p; } }
    class SpawnEffect extends SpecialObject { constructor(position,color){ super(null,1.5); const ringCount=5; this.rings=[]; for(let i=0;i<ringCount;i++){ const g=new THREE.TorusGeometry(1,.05,8,32), m=new THREE.MeshBasicMaterial({color,transparent:true}), r=new THREE.Mesh(g,m); r.position.copy(position); r.position.y=(i*0.8); r.rotation.x=Math.PI/2; r.scale.set(3,3,3); scene.add(r); this.rings.push(r); } } update(delta){ super.update(delta); const pr=1-(this.duration/this.initialDuration); this.rings.forEach((r,i)=>{ r.position.y=(i*0.8)*(1-pr); r.scale.set(3*(1-pr),3*(1-pr),3*(1-pr)); r.material.opacity=1-pr; }); } destroy(){ this.rings.forEach(r=>{scene.remove(r); if(r.geometry) r.geometry.dispose(); if(r.material) r.material.dispose(); }); } }

    class PlayerAura extends SpecialObject {
        constructor(owner,count,color,speed,size){
            super(owner,Infinity);
            if (!owner || !owner.mesh) {
              console.error("PlayerAura created without valid owner mesh!");
              this.duration = 0;
              return;
            }
            this.particles=[];
            const mat=new THREE.PointsMaterial({
                map: particleTexture,
                color,size,
                blending:THREE.AdditiveBlending,
                transparent:true,
                depthWrite:false,
                sizeAttenuation: true
            });
            const geo=new THREE.BufferGeometry();
            const verts=[];
            for(let i=0;i<count;i++){
                verts.push(0,0,0);
                this.particles.push({
                    baseAngle: Math.random() * Math.PI * 2,
                    baseRadius: Math.random() * 1.5 + 1.0,
                    swirlFrequency: Math.random() * 2 + 1,
                    swirlAmplitude: Math.random() * 0.4 + 0.2,
                    yPos: Math.random() * 4,
                    ySpeed: (Math.random() - 0.5) * speed
                });
            }
            geo.setAttribute('position',new THREE.Float32BufferAttribute(verts,3));
            this.mesh=new THREE.Points(geo,mat);
            if (this.owner && this.owner.mesh) {
               this.owner.mesh.add(this.mesh);
            } else {
               console.warn("Could not add PlayerAura mesh to owner.");
            }
        }
        update(delta){
             if (!this.mesh || !this.mesh.geometry) return;
            const pos=this.mesh.geometry.attributes.position.array;
            const t = clock.getElapsedTime();
            for(let i=0;i<this.particles.length;i++){
                const p=this.particles[i];
                p.yPos += p.ySpeed * delta;
                if (p.yPos > 4) p.yPos = 0;
                if (p.yPos < 0) p.yPos = 4;

                const angle = p.baseAngle + t * 0.5;
                const radius = p.baseRadius + Math.sin(t * p.swirlFrequency) * p.swirlAmplitude;

                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                pos[i*3] = x;
                pos[i*3+1] = p.yPos;
                pos[i*3+2] = z;
            }
            this.mesh.geometry.attributes.position.needsUpdate=true;
        }
        destroy(){ if(this.owner?.mesh && this.mesh) this.owner.mesh.remove(this.mesh); if(this.mesh){if(this.mesh.geometry) this.mesh.geometry.dispose(); if(this.mesh.material) this.mesh.material.dispose(); this.mesh = null;} }
    }

    class StatusEffectVisual extends SpecialObject { constructor(owner,key,color,count=20,style='swirl'){ super(owner,Infinity); this.statusKey=key; this.style=style; const geo=new THREE.BufferGeometry(), verts=[]; this.particles=[]; for(let i=0;i<count;i++){ verts.push(0,0,0); this.particles.push({position:new THREE.Vector3(),velocity:this.randVel(),life:Math.random()*1.5}); } geo.setAttribute('position',new THREE.Float32BufferAttribute(verts,3)); const mat=new THREE.PointsMaterial({color,size:.2,blending:THREE.AdditiveBlending,transparent:true,depthWrite:false}); this.mesh=new THREE.Points(geo,mat); this.mesh.visible=false; scene.add(this.mesh); } randVel(){ switch(this.style){case'drip':return new THREE.Vector3((Math.random()-.5)*.5,-Math.random()*2,(Math.random()-.5)*.5);case'cloud':return new THREE.Vector3((Math.random()-.5)*1.5,(Math.random()-.5)*1.5,(Math.random()-.5)*1.5);case'ring':return new THREE.Vector3(Math.cos(Math.random()*Math.PI*2)*2,0,Math.sin(Math.random()*Math.PI*2)*2);default:return new THREE.Vector3((Math.random()-.5)*2,Math.random()*1.5,(Math.random()-.5)*2);}} update(delta){ if(!this.owner||this.owner.isDead||this.owner.hp<=0||this.owner.status[this.statusKey]<=0){this.mesh.visible=false;return;} this.mesh.visible=true; const pos=this.mesh.geometry.attributes.position.array; for(let i=0;i<this.particles.length;i++){ const p=this.particles[i]; p.position.add(p.velocity.clone().multiplyScalar(delta)); p.life-=delta; if(p.life<=0){p.position.set(0,2,0);p.velocity=this.randVel();p.life=Math.random()*1.5;} const w=this.owner.mesh.position.clone().add(p.position); pos[i*3]=w.x; pos[i*3+1]=w.y; pos[i*3+2]=w.z; } this.mesh.geometry.attributes.position.needsUpdate=true; }
        destroy(){
            scene.remove(this.mesh);
            if(this.mesh){
                if(this.mesh.geometry) this.mesh.geometry.dispose();
                if(this.mesh.material) this.mesh.material.dispose();
                this.mesh = null;
            }
        }
    }

    class Rift extends SpecialObject { constructor(){ super(null,Infinity); this.state='COOLDOWN'; this.timer=5; const g=new THREE.TorusKnotGeometry(1.5,.2,100,16), m=new THREE.MeshBasicMaterial({color:0xff00ff,wireframe:true}); this.mesh=new THREE.Mesh(g,m); this.mesh.visible=false; scene.add(this.mesh); this.light=new THREE.PointLight(0xff00ff,5,10); this.mesh.add(this.light); } update(delta,players){ this.timer-=delta; if(this.state==='COOLDOWN'&&this.timer<=0){this.state='ACTIVE';this.timer=10;const x=(Math.random()-.5)*(arenaSize-10),z=(Math.random()-.5)*(arenaSize-10);this.mesh.position.set(x,2,z);this.mesh.visible=true;}else if(this.state==='ACTIVE'){this.mesh.rotation.y+=delta*2;this.mesh.rotation.x+=delta*.5;if(this.timer<=0){this.state='COOLDOWN';this.timer=15;this.mesh.visible=false;return;} for(const p of players){if(p.mesh.position.distanceTo(this.mesh.position)<3){p.status.riftBuff=8;this.state='COOLDOWN';this.timer=15;this.mesh.visible=false;break;}}}} }

    class StaticField extends SpecialObject { constructor(owner){ super(owner,5); const g=new THREE.CylinderGeometry(4,4,.5,32,1,true), m=new THREE.MeshBasicMaterial({color:0x00ffff,transparent:true,opacity:.3,side:THREE.DoubleSide}); this.mesh=new THREE.Mesh(g,m); this.mesh.position.copy(owner.mesh.position); this.mesh.position.y=.25; scene.add(this.mesh); this.damageInterval=.5; this.damageTimer=0; this.aura=new PlayerAura(this, 100, 0x00ffff, 3, 0.2); this.aura.mesh.position.y = 0.25; } update(delta,players){ super.update(delta); this.aura.update(delta); this.damageTimer-=delta; if(this.damageTimer<=0){this.damageTimer=this.damageInterval; players.forEach(p=>{if(p!==this.owner&&p.mesh.position.distanceTo(this.mesh.position)<4)p.takeDamage(5);});}} destroy() { this.aura.destroy(); super.destroy(); } }

    class ShieldEffect extends SpecialObject { constructor(owner,duration,color=0xADD8E6){ super(owner,duration); const g=new THREE.SphereGeometry(2,16,16), m=new THREE.MeshBasicMaterial({color,transparent:true,opacity:.4,side:THREE.DoubleSide}); this.mesh=new THREE.Mesh(g,m); scene.add(this.mesh); } update(delta){ super.update(delta); if(this.owner && !this.owner.isDead && this.owner.hp > 0){this.mesh.position.copy(this.owner.mesh.position); this.mesh.position.y=2;}else{this.duration=0;}} }

    class SlowingMine extends SpecialObject { constructor(owner,position){ super(owner,20); const g=new THREE.CylinderGeometry(.5,.5,.2,16), m=new THREE.MeshStandardMaterial({color:0x32cd32}); this.mesh=new THREE.Mesh(g,m); this.mesh.position.copy(position); this.mesh.position.y=.1; scene.add(this.mesh); this.armed=false; setTimeout(()=>this.armed=true,1000); } update(delta,players){ super.update(delta); if(!this.armed)return; players.forEach(p=>{if(p!==this.owner&&!p.isDead && p.mesh.position.distanceTo(this.mesh.position)<2){p.status.slowed=3;this.duration=0;if(audioReady)sounds.explosion.triggerAttackRelease("A3","4n"); specialObjects.push(new ParticleSystem(this.mesh.position, {count: 50, duration: 0.8, speed: 10, startColor: new THREE.Color(0x32cd32), endColor: new THREE.Color(0x111111)})); }});}}

    class LaserCore extends SpecialObject { constructor(owner,target){ super(owner,2.5); this.target=target; const g=new THREE.CylinderGeometry(.2,.2,1,8), m=new THREE.MeshBasicMaterial({color:0x32cd32,transparent:true,opacity:.8, blending: THREE.AdditiveBlending}); this.mesh=new THREE.Mesh(g,m); scene.add(this.mesh); this.damageInterval=.2; this.damageTimer=0; } update(delta){ super.update(delta); if(!this.target||!this.owner||this.target.isDead||this.target.hp<=0){this.duration=0;return;} const s=this.owner.mesh.position, e=this.target.mesh.position, d=s.distanceTo(e); this.mesh.scale.y=d; this.mesh.position.copy(s).lerp(e,.5); this.mesh.position.y=2; const up=new THREE.Vector3(0,1,0), axis=new THREE.Vector3().subVectors(e,s).normalize(); this.mesh.quaternion.setFromUnitVectors(up,axis); this.damageTimer-=delta; if(this.damageTimer<=0){this.damageTimer=this.damageInterval; this.target.takeDamage(5); specialObjects.push(new ParticleSystem(this.target.mesh.position.clone().setY(2), {count: 10, duration: 0.2, speed: 2, startColor: new THREE.Color(0x32cd32), endColor: new THREE.Color(0xffffff)})); } } }

    class WindWall extends SpecialObject { constructor(owner,position,quat){ super(owner,6); const g=new THREE.PlaneGeometry(8,5), m=new THREE.MeshBasicMaterial({color:0x90ee90,transparent:true,opacity:.4,side:THREE.DoubleSide}); this.mesh=new THREE.Mesh(g,m); this.mesh.position.copy(position); this.mesh.position.y=2.5; this.mesh.quaternion.copy(quat); scene.add(this.mesh); const helper=new THREE.BoxHelper(this.mesh); helper.update(); this.collider=new THREE.Box3().setFromObject(helper); this.blocksProjectiles=true; this.aura = new PlayerAura(this, 150, 0x90ee90, 4, 0.1); this.aura.mesh.position.y = 0; } update(delta){ super.update(delta); if (this.aura && this.aura.update) this.aura.update(delta); } destroy() { if (this.aura) this.aura.destroy(); super.destroy(); } }

    class StasisField extends SpecialObject { constructor(owner,position){ super(owner,5); const g=new THREE.SphereGeometry(3,16,16), m=new THREE.MeshBasicMaterial({color:0x40e0d0,transparent:true,opacity:.3}); this.mesh=new THREE.Mesh(g,m); this.mesh.position.copy(position); this.mesh.position.y=2; scene.add(this.mesh); this.aura = new PlayerAura(this, 100, 0x40e0d0, 1, 0.2); } update(delta,players){ super.update(delta); if (this.aura && this.aura.update) this.aura.update(delta); players.forEach(p=>{if(p!==this.owner&&!p.isDead && p.mesh.position.distanceTo(this.mesh.position)<3)p.status.rooted=.5;});} destroy() { if (this.aura) this.aura.destroy(); super.destroy(); } }

    class Cyclone extends SpecialObject { constructor(owner){ super(owner,4); this.aura = new PlayerAura(this.owner, 200, 0x1e90ff, 15, 0.15); } update(delta,players){ super.update(delta); const opp=players.find(p=>p!==this.owner && !p.isDead); if(opp){const dir=new THREE.Vector3().subVectors(this.owner.mesh.position,opp.mesh.position); if(dir.length()<12){dir.normalize(); opp.velocity.add(dir.multiplyScalar(15*delta));}}} destroy() { if (this.aura) this.aura.destroy(); super.destroy(); } }

    class Decimate extends SpecialObject { constructor(owner){ super(owner,.5); const g=new THREE.TorusGeometry(3,.2,8,32), m=new THREE.MeshBasicMaterial({color:0xdc143c}); this.mesh=new THREE.Mesh(g,m); this.mesh.position.copy(owner.mesh.position); this.mesh.rotation.x=Math.PI/2; this.mesh.scale.set(.1,.1,.1); scene.add(this.mesh); this.hit=false; } update(delta,players){ super.update(delta); const scale=(1-(this.duration/this.initialDuration))*1.2; this.mesh.scale.set(scale,scale,scale); if(!this.hit){const opp=players.find(p=>p!==this.owner && !p.isDead); if(opp&&opp.mesh.position.distanceTo(this.mesh.position)<(3*scale)){opp.takeDamage(20);this.hit=true;}}}}

    class MeleeSlash extends SpecialObject { constructor(owner,color){ super(owner,.4); const shape=new THREE.Shape(); shape.moveTo(0,-2.5); shape.absarc(0,0,2.5,-Math.PI/2.5,Math.PI/2.5,false); shape.lineTo(0,-2.5); const g=new THREE.ShapeGeometry(shape), m=new THREE.MeshBasicMaterial({color,side:THREE.DoubleSide,transparent:true}); this.mesh=new THREE.Mesh(g,m); this.mesh.position.copy(owner.mesh.position); this.mesh.position.y=2; this.mesh.quaternion.copy(owner.mesh.quaternion); this.mesh.position.add(owner.aimDirection.clone().multiplyScalar(.5)); scene.add(this.mesh); } update(delta){ super.update(delta); if (this.mesh && this.mesh.material) this.mesh.material.opacity=this.duration/this.initialDuration; } }

    class TectonicSlam extends SpecialObject { constructor(owner){ super(owner,1); specialObjects.push(new ExpandingRing(owner.mesh.position, CHARACTERS['COLOSSUS'].color, 5, 0.5)); specialObjects.push(new ParticleSystem(owner.mesh.position, {count: 100, duration: 1, speed: 8, startColor: new THREE.Color(CHARACTERS['COLOSSUS'].color), endColor: new THREE.Color(0x333333), emissionShape: 'sphere', gravity: -10})); const opp=window.players.find(p=>p!==this.owner && !p.isDead); if(opp&&opp.mesh.position.distanceTo(owner.mesh.position)<5){opp.takeDamage(15);opp.status.slowed=2;} if(audioReady)sounds.explosion.triggerAttackRelease("C2","2n"); } update(delta){ super.update(delta); } }

    class SentryTurret extends SpecialObject { constructor(owner, position, hp=60, duration=15){ super(owner,duration); this.hp=hp; const base=new THREE.Mesh(new THREE.CylinderGeometry(.5,.7,1,8),new THREE.MeshStandardMaterial({color:owner.mesh.children[0].material.color.clone().multiplyScalar(.7)})); const head=new THREE.Mesh(new THREE.SphereGeometry(.4,8,8),new THREE.MeshStandardMaterial({color:owner.mesh.children[0].material.color})); head.position.y=.7; this.mesh=new THREE.Group(); this.mesh.add(base); this.mesh.add(head); this.mesh.position.copy(position); this.mesh.position.y=.5; scene.add(this.mesh); this.fireRate=.75; this.fireTimer=0; this.head=head; this.collider=new THREE.Box3().setFromObject(this.mesh); } update(delta,players){ super.update(delta); this.fireTimer-=delta; const opp=players.find(p=>p!==this.owner && !p.isDead && p.hp>0 && p.status.cloaked <= 0); if(!opp)return; const target=opp.mesh.position.clone(); this.head.lookAt(target); if(this.mesh.position.distanceTo(target) < 15 && this.fireTimer<=0){this.fireTimer=this.fireRate; const start=new THREE.Vector3(); this.head.getWorldPosition(start); const dir=new THREE.Vector3().subVectors(opp.mesh.position,start).normalize(); const proj=new Projectile(this.owner,dir,5,25,{}); proj.mesh.position.copy(start); projectiles.push(proj);}} takeDamage(amount) { this.hp -= amount; if(this.hp <= 0) this.duration = 0; } }

    class StatusAura extends SpecialObject { constructor(owner,duration,color){ super(owner,duration); const g=new THREE.TorusGeometry(1.5,.05,8,48), m=new THREE.MeshBasicMaterial({color,transparent:true}); this.mesh=new THREE.Mesh(g,m); this.mesh.rotation.x=Math.PI/2; scene.add(this.mesh); } update(delta){ super.update(delta); if(this.owner&&!this.owner.isDead&&this.owner.hp>0){this.mesh.position.copy(this.owner.mesh.position); this.mesh.position.y=.1; this.mesh.material.opacity=this.duration/this.initialDuration;}else this.duration=0;}}

    class EyeOfTheStorm extends SpecialObject { constructor(owner){ super(owner,6); this.damageInterval=.5; this.damageTimer=0; this.pullRadius=15; this.damageRadius=6; const g=new THREE.TorusGeometry(this.damageRadius,.2,16,100), m=new THREE.MeshBasicMaterial({color:0x1e90ff,blending:THREE.AdditiveBlending,transparent:true}); this.mesh=new THREE.Mesh(g,m); this.mesh.rotation.x=Math.PI/2; scene.add(this.mesh); this.aura = new PlayerAura(owner, 200, 0x1e90ff, 10, 0.2); } update(delta,players){ super.update(delta); if(!this.owner||this.owner.isDead||this.owner.hp<=0){this.duration=0;return;} this.mesh.position.copy(this.owner.mesh.position); this.mesh.position.y=.2; this.mesh.rotation.z+=delta*3; this.mesh.material.opacity=.5+Math.sin(this.duration*5)*.25; const opp=players.find(p=>p!==this.owner && !p.isDead); if(opp){const dir=new THREE.Vector3().subVectors(this.owner.mesh.position,opp.mesh.position); const dist=dir.length(); if(dist<this.pullRadius){dir.normalize(); opp.velocity.add(dir.multiplyScalar(35*delta*(1-dist/this.pullRadius)));}} this.damageTimer-=delta; if(this.damageTimer<=0){this.damageTimer=this.damageInterval; players.forEach(p=>{if(!p.isDead && p.mesh.position.distanceTo(this.mesh.position)<this.damageRadius){if(p!==this.owner)p.takeDamage(8,true);}});}} destroy() { if (this.aura) this.aura.destroy(); super.destroy(); } }

    class Singularity extends SpecialObject { constructor(owner, position) { super(owner, 5); const g = new THREE.SphereGeometry(2, 16, 16), m = new THREE.MeshBasicMaterial({ color: 0x6a0dad, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending }); this.mesh = new THREE.Mesh(g, m); this.mesh.position.copy(position); scene.add(this.mesh); this.aura = new PlayerAura(this, 100, 0x6a0dad, 5, 0.1); } update(delta, players) { super.update(delta); if (this.aura && this.aura.update) this.aura.update(delta); players.forEach(p => { if (p !== this.owner && !p.isDead) { const dir = new THREE.Vector3().subVectors(this.mesh.position, p.mesh.position); if (dir.length() < 10) { p.velocity.add(dir.normalize().multiplyScalar(20 * delta)); } } }); } destroy() { if (this.aura) this.aura.destroy(); super.destroy(); } }

    // --- VORTEX REDESIGN: CrushingSingularity Orb (Spawned by S1 projectile) ---
    class CrushingSingularity extends SpecialObject {
        constructor(owner, position) {
            super(owner, 3); // Orb lasts 3 seconds
            const ownerColor = CHARACTERS[owner.characterKey]?.color || 0x6a0dad;
            const g = new THREE.SphereGeometry(2.5, 16, 16); // Orb visual size
            const m = new THREE.MeshBasicMaterial({ color: ownerColor, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
            this.mesh = new THREE.Mesh(g, m);
            this.mesh.position.copy(position);
            this.mesh.position.y = 2; // Position orb vertically
            scene.add(this.mesh);
            this.aura = new PlayerAura(this, 100, ownerColor, 8, 0.15); // Add visual effect to the orb (pass 'this' as owner)
            if (!this.aura.mesh) this.aura = null; // Nullify if failed
            this.damageTimer = 1.0; // Damage tick rate (once per second)
            this.pullRadius = 8; // Pull radius
            this.damageRadius = 2.5; // Damage radius (matches visual size)
        }
        update(delta, players) {
            super.update(delta); // Countdown duration
            if (this.aura) this.aura.update(delta); // Update aura visual

            // Pull players towards the orb
            players.forEach(p => {
                if (p !== this.owner && p && !p.isDead && p.mesh && p.mesh.position.distanceTo(this.mesh.position) < this.pullRadius) {
                    const pullDir = new THREE.Vector3().subVectors(this.mesh.position, p.mesh.position);
                    if (pullDir.lengthSq() > 0.01) { // Avoid division by zero
                        p.velocity.add(pullDir.normalize().multiplyScalar(10 * delta)); // Pull force
                    }
                }
            });

            // Damage players within the orb's damage radius
            this.damageTimer -= delta;
            if (this.damageTimer <= 0) {
                players.forEach(p => {
                    if (p !== this.owner && p && !p.isDead && p.mesh && p.mesh.position.distanceTo(this.mesh.position) < this.damageRadius) {
                        p.takeDamage(15); // Damage per tick
                        // Damage tick visual effect (runs for everyone)
                        specialObjects.push(new ParticleSystem(p.mesh.position.clone().setY(2), {count: 15, duration: 0.3, speed: 3, startColor: new THREE.Color(this.mesh.material.color), endSize: 0}));
                        // Gravity Mark applied by orb DoT
                        if (p.status.gravityMarks !== undefined) {
                            p.status.gravityMarks++;
                        } else {
                            p.status.gravityMarks = 1;
                        }
                        p.status.gravityMarkTimer = 4; // 4 second duration
                    }
                });
                // Reset damage timer after checking all players
                this.damageTimer = 1.0;
            }
        }
        destroy() {
            if (this.aura) this.aura.destroy(); // Clean up aura
            super.destroy(); // Clean up mesh
        }
    } // End CrushingSingularity class

    class Doppelganger extends SpecialObject {
        constructor(owner, duration=8, opacity=0.5, damage=5) {
            super(owner, duration);
            this.mesh = createCharacterModel(CHARACTERS[owner.characterKey], false);
            this.mesh.position.copy(owner.mesh.position).add(new THREE.Vector3(Math.random() * 4 - 2, 0, Math.random() * 4 - 2));
            scene.add(this.mesh);
            this.mesh.traverse(c => { if (c.material) {c.material.transparent = true; c.material.opacity = opacity;} });
            this.attackTimer = 1.5;
            this.speed = CHARACTERS[owner.characterKey].speed * 0.8;
            this.attackRange = CHARACTERS[owner.characterKey].attackType === 'MELEE' ? 4.0 : 0; // Only melee clones attack
            this.damage = damage;
        }
        update(delta, players) {
            super.update(delta);
            this.attackTimer -= delta;
            const opp = players.find(p => p !== this.owner && !p.isDead);
            if (!opp) return;

            const direction = new THREE.Vector3().subVectors(opp.mesh.position, this.mesh.position);
             if (direction.lengthSq() > 0.001) {
                this.mesh.lookAt(opp.mesh.position.clone().setY(this.mesh.position.y));
            }

            if (direction.length() > this.attackRange * 0.8) {
                direction.normalize();
                this.mesh.position.add(direction.multiplyScalar(this.speed * delta));
            }

            if (this.attackRange > 0 && this.attackTimer <= 0 && this.mesh.position.distanceTo(opp.mesh.position) < this.attackRange) {
                this.attackTimer = 1.5;
                opp.takeDamage(this.damage);
                 const mockOwnerForSlash = {
                     mesh: this.mesh,
                     aimDirection: new THREE.Vector3().subVectors(opp.mesh.position, this.mesh.position).normalize(),
                     mesh: {
                         position: this.mesh.position.clone(),
                         quaternion: this.mesh.quaternion.clone(),
                         children: [{ material: { color: this.mesh.children[0].material.color.clone() } }]
                     }
                 };
                specialObjects.push(new MeleeSlash(mockOwnerForSlash, mockOwnerForSlash.mesh.children[0].material.color));
            }
        }
        destroy() {
             if (this.mesh) {
                 scene.remove(this.mesh);
                 this.mesh.traverse(child => {
                     if (child.geometry) child.geometry.dispose();
                     if (child.material) {
                         if (Array.isArray(child.material)) {
                             child.material.forEach(mat => mat.dispose());
                         } else {
                             child.material.dispose();
                         }
                     }
                 });
                 this.mesh = null;
             }
             super.destroy();
        }
    }

    // --- VORTEX REDESIGN: ImplosionEffect (S3) ---
    class ImplosionEffect extends SpecialObject {
        constructor(owner, target) {
            super(owner, 3); // 3 second delay before detonation
            this.target = target; // The player marked for implosion
            const ownerColor = CHARACTERS[owner.characterKey]?.color || 0x6a0dad;
            // Marker visual on target
            const g = new THREE.SphereGeometry(1, 16, 16);
            const m = new THREE.MeshBasicMaterial({ color: ownerColor, transparent: true, opacity: 0.7 });
            this.mesh = new THREE.Mesh(g, m);
            this.mesh.position.copy(target.mesh.position);
            this.mesh.position.y = 3; // Position above target
            scene.add(this.mesh);
            // Countdown particles
            this.particleSystem = new ParticleSystem(this.mesh.position.clone().setY(3.5), {
                count: 30, duration: 3, speed: 0, startColor: new THREE.Color(ownerColor), endColor: new THREE.Color(0xff0000),
                startSize: 0.2, endSize: 0.05
            });
            specialObjects.push(this.particleSystem);
        }
        update(delta, players) {
            super.update(delta);
            // Follow target
            if (this.target && this.target.mesh) {
                this.mesh.position.copy(this.target.mesh.position);
                this.mesh.position.y = 3;
                if (this.particleSystem && this.particleSystem.mesh) {
                    this.particleSystem.mesh.position.copy(this.target.mesh.position);
                    this.particleSystem.mesh.position.y = 3.5;
                }
            }

            // Detonate when timer expires
            if (this.duration <= 0 && this.target) {
                const detonatePos = this.target.mesh.position.clone();
                // Visual effect
                specialObjects.push(new ParticleSystem(detonatePos.clone().setY(2), {
                    count: 100, duration: 1, speed: 15, gravity: -20,
                    startColor: new THREE.Color(CHARACTERS[this.owner.characterKey]?.color || 0x6a0dad),
                    endColor: new THREE.Color(0x000000)
                }));
                if(audioReady) sounds.explosion.triggerAttackRelease("A2", "2n");

                // Apply damage and pull to all players near the target
                players.forEach(p => {
                    if (p && !p.isDead && p.mesh && p.mesh.position.distanceTo(detonatePos) < 5) {
                        // Damage players (more to target)
                        if (p === this.target) {
                            p.takeDamage(30); // High damage to target
                        } else {
                            p.takeDamage(15); // Lower damage to others
                        }
                        // Pull players towards the detonation target (unless they are the target)
                        if (p !== this.target) {
                            const pullDir = new THREE.Vector3().subVectors(detonatePos, p.mesh.position);
                            if (pullDir.lengthSq() > 0.01) { // Avoid division by zero
                                p.velocity.add(pullDir.normalize().multiplyScalar(30)); // Strong pull force
                            }
                        }
                    }
                });

                // Effect is done, will be destroyed automatically in the main loop
            }
        }
        // Destroy method inherited (removes the marker mesh)
    } // End ImplosionEffect class

    class BarrierWall extends SpecialObject { constructor(owner, position, quaternion, duration=8, size=[10,5,0.5]) { super(owner, duration); const g = new THREE.BoxGeometry(size[0], size[1], size[2]), m = new THREE.MeshStandardMaterial({color: CHARACTERS[owner.characterKey].color, transparent: true, opacity: 0.6}); this.mesh = new THREE.Mesh(g,m); this.mesh.position.copy(position); this.mesh.quaternion.copy(quaternion); this.mesh.position.y=size[1]/2; scene.add(this.mesh); this.collider = new THREE.Box3().setFromObject(this.mesh); this.blocksProjectiles = true; } update(delta) { super.update(delta); }}

    // --- VORTEX REDESIGN: BlackHole (S4) ---
    class BlackHole extends SpecialObject {
        constructor(owner, position) {
            super(owner, 5); // 5 second duration
            this.pullRadius = 15; // Large pull radius
            this.markTimer = 1.0; // Apply Gravity Mark every 1 second
            const ownerColor = CHARACTERS[owner.characterKey]?.color || 0x6a0dad;
            // Black hole core visual
            const g = new THREE.SphereGeometry(3, 32, 32);
            const m = new THREE.MeshBasicMaterial({ color: 0x110011, transparent: true, opacity: 0.8 }); // Dark core
            this.mesh = new THREE.Mesh(g, m);
            this.mesh.position.copy(position);
            this.mesh.position.y = 2; // Center vertically
            scene.add(this.mesh);
            // Swirling particle aura
            this.aura = new PlayerAura(this, 200, ownerColor, 15, 0.2);
            if (!this.aura.mesh) this.aura = null; // Nullify if failed
            // Event horizon ring
            const ringGeo = new THREE.TorusGeometry(this.pullRadius, 0.5, 8, 64);
            const ringMat = new THREE.MeshBasicMaterial({ color: ownerColor, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            this.ring = new THREE.Mesh(ringGeo, ringMat);
            this.ring.position.copy(position);
            this.ring.position.y = 0.1; // On the ground
            this.ring.rotation.x = Math.PI / 2; // Flat on ground
            scene.add(this.ring);
        }
        update(delta, players) {
            super.update(delta); // Countdown duration
            if (this.aura) this.aura.update(delta); // Update swirling particles
            // Rotate ring for visual effect
            if (this.ring) {
                this.ring.rotation.z += delta * 2;
                // Pulsing opacity
                this.ring.material.opacity = 0.2 + Math.sin(this.duration * 5) * 0.1;
            }

            // Pull all players within pull radius
            players.forEach(p => {
                if (p && !p.isDead && p.mesh && p.mesh.position.distanceTo(this.mesh.position) < this.pullRadius) {
                    const pullDir = new THREE.Vector3().subVectors(this.mesh.position, p.mesh.position);
                    // Stronger pull closer to center
                    const distance = pullDir.length();
                    if (distance > 0.5) { // Avoid extreme forces at center
                        pullDir.normalize();
                        const pullStrength = 40 * delta * (1 - distance / this.pullRadius); // Weaker pull at edge
                        p.velocity.add(pullDir.multiplyScalar(pullStrength));
                    }
                    // Lift players slightly
                    p.velocity.y += 5 * delta;
                }
            });

            // Apply Gravity Mark periodically
            this.markTimer -= delta;
            if (this.markTimer <= 0) {
                players.forEach(p => {
                    if (p && p !== this.owner && !p.isDead && p.mesh && p.mesh.position.distanceTo(this.mesh.position) < this.pullRadius) {
                        // Apply gravity mark
                        if (p.status.gravityMarks !== undefined) {
                            p.status.gravityMarks++;
                        } else {
                            p.status.gravityMarks = 1;
                        }
                        p.status.gravityMarkTimer = 4; // 4 second duration
                    }
                });
                this.markTimer = 1.0; // Reset timer
            }

            // Damage players very close to the center
            players.forEach(p => {
                if (p && !p.isDead && p.mesh && p.mesh.position.distanceTo(this.mesh.position) < 3) {
                    p.takeDamage(5 * delta); // Damage over time
                }
            });
        }
        destroy() {
            if (this.aura) this.aura.destroy(); // Clean up particle aura
            if (this.ring) {
                scene.remove(this.ring);
                if (this.ring.geometry) this.ring.geometry.dispose();
                if (this.ring.material) this.ring.material.dispose();
            }
            super.destroy(); // Clean up core mesh
        }
    } // End BlackHole class

    class AdrenalHaze extends SpecialObject { constructor(owner) { super(owner, 6); const g = new THREE.SphereGeometry(8, 32, 32), m = new THREE.MeshBasicMaterial({color: CHARACTERS['CATALYST'].color, transparent: true, opacity: 0.2}); this.mesh = new THREE.Mesh(g,m); this.mesh.position.copy(owner.mesh.position); scene.add(this.mesh); this.tickTimer = 1; this.aura = new PlayerAura(this, 150, 0x00ff7f, 2, 0.1); } update(delta, players) { super.update(delta); if (this.aura && this.aura.update) this.aura.update(delta); this.tickTimer -= delta; if(this.tickTimer <= 0) { this.tickTimer = 1; players.forEach(p => { if(!p.isDead && p.mesh.position.distanceTo(this.mesh.position) < 8) { if(p === this.owner) p.speed = CHARACTERS[p.characterKey].speed * 1.2; else p.status.slowed = 1.1; } else if (p === this.owner && p.speed > CHARACTERS[p.characterKey].speed) { p.speed = CHARACTERS[p.characterKey].speed; } });} } destroy() { if (this.aura) this.aura.destroy(); super.destroy(); if(this.owner) this.owner.speed = CHARACTERS[this.owner.characterKey].speed; } }

    class BladeFury extends SpecialObject { constructor(owner) { super(owner, 3); this.slashes = []; this.slashTimer = 0.2; this.color = CHARACTERS['RONIN'].color; this.aura = new PlayerAura(owner, 100, 0xff4500, 20, 0.1); } update(delta, players) { super.update(delta); this.slashTimer -= delta; if(this.slashTimer <= 0) { this.slashTimer = 0.2; const slash = new MeleeSlash(this.owner, this.color); specialObjects.push(slash); const opp = players.find(p => p !== this.owner && !p.isDead); if (opp && opp.mesh.position.distanceTo(this.owner.mesh.position) < this.owner.attackRange * 1.5) { opp.takeDamage(8); } } } destroy() { if (this.aura) this.aura.destroy(); super.destroy(); } }

    // --- NEW CLASSES FOR EMPEROR ---

    class SandSoldier extends SpecialObject {
        constructor(owner, position, duration = 10) {
            super(owner, duration);
            this.hp = 60; // Make them killable
            const color = new THREE.Color(CHARACTERS['MIRAGE'].color);
            const mat = new THREE.MeshStandardMaterial({ color, metalness: .7, roughness: .4, emissive: color, emissiveIntensity: 0.3 });

            // Helper to create parts (local to this constructor)
            const createPart = (geo, mat, pos, rot = [0, 0, 0]) => {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(pos[0], pos[1], pos[2]);
                mesh.rotation.set(rot[0], rot[1], rot[2]);
                mesh.castShadow = true;
                return mesh;
            };

            const g = new THREE.Group();
            g.add(createPart(new THREE.ConeGeometry(0.3, 3, 4), mat, [0, 1.5, 0])); // Body
            g.add(createPart(new THREE.IcosahedronGeometry(0.5, 0), mat, [0, 3.3, 0])); // Head
            this.spear = createPart(new THREE.CylinderGeometry(0.05, 0.05, 4, 6), mat, [0.5, 2, 1.5], [Math.PI / 3, 0, 0]);
            g.add(this.spear);
            this.mesh = g;
            this.mesh.position.copy(position);
            scene.add(this.mesh);

            this.attackRange = 6;
            this.attackTimer = 0;
            this.damage = 15;
            this.isDashing = false;
            this.dashTarget = new THREE.Vector3();
            this.dashSpeed = 25;
            this.hitDuringDash = false;

            this.collider = new THREE.Box3().setFromObject(this.mesh);
            specialObjects.push(new SpawnEffect(this.mesh.position, color));
        }

        update(delta, players) {
            super.update(delta);
            const opp = players.find(p => p !== this.owner && !p.isDead);

            if (this.isDashing) {
                if (!opp) { this.isDashing = false; return; }
                const dir = new THREE.Vector3().subVectors(this.dashTarget, this.mesh.position);
                if (dir.length() < 1) {
                    this.isDashing = false;
                    this.hitDuringDash = false; // Reset for next dash
                    return;
                }
                dir.normalize();
                this.mesh.position.add(dir.multiplyScalar(this.dashSpeed * delta));

                if (opp && !this.hitDuringDash && opp.mesh.position.distanceTo(this.mesh.position) < 2) {
                    opp.takeDamage(10); // Dash damage
                    opp.status.slowed = 1.5;
                    this.hitDuringDash = true;
                }
                return;
            }

            this.attackTimer -= delta;
            if (!opp) return;

            const targetPos = opp.mesh.position.clone().setY(this.mesh.position.y);
            this.mesh.lookAt(targetPos);

            if (this.attackTimer <= 0 && this.mesh.position.distanceTo(opp.mesh.position) < this.attackRange) {
                this.attackTimer = 1.2 / (1 + (this.owner?.passiveState.attackSpeedStacks || 0) * 0.2); // Attack speed scales with owner's passive

                // Animate spear using simple position change + setTimeout
                const originalZ = this.spear.position.z;
                this.spear.position.z = originalZ + 1.0; // Thrust forward
                setTimeout(() => {
                    // Check if spear still exists before resetting position
                    if (this.spear) {
                        this.spear.position.z = originalZ; // Return to original position
                    }
                }, 100); // Reset after 100ms

                opp.takeDamage(this.damage);
                if(audioReady) sounds.hit.triggerAttackRelease("A4","16n");

                // Trigger owner's passive
                if (this.owner) {
                    this.owner.passiveState.attackSpeedStacks = Math.min(3, (this.owner.passiveState.attackSpeedStacks || 0) + 1);
                    this.owner.passiveState.attackSpeedTimer = 3; // Refresh duration
                }
            }
        }

        dashTo(targetPos) {
            this.dashTarget.copy(targetPos);
            this.isDashing = true;
            this.hitDuringDash = false;
        }

        takeDamage(amount) {
            this.hp -= amount;
            if (this.hp <= 0) this.duration = 0;
        }
    }

    class SoldierWall extends SpecialObject {
        constructor(owner, position, quaternion) {
            super(owner, 2.5); // Wall duration
            const g = new THREE.BoxGeometry(16, 5, 0.5); // 16 units wide
            const m = new THREE.MeshStandardMaterial({ color: CHARACTERS['MIRAGE'].color, transparent: true, opacity: 0.7, emissive: CHARACTERS['MIRAGE'].color, emissiveIntensity: 0.4 });
            this.mesh = new THREE.Mesh(g, m);
            this.mesh.position.copy(position);
            this.mesh.quaternion.copy(quaternion);
            this.mesh.position.y = 2.5;
            scene.add(this.mesh);

            this.collider = new THREE.Box3().setFromObject(this.mesh);
            this.blocksProjectiles = true;
            this.speed = 8;
            this.hitPlayers = new Set();
        }

        update(delta, players) {
            super.update(delta);
            // Move forward
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.mesh.quaternion); // Move "forward" relative to player's aim
            this.mesh.position.add(forward.multiplyScalar(this.speed * delta));
            this.collider.setFromObject(this.mesh);

            players.forEach(p => {
                if (p !== this.owner && !p.isDead && !this.hitPlayers.has(p) && this.collider.intersectsBox(p.collider)) {
                    p.takeDamage(30);
                    const knockbackDir = forward.clone().setY(0.2).normalize(); // Slight knock-up
                    p.velocity.add(knockbackDir.multiplyScalar(35));
                    this.hitPlayers.add(p);
                }
            });
        }
    }

    // --- V5 NEW ULTIMATE ABILITY CLASSES ---

    class OrbitalStrikeMarker extends SpecialObject {
        constructor(owner, position) {
            super(owner, 2); // 2 second delay
            const g = new THREE.CylinderGeometry(5, 5, 0.2, 32, 1, true);
            const m = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            this.mesh = new THREE.Mesh(g, m);
            this.mesh.position.copy(position);
            this.mesh.position.y = 0.1;
            scene.add(this.mesh);
        }
        update(delta, players) {
            super.update(delta);
            this.mesh.material.opacity = 0.5 + Math.sin(this.initialDuration - this.duration) * 5 * 0.25;
            if (this.duration <= 0) {
                if(audioReady) sounds.explosion.triggerAttackRelease("A1", "1n");
                specialObjects.push(new ParticleSystem(this.mesh.position, {
                    count: 300, duration: 1.5, speed: 20, startColor: new THREE.Color(0xffa500), endColor: new THREE.Color(0xff0000), gravity: -10
                }));
                players.forEach(p => {
                    if (!p.isDead && p.mesh.position.distanceTo(this.mesh.position) < 5) {
                        p.takeDamage(60);
                    }
                });
            }
        }
    }

    class Thunderstorm extends SpecialObject {
        constructor(owner) {
            super(owner, 6);
            this.boltTimer = 0.4;
            this.aura = new PlayerAura(owner, 200, 0x1e90ff, 10, 0.2);
        }
        update(delta, players) {
            super.update(delta);
            if (!this.owner || this.owner.isDead) { this.duration = 0; return; }
            this.boltTimer -= delta;
            if (this.boltTimer <= 0) {
                this.boltTimer = 0.4;
                const strikePos = this.owner.mesh.position.clone().add(new THREE.Vector3((Math.random() - 0.5) * 16, 0, (Math.random() - 0.5) * 16));
                strikePos.y = 0;
                specialObjects.push(new ParticleSystem(strikePos.clone().setY(10), {
                    count: 50, duration: 0.5, speed: 5, startColor: new THREE.Color(0x00ffff), endColor: new THREE.Color(0x1e90ff), gravity: -40
                }));
                players.forEach(p => {
                    if (!p.isDead && p.mesh.position.distanceTo(strikePos) < 2.5) {
                        p.takeDamage(15);
                    }
                });
            }
        }
        destroy() { if (this.aura) this.aura.destroy(); super.destroy(); }
    }

    class PulverizeLeap extends SpecialObject {
        constructor(owner, targetPos) {
            super(owner, 1.0); // Duration of leap
            this.startPos = owner.mesh.position.clone();
            this.targetPos = targetPos;
            this.owner.status.unstoppable = 1.0;
            this.owner.status.rooted = 1.0; // Root owner during leap
        }
        update(delta, players) {
            super.update(delta);
            if (!this.owner || this.owner.isDead) { this.duration = 0; return; }

            const progress = 1 - (this.duration / this.initialDuration);
            const leapPos = new THREE.Vector3().lerpVectors(this.startPos, this.targetPos, progress);
            leapPos.y = this.startPos.y + Math.sin(progress * Math.PI) * 8; // Arc
            this.owner.mesh.position.copy(leapPos);

            if (this.duration <= 0) {
                if(audioReady) sounds.explosion.triggerAttackRelease("C2", "2n");
                specialObjects.push(new TectonicSlam(this.owner)); // Re-use slam effect
                players.forEach(p => {
                    if (p !== this.owner && !p.isDead && p.mesh.position.distanceTo(this.targetPos) < 5) {
                        p.takeDamage(40);
                        p.status.rooted = 1.5; // Stun
                    }
                });
            }
        }
    }

    class TimeStopEffect extends SpecialObject {
        constructor(owner, duration) {
            super(owner, duration);
            this.aura = new PlayerAura(this, 300, 0x40e0d0, 1, 0.1);
            this.mesh = new THREE.Mesh(new THREE.SphereGeometry(20, 32, 32), new THREE.MeshBasicMaterial({color: 0x40e0d0, transparent: true, opacity: 0.2, side: THREE.BackSide})); // BackSide for effect
            this.mesh.position.copy(owner.mesh.position);
            scene.add(this.mesh);
            this.frozenProjectiles = [];
        }
        update(delta, players, projs) {
            super.update(delta);
            if (this.aura && this.aura.update) this.aura.update(delta);
            this.mesh.material.opacity = (this.duration / this.initialDuration) * 0.2;
            this.mesh.position.copy(this.owner.mesh.position); // Follow owner

            players.forEach(p => {
                if (p !== this.owner && !p.isDead && p.mesh.position.distanceTo(this.mesh.position) < 20) {
                    p.status.rooted = 0.1; // Re-apply root every frame
                    p.velocity.set(0,0,0);
                }
            });
            projs.forEach(p => {
                if (p.mesh.position.distanceTo(this.mesh.position) < 20 && p.speed > 0.001) {
                    p.speed = 0.001; // Effectively stop
                    if (!this.frozenProjectiles.includes(p)) this.frozenProjectiles.push(p);
                }
            });
        }
        destroy() {
            if (this.aura) this.aura.destroy();
            this.frozenProjectiles.forEach(p => {
                if (p && p.originalSpeed) p.speed = p.originalSpeed;
            });
            this.frozenProjectiles = [];
            super.destroy();
        }
    }

    class GaleForceTornado extends SpecialObject {
        constructor(owner, direction) {
            super(owner, 5); // 5 second travel time
            this.direction = direction.clone();
            this.speed = 10;

            this.mesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 3, 6, 16, 1, true), new THREE.MeshBasicMaterial({color: 0x90ee90, transparent: true, opacity: 0.4, side: THREE.DoubleSide}));

            if (owner && owner.mesh) {
                this.mesh.position.copy(owner.mesh.position).add(new THREE.Vector3(0,3,0));
            } else {
                console.error("GaleForceTornado created without valid owner mesh, placing at origin.");
                this.mesh.position.set(0, 3, 0); // Fallback
            }

            scene.add(this.mesh);

            this.aura = new PlayerAura(this, 150, 0x90ee90, 20, 0.2); // Pass 'this' as owner for aura positioning

            this.hitPlayers = new Set();
        }
        update(delta, players) {
            super.update(delta);
            if (this.aura && this.aura.update) this.aura.update(delta);
            this.mesh.position.add(this.direction.clone().multiplyScalar(this.speed * delta));
            this.mesh.rotation.y += delta * 5; // Spin effect

            players.forEach(p => {
                if (p !== this.owner && !p.isDead && !this.hitPlayers.has(p)) {
                    if (p.mesh.position.distanceTo(this.mesh.position) < 3.5) {
                        p.takeDamage(30);
                        p.velocity.add(this.direction.clone().multiplyScalar(15)); // Knockback
                        this.hitPlayers.add(p);
                    }
                }
            });
        }
        destroy() { if (this.aura) this.aura.destroy(); super.destroy(); }
    }

    class AnvilTurret extends SentryTurret {
        constructor(owner, position) {
            super(owner, position, 200, 30); // 200 HP, 30s duration
            this.fireRate = 0.25; // Fires much faster
            this.damage = 8; // Increase damage per shot
        }
        update(delta, players) {
            // Overrides SentryTurret update to pass correct damage
            this.duration -= delta;
            this.fireTimer -= delta;
            const opp = players.find(p => p !== this.owner && !p.isDead && p.hp > 0 && p.status.cloaked <= 0);
            if (!opp) return;
            const target = opp.mesh.position.clone();
            this.head.lookAt(target);
            if (this.mesh.position.distanceTo(target) < 18 && this.fireTimer <= 0) {
                this.fireTimer = this.fireRate;
                const start = new THREE.Vector3();
                this.head.getWorldPosition(start);
                const dir = new THREE.Vector3().subVectors(opp.mesh.position.clone().setY(2), start).normalize(); // Aim slightly higher
                const proj = new Projectile(this, dir, this.damage, 30, {}); // Use stored damage
                proj.mesh.position.copy(start);
                projectiles.push(proj);
            }
        }
    }

    class PlagueCloud extends AdrenalHaze {
        constructor(owner) {
            super(owner);
            this.duration = 8;
            this.mesh.material.color.set(CHARACTERS['CATALYST'].color);
             if (this.aura) this.aura.mesh.material.color.set(CHARACTERS['CATALYST'].color); // Match aura color
        }
        update(delta, players) {
            // Does not call super.update() to avoid speed buff
            this.duration -= delta;
            if (this.aura && this.aura.update) this.aura.update(delta);
            this.tickTimer -= delta;
            if (this.tickTimer <= 0) {
                this.tickTimer = 1;
                players.forEach(p => {
                    if (!p.isDead && p.mesh.position.distanceTo(this.mesh.position) < 8) {
                        if (p !== this.owner) {
                            p.status.venom = 2; // Reapply venom
                            p.status.corruption = 2; // Add corruption
                        }
                    }
                });
            }
        }
    }

    class ShadowStrikeDash extends SpecialObject {
        constructor(owner, targets) {
            super(owner, targets.length * 0.4 + 0.2); // 0.4s per target
            this.targets = targets.filter(t => t && !t.isDead); // Ensure targets are valid
            this.currentTargetIndex = 0;
            if (this.targets.length === 0) { this.duration = 0; return; } // No valid targets

            this.target = this.targets[0];
            this.startPos = owner.mesh.position.clone(); // Store start pos for first lerp
            this.dashTimer = 0.4;
            this.owner.status.unstoppable = this.duration; // Untargetable
            this.owner.mesh.visible = false; // Hide owner
        }
        update(delta, players) {
            super.update(delta);
            if (!this.owner || !this.target || this.owner.isDead || this.target.isDead) { this.duration = 0; return; }

            this.dashTimer -= delta;

            // Particle trail at current "invisible" position
            specialObjects.push(new ParticleSystem(this.owner.mesh.position.clone().setY(2), {
                count: 15, duration: 0.3, speed: 3, startColor: new THREE.Color(CHARACTERS['RONIN'].color), endSize: 0
            }));

            // Move owner smoothly towards the current target
            const progress = 1 - Math.max(0, this.dashTimer / 0.4);
            this.owner.mesh.position.lerpVectors(this.startPos, this.target.mesh.position, progress);

            if (this.dashTimer <= 0) {
                // Strike target
                this.target.takeDamage(25);
                // Create slash effect at target location, oriented towards owner's last position
                const slashOwner = { // Mock owner for positioning slash
                    mesh: {
                        position: this.target.mesh.position.clone(),
                        quaternion: new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), new THREE.Vector3().subVectors(this.startPos, this.target.mesh.position).normalize()),
                        children: [{ material: { color: new THREE.Color(CHARACTERS['RONIN'].color) } }]
                    },
                    aimDirection: new THREE.Vector3(0,0,1) // Doesn't matter much for slash shape
                }
                specialObjects.push(new MeleeSlash(slashOwner, CHARACTERS['RONIN'].color));
                if(audioReady) sounds.hit.triggerAttackRelease("C4","16n");

                // Move to next target
                this.currentTargetIndex++;
                if (this.currentTargetIndex >= this.targets.length) {
                    this.duration = 0; // End
                } else {
                    this.target = this.targets[this.currentTargetIndex];
                    this.startPos.copy(this.owner.mesh.position); // Update start position for next lerp
                    this.dashTimer = 0.4;
                }
            }
        }
        destroy() {
            if (this.owner) {
                this.owner.mesh.visible = true; // Make owner visible again
                 // Snap owner to the last target's position or nearby
                if(this.targets && this.targets.length > 0) {
                   const lastTargetPos = this.targets[this.targets.length - 1].mesh.position;
                   this.owner.mesh.position.copy(lastTargetPos).add(new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).multiplyScalar(2)); // Appear near last target
                }
            }
            super.destroy();
        }
    }


    class Projectile {
        constructor(owner, direction, damage, speed, { size=0.3, life=3, effects=null, piercing=false }={}){
            this.owner=owner;
            this.damage = (owner && owner.status?.riftBuff > 0) ? damage * 1.5 : damage;
            this.speed=speed;
            this.originalSpeed = speed; // Store original speed for TimeStop
            this.direction=direction; this.life=life; this.effects=effects; this.piercing=piercing; this.hitPlayers=new Set(); this.gracePeriod=.1;

            let ownerColor = new THREE.Color(0xffffff);
            // Determine color robustly
            const sourcePlayer = (owner instanceof Player) ? owner : owner?.owner; // Handle turrets/soldiers owning projectiles
            if (sourcePlayer instanceof Player && sourcePlayer.mesh && sourcePlayer.mesh.children[0] && sourcePlayer.mesh.children[0].material) {
                ownerColor = sourcePlayer.mesh.children[0].material.color;
            }

            const g=new THREE.SphereGeometry(size,8,8), m=new THREE.MeshBasicMaterial({ color: ownerColor, blending: THREE.AdditiveBlending });
            this.mesh=new THREE.Mesh(g,m);
            // Position projectile correctly even if owner is a SpecialObject (like turret head)
            if (owner && owner.mesh) {
                const worldPos = new THREE.Vector3();
                owner.mesh.getWorldPosition(worldPos); // Get world position of owner's mesh origin
                this.mesh.position.copy(worldPos).add(new THREE.Vector3(0,2,0)); // Start from ~center height
                // Offset slightly in fire direction
                this.mesh.position.add(direction.clone().multiplyScalar(1.5));
            } else {
                console.warn("Projectile created without valid owner mesh position!");
                this.mesh.position.set(0, 2, 0);
            }
            const light=new THREE.PointLight(this.mesh.material.color,2,5); this.mesh.add(light); scene.add(this.mesh);

            specialObjects.push(new ParticleSystem(this.mesh.position, {
                count: 20, duration: 0.3, speed: 3, startColor: new THREE.Color(0xffffff), endColor: ownerColor,
                startSize: 0.2, endSize: 0, emissionShape: 'cone', direction: direction
            }));
            if(audioReady) sounds.shoot.triggerAttackRelease("C5","16n");
        }
        update(delta){
             if(this.speed < 0.1) return; // Stopped by Time Stop
            this.life-=delta; this.gracePeriod-=delta; if(this.life<=0){ this.destroy(); return; }
            this.mesh.position.add(this.direction.clone().multiplyScalar(this.speed*delta));
            if(this.gracePeriod>0) return;
            const projCollider = new THREE.Box3().setFromObject(this.mesh); // Simple bounding box for projectile

            for(const p of window.players){
                 // Ensure owner check works for projectiles fired by SpecialObjects
                const projOwnerPlayer = (this.owner instanceof Player) ? this.owner : this.owner?.owner;
                if(p !== projOwnerPlayer && !p.isDead && !this.hitPlayers.has(p)){
                     // Use player's main collider
                    if(p.collider.intersectsBox(projCollider)){ // Check intersection
                        p.takeDamage(this.damage);
                        if(this.effects) {
                           // Apply effects carefully, ensuring values are numbers
                           Object.keys(this.effects).forEach(key => {
                             if(typeof this.effects[key] === 'number') {
                                p.status[key] = (p.status[key] || 0) + this.effects[key];
                             }
                           });
                        }
                        if(!this.piercing){ this.destroy(); return; }
                        this.hitPlayers.add(p);
                    }
                }
            }
            for(const obs of obstacles){ if(obs.intersectsBox?.(projCollider)){ this.destroy(); return; } } // Check intersection
            for(const o of specialObjects){
                // Projectiles shouldn't hit their own owner or the entity that fired them
                const ownerCheck = (o === this.owner) || (o.owner === this.owner) || (o === this.owner?.owner);
                if (!ownerCheck && o.collider && o.collider.intersectsBox(projCollider)) {
                     if(o.blocksProjectiles) { this.destroy(); return; }
                     if(o instanceof SentryTurret || o instanceof SandSoldier) {
                         if (typeof o.takeDamage === 'function') o.takeDamage(this.damage);
                         this.destroy();
                         return;
                     }
                 }
            }
        }
        destroy(){
            if (this.mesh) {
                specialObjects.push(new ParticleSystem(this.mesh.position, {count: 20, duration: 0.5, speed: 5, startColor: new THREE.Color(this.mesh.material.color), endColor: new THREE.Color(0x000000)}));
                scene.remove(this.mesh);
                if (this.mesh.geometry) this.mesh.geometry.dispose();
                if (this.mesh.material) this.mesh.material.dispose();
                this.mesh = null;
            }
            const i=projectiles.indexOf(this); if(i>-1) projectiles.splice(i,1);
        }
    }

    class Player {
        constructor(playerNum, characterKey){
            this.playerNum=playerNum; this.characterKey=characterKey; const d=CHARACTERS[characterKey];
            this.mesh=createCharacterModel(d);
            this.mesh.position.set(playerNum===1?-15:15,0,0); scene.add(this.mesh);
            this.collider=new THREE.Box3().setFromObject(this.mesh);
            this.maxHp=d.hp; this.hp=d.hp; this.maxEnergy=100; this.energy=100; this.speed=d.speed; this.skills=d.skills; this.passive=d.passive; this.attackType=d.attackType; this.attackRange=this.attackType==='MELEE'?4.0:0;
            this.status={ slowed:0, rooted:0, silenced:0, shielded:0, spellShield:0, unstoppable:0, cloaked:0, empowered:0, venom:0, corruption:0, feedbackLoop:0, isCharging:0, riftBuff:0, nextAttackVenom:false, targetingArray:0, parry:0, siege:0, dashTarget: null, gravityMarks: 0, gravityMarkTimer: 0, implosionTarget: null, implosionTimer: 0 };
            this.statusMeshes={}; this.riftLight=null; this.cooldowns={ basicAttack:0, s1:0, s2:0, s3:0, s4:0 }; this.velocity=new THREE.Vector3(); this.aimDirection=new THREE.Vector3(); this.rewindPositions=[]; this.rewindTimer=0;
            this.isDead = false;
            this.damageFlashTimeout = null; // Property to track damage flash
            this.originalEmissives = null; // Stores original colors during flash

            // Passive-specific state
            this.passiveState = {
                resonanceStacks: 0,
                fortressTimer: 0,
                staticChargeStacks: 0,
                firewallTimer: 20,
                illusionTimer: 45, // Mirage specific
                lastSkillTime: -1, // Ronin specific
                attackSpeedStacks: 0, // For Emperor
                attackSpeedTimer: 0   // For Emperor
            };

            if (this.passive.name === "Juggernaut") this.maxHp *= 1.1; this.hp = this.maxHp;
            if (this.passive.name === "Swiftness") this.speed *= 1.05;

            this.networkTargetPosition = this.mesh.position.clone();

            this.aura=null;
            switch(characterKey){
              case 'ECHO_PRIME': case 'TEMPEST': this.aura=new PlayerAura(this,50,d.color, 2, .15); break;
              case 'AEGIS': case 'COLOSSUS': case 'FORGE': this.aura=new PlayerAura(this,40,d.color,1, .2); break;
              case 'SPECTRE': case 'NULL': this.aura=new PlayerAura(this,60,d.color,3,.1); break;
              case 'MIRAGE': this.aura=new PlayerAura(this,60,d.color,1,.15); break; // Emperor aura
              case 'JAVELIN': this.aura=new PlayerAura(this,30,d.color,4,.1); break;
              case 'GLITCH': case 'CHRONOMANCER': case 'VORTEX': this.aura=new PlayerAura(this,40,d.color, 1.5,.15); break;
              case 'ORACLE': case 'CATALYST': this.aura=new PlayerAura(this,70,d.color,.8,.18); break;
              case 'ZEPHYR': case 'RONIN': this.aura=new PlayerAura(this,60,d.color,5,.12); break;
            }
            if(this.aura) specialObjects.push(this.aura);

            this.statusVisuals = {
              empowered: new StatusEffectVisual(this,'empowered',0xffff00),
              venom:     new StatusEffectVisual(this,'venom',0x00ff7f,30,'drip'),
              corruption:new StatusEffectVisual(this,'corruption',0x800080,40,'cloud'),
              gravityMark: new StatusEffectVisual(this, 'gravityMark', 0x6a0dad, 20, 'ring') // Purple ring for gravity marks
            };
            specialObjects.push(...Object.values(this.statusVisuals));
        }

        updatePassive(delta, opponent) {
            // Update passive timers
            for(const k of ['firewallTimer', 'illusionTimer', 'fortressTimer', 'attackSpeedTimer']) {
                if (this.passiveState[k] > 0) this.passiveState[k] = Math.max(0, this.passiveState[k] - delta);
            }

            // Emperor passive timer reset
            if (this.passive.name === "Imperial Will" && this.passiveState.attackSpeedTimer <= 0) {
                this.passiveState.attackSpeedStacks = 0;
            }

            switch(this.passive.name) {
                case "Fortress":
                    const isMoving = this.velocity.lengthSq() > 0.1;
                    if (!isMoving && this.status.rooted <= 0) {
                        this.passiveState.fortressTimer += delta;
                        if (this.passiveState.fortressTimer >= 2 && this.status.shielded <= 0.1) {
                             // Grant a temporary shield HP instead of status
                             this.hp = Math.min(this.maxHp, this.hp + 20); // Add 20 shield HP
                             specialObjects.push(new ShieldEffect(this, 0.5, 0xaaaaff)); // Visual effect
                             this.passiveState.fortressTimer = -5; // Cooldown after activation
                        }
                    } else {
                        // Decay shield HP if moving
                        if(this.passiveState.fortressTimer < 0) { // Only decay if shield was active
                           // Simple decay for now
                           // More complex decay could be implemented if needed
                        }
                        this.passiveState.fortressTimer = 0;
                    }
                    break;
                case "Event Horizon": // Vortex passive
                    // Check for gravity mark proc (3 stacks)
                    if (this.status.gravityMarks >= 3) {
                        this.status.gravityMarks = 0; // Consume marks
                        this.status.gravityMarkTimer = 0; // Clear timer
                        
                        // Find opponent
                        const opponent = window.players.find(p => p !== this && !p.isDead);
                        if (opponent) {
                            opponent.status.rooted = 1.5; // Stun opponent for 1.5 seconds
                            
                            // Pull opponent towards this player
                            const pullDir = new THREE.Vector3().subVectors(this.mesh.position, opponent.mesh.position);
                            if (pullDir.length() > 5) { // Only pull if further than 5 units
                                pullDir.normalize();
                                opponent.velocity.add(pullDir.multiplyScalar(25)); // Pull force
                            }
                            
                            // Visual effect
                            specialObjects.push(new ParticleSystem(opponent.mesh.position.clone().setY(2), {
                                count: 60, duration: 0.8, speed: 6, 
                                startColor: new THREE.Color(0x6a0dad), endColor: new THREE.Color(0xff00ff)
                            }));
                        }
                    }
                    break;
                // Add other passive update logic here...
            }
        }

        update(delta, opponent){
            if (this.isDead) return;

            for(const k in this.cooldowns) this.cooldowns[k] = Math.max(0,this.cooldowns[k]-delta);
            for(const k in this.status) if(typeof this.status[k]==='number') this.status[k]=Math.max(0,this.status[k]-delta);
            // Special handling for gravity marks
            if (this.status.gravityMarkTimer <= 0 && this.status.gravityMarks > 0) {
                this.status.gravityMarks = 0; // Reset stacks when timer expires
            }
            // Update gravity mark visualization
            if (this.status.gravityMarks > 0) {
                this.statusVisuals.gravityMark.visible = true;
                // Make the visual more intense with more stacks
                this.statusVisuals.gravityMark.mesh.material.opacity = 0.3 + (this.status.gravityMarks * 0.2);
            } else {
                this.statusVisuals.gravityMark.visible = false;
            }
            if(this.status.venom>0) this.takeDamage(10*delta,true);
            if(this.status.feedbackLoop>0 && opponent && opponent.energy<opponent.maxEnergy) opponent.takeDamage(15*delta,true);
            // Handle implosion timer
            if (this.status.implosionTimer > 0) {
                this.status.implosionTimer -= delta;
                if (this.status.implosionTimer <= 0 && this.status.implosionTarget) {
                    // Apply implosion effect
                    this.takeDamage(30); // Damage from implosion
                    // Apply pull effect
                    const pullDir = new THREE.Vector3().subVectors(this.status.implosionTarget.mesh.position, this.mesh.position);
                    if (pullDir.lengthSq() > 0.01) {
                        this.velocity.add(pullDir.normalize().multiplyScalar(20)); // Pull towards caster
                    }
                    // Clear implosion status
                    this.status.implosionTarget = null;
                }
            }

            let energyRegen = 5 + (window.mode.current.rift ? 15 : 0) + (this.status.riftBuff > 0 ? 10 : 0);
            if (this.passive.name === "Juggernaut") energyRegen *= 0.8;
            this.energy = Math.min(this.maxEnergy, this.energy + energyRegen*delta);

            this.updatePassive(delta, opponent);

            const isMyPlayer = !window.mode.isOnline || ((window.mode.onlineState.isHost && this.playerNum === 1) || (!window.mode.onlineState.isHost && this.playerNum === 2));

            if (isMyPlayer) {
                const move = new THREE.Vector3(0, 0, 0);
                if (this.status.rooted <= 0 && this.status.siege <= 0) {
                    const c = window.mode.isOnline ? controlsP1P2.p1 : controlsP1P2[`p${this.playerNum}`]; // Use renamed controls variable
                    if (keys[c.forward]) move.z -= 1;
                    if (keys[c.backward]) move.z += 1;
                    if (keys[c.left]) move.x -= 1;
                    if (keys[c.right]) move.x += 1;

                    if (CCA.flow.tutorialActive && CCA.flow.tutorialStep === 5 && move.lengthSq() > 0) {
                        CCA.flow.tutorialMoveTimer = Math.max(0, CCA.flow.tutorialMoveTimer - delta);
                        if (CCA.flow.tutorialMoveTimer <= 0) {
                            updateTutorial(6);
                            setTimeout(() => updateTutorial(7), 5000); // Advance after 5s
                        }
                    }
                }
                if(move.lengthSq()>0){
                    move.normalize();
                    let sp=this.speed*(this.status.riftBuff>0?1.5:1);
                    if(this.status.slowed>0 && this.status.unstoppable<=0) sp*=.5;
                    this.velocity.add(move.multiplyScalar(sp*delta*20));
                }
            }

            if(this.status.isCharging>0 && this.characterKey === 'AEGIS'){ let cs=40; this.velocity.copy(this.aimDirection).multiplyScalar(cs); }

            // Shifting Sands Dash (Emperor)
            if (this.status.isCharging > 0 && this.characterKey === 'MIRAGE') {
                const soldier = this.status.dashTarget;
                if (soldier && soldier.mesh && soldier.duration > 0) {
                    const dir = new THREE.Vector3().subVectors(soldier.mesh.position, this.mesh.position);
                    if (dir.length() < 1.5) {
                        this.status.isCharging = 0; // Arrived
                        this.velocity.set(0,0,0);
                    } else {
                        dir.normalize();
                        this.velocity.copy(dir).multiplyScalar(35);
                    }
                } else {
                    this.status.isCharging = 0; // Target died or expired
                }
            }

            if (isMyPlayer) {
                this.mesh.position.add(this.velocity.clone().multiplyScalar(delta));
            } else {
                this.mesh.position.lerp(this.networkTargetPosition, 0.25);
                this.mesh.position.add(this.velocity.clone().multiplyScalar(delta)); // Apply local velocity for prediction
            }

            this.velocity.multiplyScalar(1-15*delta); // Apply friction/damping
            this.mesh.position.x = Math.max(-arenaSize/2+1, Math.min(arenaSize/2-1, this.mesh.position.x));
            this.mesh.position.z = Math.max(-arenaSize/2+1, Math.min(arenaSize/2-1, this.mesh.position.z));

            if (opponent && !opponent.isDead) {
                this.aimDirection.subVectors(opponent.mesh.position, this.mesh.position).normalize();
                const lookAt=this.mesh.position.clone().add(this.aimDirection);
                lookAt.y=this.mesh.position.y;
                this.mesh.lookAt(lookAt);
            }

            this.collider.setFromObject(this.mesh);

            obstacles.forEach(obs=>{ if(this.collider.intersectsBox(obs)) this.resolveCollision(obs); });
            if(opponent && !opponent.isDead && this.collider.intersectsBox(opponent.collider)){
                // Handle specific collision effects (like Aegis Charge)
                if(this.status.isCharging > 0 && this.characterKey === 'AEGIS'){
                    opponent.takeDamage(25);
                    const kb=this.aimDirection.clone().multiplyScalar(20);
                    opponent.velocity.add(kb);
                    this.status.isCharging=0; // Stop charge on hit
                }
                // General collision resolution
                this.resolveCollision(opponent.collider, .5);
                opponent.resolveCollision(this.collider, .5);
            }

            this.rewindTimer += delta;
            if(this.rewindTimer > .25){ this.rewindTimer=0; this.rewindPositions.push({ pos:this.mesh.position.clone(), hp:this.hp, energy:this.energy }); if(this.rewindPositions.length>20) this.rewindPositions.shift(); }

            this.updateStatusVisuals();
            this.mesh.traverse(child=>{ if(child.isMesh && child.material){ child.material.transparent = this.status.cloaked>0; child.material.opacity = this.status.cloaked>0 ? .3 : 1; } });
        }

        updateStatusVisuals(){
            if(this.isDead) return;

            // Rooted visual
            if(this.status.rooted>0 && !this.statusMeshes.root){ const g=new THREE.TorusGeometry(1.2,.05,8,32), m=new THREE.MeshBasicMaterial({color:0xff0000}); const r=new THREE.Mesh(g,m); r.rotation.x=Math.PI/2; scene.add(r); this.statusMeshes.root=r; }
            else if(this.status.rooted<=0 && this.statusMeshes.root){ scene.remove(this.statusMeshes.root); this.statusMeshes.root.geometry.dispose(); this.statusMeshes.root.material.dispose(); this.statusMeshes.root=null; }
            if(this.statusMeshes.root){ this.statusMeshes.root.position.copy(this.mesh.position); this.statusMeshes.root.position.y=.1; }

            // Slowed visual
            if(this.status.slowed>0 && !this.statusMeshes.slow){ const g=new THREE.TorusGeometry(1.3,.05,8,32), m=new THREE.MeshBasicMaterial({color:0x0000ff}); const r=new THREE.Mesh(g,m); r.rotation.x=Math.PI/2; scene.add(r); this.statusMeshes.slow=r; }
            else if(this.status.slowed<=0 && this.statusMeshes.slow){ scene.remove(this.statusMeshes.slow); this.statusMeshes.slow.geometry.dispose(); this.statusMeshes.slow.material.dispose(); this.statusMeshes.slow=null; }
            if(this.statusMeshes.slow){ this.statusMeshes.slow.position.copy(this.mesh.position); this.statusMeshes.slow.position.y=.15; }

            // Rift buff visual
            if(this.status.riftBuff>0 && !this.riftLight){ this.riftLight=new THREE.PointLight(0xff00ff,5,5); this.mesh.add(this.riftLight); }
            else if(this.status.riftBuff<=0 && this.riftLight){ this.mesh.remove(this.riftLight); this.riftLight.dispose(); this.riftLight=null; }

            // Update individual status effect visuals
            Object.values(this.statusVisuals).forEach(v => v.update(0)); // Pass 0 delta as they check owner status directly
        }

        resolveCollision(otherBox, pushFactor=1.0){
            if (this.isDead) return;
            // Handle charge collision with pylons
            if(this.status.isCharging>0 && otherBox.isPylon && this.characterKey === 'AEGIS'){
                this.status.isCharging=0;
                this.status.rooted=1.5; // Stun self
                this.velocity.set(0,0,0);
                 specialObjects.push(new ParticleSystem(this.mesh.position, {count: 50, duration: 0.5, speed: 5})); // Impact effect
            }
            const cP=new THREE.Vector3(); this.collider.getCenter(cP);
            const cO=new THREE.Vector3(); otherBox.getCenter(cO);
            const sP=new THREE.Vector3(); this.collider.getSize(sP);
            const sO=new THREE.Vector3(); otherBox.getSize(sO);
            const dx=cO.x-cP.x, penX=(sP.x/2+sO.x/2)-Math.abs(dx);
            const dz=cO.z-cP.z, penZ=(sP.z/2+sO.z/2)-Math.abs(dz);
            if(penX>0 && penZ>0){
                 // Only push if not rooted or unstoppable (unless hitting another player)
                const canBePushed = (this.status.rooted <= 0 && this.status.unstoppable <= 0) || !otherBox.isPylon;
                if (canBePushed) {
                    if(penX<penZ) this.mesh.position.x -= penX*Math.sign(dx)*pushFactor;
                    else this.mesh.position.z -= penZ*Math.sign(dz)*pushFactor;
                    this.collider.setFromObject(this.mesh);
                }
            }
        }

        takeDamage(amount, isDoT=false){
            if (this.isDead) return;
            if(this.status.shielded>0 && !isDoT) return; // Status shield blocks non-DoT

            // Firewall passive check
            if (this.passive.name === "Firewall" && this.passiveState.firewallTimer <= 0 && !isDoT) {
                this.passiveState.firewallTimer = 20;
                specialObjects.push(new ShieldEffect(this, 1, 0xf0e68c));
                return; // Block the damage
            }

            if(this.status.spellShield>0 && !isDoT){ this.status.spellShield=0; return; } // Spell shield blocks
            if(this.status.parry>0 && !isDoT) { // Parry blocks and stuns attacker
                this.status.parry = 0;
                const opponent = window.players.find(p=>p!==this);
                if(opponent) opponent.status.rooted = 1.5;
                return;
            }

            let dmg=amount;
            if(this.status.corruption>0) dmg*=1.3; // Take more damage if corrupted
            if(this.status.empowered>0) dmg*=.7; // Take less damage if empowered

            this.hp = Math.max(0, this.hp - dmg);

            if(!isDoT){
                // Add floating damage text
                const damagePosition = this.mesh.position.clone().add(new THREE.Vector3(0, 3.5, 0)); // Position above head
                specialObjects.push(new FloatingDamageText(dmg, damagePosition));

                // Hit particle effect
                specialObjects.push(new ParticleSystem(this.mesh.position.clone().setY(2), {
                    count: 30, duration: 0.6, speed: 8, startColor: new THREE.Color(0xff0000), endColor: new THREE.Color(0x440000), startSize: 0.2, endSize: 0
                }));
                if(audioReady) sounds.hit.triggerAttackRelease("C2","8n");

                // --- DAMAGE FLASH LOGIC (V5.1 FIX) ---
                if (this.damageFlashTimeout) { clearTimeout(this.damageFlashTimeout); }
                if (!this.originalEmissives) {
                    this.originalEmissives = new Map();
                    this.mesh.traverse(c => {
                        if (c.isMesh && c.material && c.material.emissive) {
                            this.originalEmissives.set(c.uuid, c.material.emissive.getHex());
                        }
                    });
                }
                this.mesh.traverse(c => {
                    if (c.isMesh && c.material && c.material.emissive) {
                        c.material.emissive.setHex(0xffffff);
                    }
                });
                this.damageFlashTimeout = setTimeout(() => {
                    if (this.mesh && this.originalEmissives) {
                        this.mesh.traverse(c => {
                            if (c.isMesh && c.material && c.material.emissive && this.originalEmissives.has(c.uuid)) {
                                c.material.emissive.setHex(this.originalEmissives.get(c.uuid));
                            } else if (c.isMesh && c.material && c.material.emissive) {
                                c.material.emissive.setHex(0x000000); // Fallback
                            }
                        });
                    }
                    this.damageFlashTimeout = null;
                    this.originalEmissives = null;
                }, 150);
                // --- END DAMAGE FLASH LOGIC ---
            }
            if(this.hp<=0) this.die();
        }

        die(){
            if (this.isDead) return;
            this.isDead = true;
            this.hp = 0;

            // --- Restore Colors Immediately on Death (V5.1 Fix) ---
            if (this.damageFlashTimeout) {
                clearTimeout(this.damageFlashTimeout);
                this.damageFlashTimeout = null;
            }
            if (this.originalEmissives) {
                this.mesh.traverse(c => {
                    if (c.isMesh && c.material && c.material.emissive && this.originalEmissives.has(c.uuid)) {
                        c.material.emissive.setHex(this.originalEmissives.get(c.uuid));
                    } else if (c.isMesh && c.material && c.material.emissive) {
                        c.material.emissive.setHex(0x000000); // Fallback
                    }
                });
                this.originalEmissives = null;
            }
            // --- End Restore Colors ---

            // Death particle effect
            specialObjects.push(new ParticleSystem(this.mesh.position.clone().setY(2), {
                count: 200, duration: 1.5, speed: 12, startColor: new THREE.Color(this.mesh.children[0].material.color), endColor: new THREE.Color(0x000000), startSize: 0.25, endSize: 0
            }));
            if(audioReady) sounds.death.triggerAttackRelease("8n");

            this.mesh.visible = false; // Hide mesh

            // Clean up status visuals
            Object.values(this.statusMeshes).forEach(m=>{ if(m) scene.remove(m); });
            this.statusMeshes = {};
            if (this.riftLight) this.mesh.remove(this.riftLight);
            this.riftLight = null;

            // Clean up aura
            if (this.aura) {
                this.aura.destroy();
                const auraIndex = specialObjects.indexOf(this.aura);
                if(auraIndex > -1) specialObjects.splice(auraIndex, 1);
                this.aura = null;
            }

            endGame(this.playerNum===1?2:1); // Declare winner
        }

        destroy(){
             // --- Restore Colors Before Destroy (V5.1 Fix) ---
             if (this.damageFlashTimeout) {
                 clearTimeout(this.damageFlashTimeout);
                 this.damageFlashTimeout = null;
             }
             if (this.originalEmissives) {
                 // Traverse only if mesh exists
                 if (this.mesh) {
                     this.mesh.traverse(c => {
                         if (c.isMesh && c.material && c.material.emissive && this.originalEmissives.has(c.uuid)) {
                             c.material.emissive.setHex(this.originalEmissives.get(c.uuid));
                         }
                     });
                 }
                 this.originalEmissives = null;
             }
             // --- End Restore Colors ---

             if(this.mesh) {
                scene.remove(this.mesh);
                this.mesh.traverse(child => {
                   if (child.geometry) child.geometry.dispose();
                   if (child.material) {
                     if (Array.isArray(child.material)) {
                       child.material.forEach(mat => { if(mat && mat.dispose) mat.dispose(); });
                     } else {
                       if (child.material.dispose) child.material.dispose();
                     }
                   }
                });
                this.mesh = null; // Prevent errors if destroy is called again
             }

             // Clean up status visuals
             Object.values(this.statusMeshes).forEach(m=>{ if(m) { scene.remove(m); if(m.geometry) m.geometry.dispose(); if(m.material && typeof m.material.dispose === 'function') m.material.dispose();} });
             this.statusMeshes = {};

             // Clean up aura
             if (this.aura) {
                 this.aura.destroy();
                 const auraIndex = specialObjects.indexOf(this.aura);
                 if (auraIndex > -1) specialObjects.splice(auraIndex, 1);
                 this.aura = null;
             }

             // Clean up owned special objects
             for(let i=specialObjects.length-1;i>=0;i--){
                 if(specialObjects[i].owner===this){
                     if (typeof specialObjects[i].destroy === 'function') specialObjects[i].destroy();
                     specialObjects.splice(i,1);
                 }
             }
           }

        useSkill(skillKey) {
            if (this.isDead || this.cooldowns[skillKey] > 0 || this.status.silenced > 0) return;

            const skill = (skillKey === 'basicAttack') ? { cost: 0, cd: this.status.siege > 0 ? 1.5 : 0.5 } : this.skills[skillKey];
            if (!skill || this.energy < skill.cost) return;

            if (window.mode.isOnline) {
                window.pushSkillEvent(skillKey);
            }

            this.executeSkill(skillKey);
        }

        useSkillRemote(skillKey) {
            if (this.isDead) return;
            console.log(`Executing remote skill: ${skillKey} for player ${this.playerNum}`);
            this.executeSkill(skillKey, true);
        }

        applyPassiveCooldown(skillKey) {
            // Apply cooldown reduction passives here
            if (this.passive.name === "Time Flux" && skillKey !== 'basicAttack') {
                 this.cooldowns[skillKey] *= 0.95; // 5% CDR
            }
        }

        executeSkill(skillKey, isRemote = false) {
            if (this.isDead) return;

            const fireDir = this.aimDirection.clone();
            const opponent = window.players.find(p => p !== this);
            let bonusDamage = 0;
            let bonusRange = 0;

            // --- Passive Logic on Skill Use (Only for local player) ---
            if (!isRemote) {
                if (this.passive.name === "Way of the Blade" && skillKey !== 'basicAttack') {
                    this.passiveState.lastSkillTime = 3; // Buff lasts 3 seconds
                }
            }

            // --- Basic Attack Logic ---
            if (skillKey === 'basicAttack') {
                if (!isRemote) {
                    let atkSpeed = 1.0;
                    if (this.characterKey === 'MIRAGE') { // Emperor passive
                        atkSpeed = 1 + (this.passiveState.attackSpeedStacks || 0) * 0.2; // 20% per stack
                    }
                    this.cooldowns.basicAttack = (this.status.siege > 0 ? 1.5 : 0.5) / atkSpeed;
                    this.applyPassiveCooldown('basicAttack'); // Apply CDR passive if relevant

                    // --- Passive Logic on Basic Attack ---
                    if (this.passive.name === "Resonance") {
                        this.passiveState.resonanceStacks = (this.passiveState.resonanceStacks + 1) % 3;
                        if (this.passiveState.resonanceStacks === 0) {
                            bonusDamage += 15;
                            this.energy = Math.min(this.maxEnergy, this.energy + 10);
                        }
                    }
                    if (this.passive.name === "Shadowstrike" && opponent) {
                        const toOpponent = opponent.mesh.position.clone().sub(this.mesh.position).normalize();
                        const oppForward = new THREE.Vector3();
                        opponent.mesh.getWorldDirection(oppForward);
                        if (toOpponent.dot(oppForward) > 0.5) { // Attacking from behind-ish
                            bonusDamage += 10 * 0.15; // 15% of base 10 damage
                        }
                    }
                    if (this.passive.name === "Mana Burn" && opponent) {
                        opponent.energy = Math.max(0, opponent.energy - 5);
                    }
                    if (this.passive.name === "Way of the Blade" && this.passiveState.lastSkillTime > 0) {
                        bonusDamage += 10;
                        bonusRange += 1; // Add bonus range
                        this.passiveState.lastSkillTime = 0; // Consume buff
                    }
                    // Vortex passive: Apply Gravity Mark on basic attacks
                    if (this.passive.name === "Event Horizon" && opponent) {
                        // Apply gravity mark
                        if (opponent.status.gravityMarks !== undefined) {
                            opponent.status.gravityMarks++;
                        } else {
                            opponent.status.gravityMarks = 1;
                        }
                        opponent.status.gravityMarkTimer = 4; // 4 second duration
                    }
                }

                let damage = 10 + bonusDamage;
                if(this.status.siege > 0) damage = 25 + bonusDamage;
                if (this.passive.name === "Sharpshooter" && opponent) {
                    const dist = this.mesh.position.distanceTo(opponent.mesh.position);
                    damage *= (1 + Math.min(0.2, (dist / (arenaSize * 0.6)) * 0.2)); // Up to 20%
                }

                let effects = null; if(this.status.nextAttackVenom){ effects = { venom:3 }; this.status.nextAttackVenom=false; }
                if(this.attackType==='RANGED'){
                    const isPiercing = this.status.targetingArray > 0;
                    projectiles.push(new Projectile(this, fireDir, damage, 20, { effects, piercing:isPiercing }));
                } else { // Melee
                    if (opponent && !opponent.isDead && opponent.mesh.position.distanceTo(this.mesh.position) < (this.attackRange + bonusRange)) {
                        const vectorToOpponent = new THREE.Vector3().subVectors(opponent.mesh.position, this.mesh.position).normalize();
                        const forwardAngle = this.aimDirection.dot(vectorToOpponent);
                        if (forwardAngle > 0.5) { // Check if opponent is roughly in front
                            opponent.takeDamage(damage);
                            if(effects) Object.assign(opponent.status, effects);
                        }
                    }
                    specialObjects.push(new MeleeSlash(this, this.mesh.children[0].material.color));
                }
                return; // End execution for basic attack
            }

            // --- Other Skills Logic ---
            const skill = this.skills[skillKey];
            if (!skill) return;

            // Apply cost and cooldown only for the local player initiating the skill
            if (!isRemote) {
               if (this.energy < skill.cost) return; // Check energy again just in case
               this.energy -= skill.cost;
               this.cooldowns[skillKey] = skill.cd;
               this.applyPassiveCooldown(skillKey); // Apply relevant CDR passives
            }

            // --- Passive Trigger on Skill Use (before execution) ---
            if (this.passive.name === "Static Charge" && opponent) {
                this.passiveState.staticChargeStacks = (this.passiveState.staticChargeStacks || 0) + 1;
                if (this.passiveState.staticChargeStacks >= 3) {
                    this.passiveState.staticChargeStacks = 0;
                    opponent.status.rooted = 0.5; // Stun opponent
                }
            }

            console.log(`Executing ${skill.name} (${skillKey}) for player ${this.playerNum}`);

            switch (skill.name) {
              // --- S1 SKILLS ---
              case "Power Shot": projectiles.push(new Projectile(this, fireDir, 25, 25, {size: 0.4})); break;
              case "Aegis Charge": this.status.isCharging=.5; if(audioReady) sounds.charge.triggerAttackRelease("C3", "4n"); specialObjects.push(new PlayerAura(this, 100, 0xffffff, 10, 0.1)); break;
              case "Venom Blade": this.status.nextAttackVenom=true; specialObjects.push(new StatusAura(this, 3, 0x00ff00)); break;
              case "Targeting Array": this.status.targetingArray=5; specialObjects.push(new StatusAura(this,5, this.mesh.children[0].material.color.getHex())); break;
              case "Static Orb": projectiles.push(new Projectile(this, fireDir, 25, 20, { size:.6, life:2 })); break;
              case "Corruption": projectiles.push(new Projectile(this, fireDir, 5, 20, { effects:{ corruption:5 } })); break;
              case "Decimate": specialObjects.push(new Decimate(this)); break;
              case "Temporal Anomaly": projectiles.push(new Projectile(this, fireDir, 10, 15, { effects:{ slowed:3 } })); break;
              case "Empower": this.status.empowered=6; specialObjects.push(new StatusAura(this, 6, 0xffff00)); break;
              case "Tailwind": this.velocity.add(this.aimDirection.clone().multiplyScalar(-20)); specialObjects.push(new ParticleSystem(this.mesh.position.clone().setY(2), {count: 50, duration: 0.5, speed: 5, startColor: new THREE.Color(this.mesh.children[0].material.color)})); if(audioReady) sounds.teleport.triggerAttackRelease("C5","8n"); break;
              case "Feedback Loop": projectiles.push(new Projectile(this, fireDir, 10, 20, { effects:{ feedbackLoop:5 } })); break;
              case "Crushing Singularity": // Vortex S1
                  // Create projectile that spawns an orb on hit
                  projectiles.push(new Projectile(this, fireDir, 20, 25, {
                       size: 0.6,
                       life: 3.5, // Projectile lifespan
                       effects: { gravityMark: 1 }, // Apply mark on direct hit
                       // Custom destroy function for projectile to spawn the orb
                       onDestroy: (proj) => {
                           specialObjects.push(new CrushingSingularity(this, proj.mesh.position));
                       }
                  }));
                  break;
              case "Build Turret": specialObjects.push(new SentryTurret(this, this.mesh.position.clone())); break;
              case "Caustic Blast":
                  let slowDur = 2;
                  if (opponent && opponent.status.venom > 0) {
                      const stacks = Math.min(5, Math.floor(opponent.status.venom));
                      slowDur += stacks * 0.5; // Add 0.5s per venom stack
                  }
                  projectiles.push(new Projectile(this, fireDir, 15, 18, { effects: {slowed: slowDur, venom: 3} }));
                  break;
              case "Iaijutsu Dash": this.velocity.add(this.aimDirection.clone().multiplyScalar(30)); specialObjects.push(new MeleeSlash(this, this.mesh.children[0].material.color)); if(opponent && !opponent.isDead && opponent.mesh.position.distanceTo(this.mesh.position) < 5) opponent.takeDamage(15); break;

              // --- S2 SKILLS ---
              case "Phase Shift": this.velocity.add(this.aimDirection.clone().multiplyScalar(20)); specialObjects.push(new ParticleSystem(this.mesh.position.clone().setY(2), {count: 50, duration: 0.5, speed: 5, startColor: new THREE.Color(this.mesh.children[0].material.color)})); if(audioReady) sounds.teleport.triggerAttackRelease("C5","8n"); break;
              case "Energy Shield": this.status.shielded=5; specialObjects.push(new ShieldEffect(this,5,0xADD8E6)); break;
              case "Blink": const bp=this.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(8)); specialObjects.push(new ParticleSystem(this.mesh.position.clone().setY(2), {count: 50, duration: 0.5, speed: 5, startColor: new THREE.Color(this.mesh.children[0].material.color)})); this.mesh.position.copy(bp); specialObjects.push(new ParticleSystem(this.mesh.position.clone().setY(2), {count: 50, duration: 0.5, speed: 5, startColor: new THREE.Color(this.mesh.children[0].material.color)})); if(audioReady) sounds.teleport.triggerAttackRelease("C6","16n"); break;
              case "Slowing Mine": specialObjects.push(new SlowingMine(this, this.mesh.position.clone())); break;
              case "Ball Lightning": projectiles.push(new Projectile(this, fireDir, 12, 15, { size:.8, life:4, piercing:true })); break;
              case "Rewind": if(this.rewindPositions.length>0){ const st=this.rewindPositions[0]; specialObjects.push(new ParticleSystem(this.mesh.position.clone().setY(2), {count: 80, duration: 0.7, speed: 5, startColor: new THREE.Color(this.mesh.children[0].material.color)})); this.mesh.position.copy(st.pos); if(!isRemote) { this.hp=st.hp; this.energy=st.energy; } specialObjects.push(new ParticleSystem(this.mesh.position.clone().setY(2), {count: 80, duration: 0.7, speed: 5, startColor: new THREE.Color(0xffffff)})); } if(audioReady) sounds.teleport.triggerAttackRelease("A5","8n"); break;
              case "Tectonic Slam": specialObjects.push(new TectonicSlam(this)); break;
              case "Stasis Field": specialObjects.push(new StasisField(this, this.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(10)))); break;
              case "Sentry Turret": specialObjects.push(new SentryTurret(this, this.mesh.position.clone())); break;
              case "Wind Wall": const wp=this.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(3)); specialObjects.push(new WindWall(this, wp, this.mesh.quaternion)); break;
              case "Silence": projectiles.push(new Projectile(this, fireDir, 10, 20, { effects:{ silenced:3 } })); break;
              case "Graviton Pulse": // Vortex S2
                  // AoE damage and slow around self, applies mark
                  specialObjects.push(new ExpandingRing(this.mesh.position, this.mesh.children[0].material.color, 6, 0.4)); // Visual
                  players.forEach(p => {
                      if (p !== this && p && !p.isDead && p.mesh && p.mesh.position.distanceTo(this.mesh.position) < 6) {
                          p.takeDamage(15);
                          p.status.slowed = 3.0;
                          // Apply gravity mark
                          if (p.status.gravityMarks !== undefined) {
                              p.status.gravityMarks++;
                          } else {
                              p.status.gravityMarks = 1;
                          }
                          p.status.gravityMarkTimer = 4; // 4 second duration
                      }
                  });
                  if(audioReady) sounds.explosion.triggerAttackRelease("F3", "8n");
                  break;
              case "Barrier Wall": specialObjects.push(new BarrierWall(this, this.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(5)), this.mesh.quaternion)); break;
              case "Adrenal Haze": specialObjects.push(new AdrenalHaze(this)); break;
              case "Parry Stance": this.status.parry = 1.5; specialObjects.push(new ShieldEffect(this, 1.5, 0xffffff)); break;

              // --- S3 SKILLS ---
              case "Static Field": specialObjects.push(new StaticField(this)); break;
              case "Overload": specialObjects.push(new ExpandingRing(this.mesh.position, this.mesh.children[0].material.color, 8, .5)); specialObjects.push(new ParticleSystem(this.mesh.position, {count: 200, duration: 1.2, speed: 15, startColor: new THREE.Color(this.mesh.children[0].material.color), endColor: new THREE.Color(0xffffff)})); if(opponent && !opponent.isDead && opponent.mesh.position.distanceTo(this.mesh.position)<8){ opponent.takeDamage(40); } if(audioReady) sounds.explosion.triggerAttackRelease("G2","2n"); break;
              case "Cloak": this.status.cloaked=5; break;
              case "Laser Core": if(opponent && !opponent.isDead) specialObjects.push(new LaserCore(this, opponent)); if(audioReady) sounds.laser.triggerAttackRelease("C4","1n"); break;
              case "Cyclone": specialObjects.push(new Cyclone(this)); break;
              case "Swap": if(opponent && !opponent.isDead) { const my=this.mesh.position.clone(); specialObjects.push(new ParticleSystem(this.mesh.position.clone().setY(2), {count: 80, duration: 0.7, speed: 8, startColor: new THREE.Color(this.mesh.children[0].material.color)})); specialObjects.push(new ParticleSystem(opponent.mesh.position.clone().setY(2), {count: 80, duration: 0.7, speed: 8, startColor: new THREE.Color(opponent.mesh.children[0].material.color)})); this.mesh.position.copy(opponent.mesh.position); opponent.mesh.position.copy(my); } if(audioReady) sounds.teleport.triggerAttackRelease("F4","8n"); break;
              case "Unstoppable Force": this.status.unstoppable=4; this.status.isCharging=.5; specialObjects.push(new PlayerAura(this, 150, 0xff0000, 15, 0.2)); if(audioReady) sounds.charge.triggerAttackRelease("A2", "4n"); break;
              case "Implosion": // Vortex S3
                  if(opponent && !opponent.isDead) {
                      // Mark opponent for implosion
                      opponent.status.implosionTarget = this; // Store reference to caster
                      opponent.status.implosionTimer = 4; // 4 second delay before detonation (increased from 3)
                      specialObjects.push(new ImplosionEffect(this, opponent)); // Visual marker
                      
                      // Apply initial damage and gravity mark
                      opponent.takeDamage(15); // Initial damage
                      if (opponent.status.gravityMarks !== undefined) {
                          opponent.status.gravityMarks++;
                      } else {
                          opponent.status.gravityMarks = 1;
                      }
                      opponent.status.gravityMarkTimer = 4; // 4 second duration
                  }
                  break;
              case "Bastion Protocol": this.status.shielded=10; specialObjects.push(new ShieldEffect(this,10,0xffffff)); break;
              case "Spell Shield": this.status.spellShield=10; specialObjects.push(new ShieldEffect(this,10,0xa020f0)); break;
              case "Siege Mode": this.status.siege = 10; this.status.rooted = 10; specialObjects.push(new StatusAura(this, 10, 0xff8c00)); break;
              case "Blade Fury": specialObjects.push(new BladeFury(this)); break;

              // --- EMPEROR (MIRAGE) SKILLS ---
              case "Arise!":
                const soldiers = specialObjects.filter(o => o instanceof SandSoldier && o.owner === this);
                if (soldiers.length >= 3) { // Max 3 soldiers
                    // Despawn the oldest one
                    const oldestSoldier = soldiers.sort((a, b) => (b.initialDuration - b.duration) - (a.initialDuration - a.duration))[0]; // Find oldest by elapsed time
                    if (oldestSoldier) oldestSoldier.duration = 0;
                }
                const spawnPos = this.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(4));
                specialObjects.push(new SandSoldier(this, spawnPos));
                break;
              case "Conquering Sands":
                 // Send ALL soldiers dashing
                specialObjects.forEach(o => {
                    if (o instanceof SandSoldier && o.owner === this) {
                       const dashPos = o.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(10));
                       o.dashTo(dashPos);
                    }
                });
                break;
              case "Shifting Sands":
                const closestSoldier = specialObjects
                    .filter(o => o instanceof SandSoldier && o.owner === this)
                    .sort((a, b) => a.mesh.position.distanceTo(this.mesh.position) - b.mesh.position.distanceTo(this.mesh.position))[0];

                if (closestSoldier) {
                    this.status.isCharging = 0.5; // Dash duration
                    this.status.dashTarget = closestSoldier; // Store soldier as target
                }
                break;

              // --- S4 SKILLS (ULTIMATES) ---
              case "Overcharge": this.status.empowered = 8; this.energy = Math.min(this.maxEnergy, this.energy + 50); specialObjects.push(new StatusAura(this, 8, 0x00ffff)); if(audioReady) sounds.ult.triggerAttackRelease("C5", "1n"); break;
              case "Righteous Stand": this.status.shielded = 6; this.status.rooted = 6; specialObjects.push(new ShieldEffect(this, 6, 0xffa500)); if(audioReady) sounds.ult.triggerAttackRelease("G3", "1n"); break;
              case "Death Mark": if(opponent && !opponent.isDead) { opponent.status.corruption = 10; opponent.status.venom = 10; } if(audioReady) sounds.ult.triggerAttackRelease("A2", "1n"); break;
              case "Orbital Strike": specialObjects.push(new OrbitalStrikeMarker(this, this.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(15)))); if(audioReady) sounds.ult.triggerAttackRelease("E2", "1n"); break;
              case "Eye of the Storm": specialObjects.push(new Thunderstorm(this)); if(audioReady) sounds.ult.triggerAttackRelease("F3", "1n"); break; // Renamed from Tempest's old S3 name
              case "System Crash": if(opponent && !opponent.isDead) { opponent.takeDamage(30); opponent.energy = 0; opponent.status.silenced = 4; } specialObjects.push(new ExpandingRing(this.mesh.position, this.mesh.children[0].material.color, 12, 0.8)); if(audioReady) sounds.ult.triggerAttackRelease("D2", "1n"); break;
              case "Pulverize": { const targetPos = this.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(12)); specialObjects.push(new PulverizeLeap(this, targetPos)); if(audioReady) sounds.ult.triggerAttackRelease("C2", "1n"); break; } // Target position in front
              case "Time Stop": specialObjects.push(new TimeStopEffect(this, 4)); if(audioReady) sounds.ult.triggerAttackRelease("G5", "1n"); break;
              case "Salvation": if(this.hp < this.maxHp) { this.hp = Math.min(this.maxHp, this.hp + 70); } specialObjects.push(new ExpandingRing(this.mesh.position, 0xffffff, 8, 1)); if(audioReady) sounds.ult.triggerAttackRelease("A4", "1n"); break;
              case "Gale Force": specialObjects.push(new GaleForceTornado(this, this.aimDirection.clone())); if(audioReady) sounds.ult.triggerAttackRelease("B3", "1n"); break;
              case "Energy Void": if(opponent && !opponent.isDead) { const drain = opponent.energy * 0.6; opponent.energy -= drain; this.energy = Math.min(this.maxEnergy, this.energy + drain); opponent.takeDamage(drain * 0.5); specialObjects.push(new ExpandingRing(opponent.mesh.position, this.mesh.children[0].material.color, 6, 1));} if(audioReady) sounds.ult.triggerAttackRelease("F2", "1n"); break;
              case "Black Hole": { // Vortex S4
                  const targetPosBH = this.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(15)); // Cast range 15 units
                  // Clamp targetPos within arena bounds
                  const halfArenaBH = arenaSize / 2 - 3; // Keep edge margin for effect (radius 3)
                  targetPosBH.x = Math.max(-halfArenaBH, Math.min(halfArenaBH, targetPosBH.x));
                  targetPosBH.z = Math.max(-halfArenaBH, Math.min(halfArenaBH, targetPosBH.z));
                  specialObjects.push(new BlackHole(this, targetPosBH)); // Create Black Hole object
                  
                  // Apply gravity marks to all players in range when cast
                  window.players.forEach(p => {
                      if (p !== this && !p.isDead && p.mesh.position.distanceTo(targetPosBH) < 20) {
                          // Apply 2 gravity marks to each player in range
                          if (p.status.gravityMarks !== undefined) {
                              p.status.gravityMarks += 2;
                          } else {
                              p.status.gravityMarks = 2;
                          }
                          p.status.gravityMarkTimer = 4; // 4 second duration
                      }
                  });
                  
                  if(audioReady) sounds.ult.triggerAttackRelease("A1", "1n"); // Deep ult sound
                  } break;
              case "Emperor's Divide":
                const wallPos = this.mesh.position.clone().add(this.aimDirection.clone().multiplyScalar(4));
                specialObjects.push(new SoldierWall(this, wallPos, this.mesh.quaternion.clone()));
                if(audioReady) sounds.ult.triggerAttackRelease("D3", "1n");
                break;
              case "Anvil Turret": specialObjects.push(new AnvilTurret(this, this.mesh.position.clone())); if(audioReady) sounds.ult.triggerAttackRelease("C4", "1n"); break;
              case "Plague Cloud": specialObjects.push(new PlagueCloud(this)); if(audioReady) sounds.ult.triggerAttackRelease("G2", "1n"); break;
              case "Shadow Strike":
                const targets = [];
                if(opponent && !opponent.isDead) { targets.push(opponent); }
                // Add other potential targets like turrets or soldiers if desired
                if (targets.length > 0) {
                    specialObjects.push(new ShadowStrikeDash(this, targets));
                }
                if(audioReady) sounds.ult.triggerAttackRelease("C5", "1n");
                break;
            }
        }
    }


    /********** Game flow functions **********/
    window.startGame = function startGame(p1CharKey, p2CharKey) {
      if(CCA.flow.gameState === 'ACTIVE') return;
      console.log(`Starting game: P1 (${p1CharKey}) vs P2 (${p2CharKey})`);
      CCA.flow.gameState = 'ACTIVE';
      if(window.mode.isOnline) {
          if (window.mode.onlineState.isHost) {
              CCA.online.setStarted(window.mode.onlineState.code);
          }
      }

      window.players = [ new Player(1, p1CharKey), new Player(2, p2CharKey) ];
      // Reset camera to game view
      camera.position.set(0, 30, 25);
      camera.lookAt(0, 0, 0);
      controls.target.set(0, 0, 0); // Reset orbit controls target

      controls.enabled = false; // Disable camera controls during game
      controls.autoRotate = false; // Disable auto-rotation

      buildPlayerHUD(1, CHARACTERS[p1CharKey]);
      buildPlayerHUD(2, CHARACTERS[p2CharKey]);

      if (window.mode.current.rift) {
        specialObjects.push(new Rift());
      }

      switchScreen(null);
      document.getElementById('ui-container').style.opacity = '1';

      let count = 3;
      document.getElementById('countdown-text').textContent = count;
      document.getElementById('game-message-container').style.display = 'flex';

      const i = setInterval(() => {
        count--;
        if (count > 0) {
          document.getElementById('countdown-text').textContent = count;
        } else {
          clearInterval(i);
          document.getElementById('countdown-text').textContent = 'FIGHT!';
          if (CCA.flow.tutorialActive && CCA.flow.tutorialStep === 4) {
              updateTutorial(5);
          }
          setTimeout(() => {
            document.getElementById('game-message-container').style.display = 'none';
          }, 1000);
        }
      }, 1000);
    }

    let gameEnded = false;
    window.endGame = function endGame(winnerNum) {
      if (gameEnded || CCA.flow.gameState === 'GAME_OVER') return;
      gameEnded = true;
      CCA.flow.gameState = 'GAME_OVER';

      console.log(`Game over. Winner: Player ${winnerNum}`);
      const winner = window.players.find(p => p.playerNum === winnerNum); // Find winner robustly
      // const loser = window.players.find(p => p.playerNum !== winnerNum);
      const p1Nick = window.loggedInUsers.p1 || 'Player 1';
      const p2Nick = window.loggedInUsers.p2 || 'Player 2';

      const winnerName = (winnerNum === 1) ? p1Nick : p2Nick;
      document.getElementById('winner-text').innerHTML = `${winnerName} WINS!`;

      // --- Add Win Logic (Simplified) ---
       if (!CCA.flow.isGuest && CCA.playersMeta.loggedInUser) {
           let won = false;
           if (window.mode.isOnline) {
               const { isHost } = window.mode.onlineState;
               won = (isHost && winnerNum === 1) || (!isHost && winnerNum === 2);
           } else {
               // Assuming local game win tracking might be desired, though not implemented fully.
               // For now, only track online wins based on host/guest status.
               // Add local win tracking if needed.
           }

           if (won) {
               window.addWin(CCA.playersMeta.loggedInUser.uid, window.mode.current.key);
           }

           // Only host sets winner in Firestore for online matches
           if (window.mode.isOnline && window.mode.onlineState.isHost && online.code) {
               CCA.online.setWinner(window.mode.onlineState.code, winnerNum)
                 .catch(e => console.error("Error setting winner:", e));
           }
       }
       // --- End Add Win Logic ---


      setTimeout(() => {
        switchScreen('game-over-screen');
        controls.enabled = true; // Re-enable camera controls
        controls.autoRotate = true; // Re-enable auto-rotation
      }, 2000);
    }

    document.getElementById('restart-button').addEventListener('click', () => {
        resetGame(true);
    });

    function resetGame(returnToMenu = false) {
        console.log("Resetting game...");
        gameEnded = false;
        CCA.flow.gameState = 'START_SCREEN'; // Go to start screen first

        window.players.forEach(p => p.destroy());
        window.players = [];

        projectiles.forEach(p => p.destroy());
        projectiles = [];

        for(let i=specialObjects.length-1;i>=0;i--){
            if (typeof specialObjects[i].destroy === 'function') {
                specialObjects[i].destroy();
            }
        }
        specialObjects = [];

        p1Select = -1; p2Select = -1; p1Locked = false; p2Locked = false;

        $$('player1-hud').innerHTML = '';
        $$('player2-hud').innerHTML = '';
        // Clear HUD renderers data
         for (const key in hudScenes) {
            if (hudScenes[key]) {
                // Properly dispose of scene resources if needed
                 hudScenes[key].traverse(obj => {
                     if (obj.geometry) obj.geometry.dispose();
                     if (obj.material) {
                         if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                         else obj.material.dispose();
                     }
                 });
            }
         }
        hudScenes = { p1: null, p2: null };
        hudCameras = { p1: null, p2: null };
        hudModels = { p1: null, p2: null };


        document.getElementById('ui-container').style.opacity = '0';
        document.getElementById('game-message-container').style.display = 'none';

        if(window.mode.isOnline) {
            if(online.unsub) { online.unsub(); online.unsub = null; }
            if(eventsListenerUnsub) { eventsListenerUnsub(); eventsListenerUnsub = null; }

            // FIX: Only host deletes room
            if(online.code && online.isHost) {
                 deleteDoc(doc(ROOMS, online.code)).catch(e => console.error("Error deleting room:", e));
            }
            online = { code:null, isHost:false, unsub:null, ready:false };
        }

        controls.enabled = true; // Ensure camera controls are enabled when returning to menu
        controls.autoRotate = true; // Ensure auto-rotation is enabled

        if (returnToMenu) {
            switchScreen('start-screen');
            $$('room-status').textContent = '';
            $$('find-match-button').disabled = false;
            $$('cancel-match-button').style.display = 'none';
        } else {
            switchScreen('login-screen'); // Should ideally not happen often, maybe on error?
        }
    }

    /********** Main loop **********/
    function animate() {
      requestAnimationFrame(animate);
      const delta = Math.min(0.05, clock.getDelta()); // Cap delta

      // Update camera controls if enabled (includes auto-rotate)
      controls.update(); // MUST be called each frame for damping and auto-rotate

      if (CCA.flow.gameState === 'ACTIVE') {
        const p1 = window.players[0];
        const p2 = window.players[1];

        if (p1 && p2) {
            p1.update(delta, p2);
            p2.update(delta, p1);
        }

        projectiles.forEach(p => p.update(delta));

        // Iterate backwards for safe removal during iteration
        for(let i=specialObjects.length-1; i>=0; i--){
            const o = specialObjects[i];
            if (o) { // Check if object exists (might be null if destroyed mid-loop?)
                o.update(delta, window.players, projectiles);
                if(o.duration <= 0){
                    if (typeof o.destroy === 'function') o.destroy(); // Ensure destroy exists
                    specialObjects.splice(i,1);
                }
            } else {
                 specialObjects.splice(i,1); // Remove null/undefined entries if they appear
            }
        }

        updateUI();
        updateMinimap(); // Update minimap only during active game
      } else {
        // --- Ensure controls are enabled outside of game ---
        if (!controls.enabled) {
            controls.enabled = true;
        }
         if (!controls.autoRotate) {
             controls.autoRotate = true; // Keep rotating in menus
         }
      }

      // Render main scene with composer
      composer.render(delta);

      // Render HUDs separately only during active game
      if (CCA.flow.gameState === 'ACTIVE') {
        renderHUDs(delta);
      }
    }

    // Set initial camera position for menu view
    camera.position.set(0, 25, 35);
    camera.lookAt(0, 0, 0);
    animate(); // Start the loop

    /********** Event listeners **********/
    window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        keys[key] = true;

        // Handle local player skill activation
        if (CCA.flow.gameState === 'ACTIVE' && !window.mode.isOnline) {
            const p1c = controlsP1P2.p1; // Use renamed controls variable
            const p2c = controlsP1P2.p2; // Use renamed controls variable
            const p1 = window.players[0];
            const p2 = window.players[1];

            if (p1) {
                if (key === p1c.basicAttack) p1.useSkill('basicAttack');
                else if (key === p1c.skill1) p1.useSkill('s1');
                else if (key === p1c.skill2) p1.useSkill('s2');
                else if (key === p1c.skill3) p1.useSkill('s3');
                else if (key === p1c.skill4) p1.useSkill('s4');
            }
            if (p2) {
                if (key === p2c.basicAttack) p2.useSkill('basicAttack');
                else if (key === p2c.skill1) p2.useSkill('s1');
                else if (key === p2c.skill2) p2.useSkill('s2');
                else if (key === p2c.skill3) p2.useSkill('s3');
                else if (key === p2c.skill4) p2.useSkill('s4');
            }

            if (CCA.flow.tutorialActive && CCA.flow.tutorialStep === 7 && key === p1c.basicAttack) {
                updateTutorial(8);
                setTimeout(() => updateTutorial(9), 8000); // Advance after 8s
                setTimeout(() => updateTutorial(10), 14000); // Advance after 14s
            }
        }

        // Handle online player skill activation (always P1 controls)
        if (CCA.flow.gameState === 'ACTIVE' && window.mode.isOnline) {
            const c = controlsP1P2.p1; // Use renamed controls variable
            const me = window.mode.onlineState.isHost ? window.players[0] : window.players[1];

            if (me) {
                if (key === c.basicAttack) me.useSkill('basicAttack');
                else if (key === c.skill1) me.useSkill('s1');
                else if (key === c.skill2) me.useSkill('s2');
                else if (key === c.skill3) me.useSkill('s3');
                else if (key === c.skill4) me.useSkill('s4');
            }
        }
    });

    window.addEventListener('keyup', (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
    });


    // --- IMPORT/EXPORT LEADERBOARD ---
    // (Local data only, for sharing snapshots)

    function exportLeaderboardSnapshot() {
        const modes = Object.keys(MODES);
        const allData = {};
        const promises = modes.map(async (modeKey) => {
            try {
                const q = query(collection(db, "leaderboards", modeKey, "scores"), orderBy("wins", "desc"), limit(100));
                const snap = await getDocs(q);
                const scores = snap.docs.map(d => ({
                    id: d.id,
                    nickname: d.data().nickname,
                    wins: d.data().wins
                }));
                allData[modeKey] = scores;
            } catch (e) {
                console.error(`Failed to fetch ${modeKey} for export:`, e);
            }
        });

        Promise.all(promises).then(() => {
            const json = JSON.stringify(allData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chroma-core-leaderboard-snapshot-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            $$('leaderboard-message').textContent = 'Snapshot exported!';
        });
    }

    async function importLeaderboardSnapshot() {
        const json = $$('import-data-area').value;
        if (!json) {
            $$('leaderboard-message').textContent = 'Paste snapshot data into the text area first.';
            return;
        }

        let data;
        try {
            data = JSON.parse(json);
        } catch (e) {
            $$('leaderboard-message').textContent = 'Error: Invalid JSON data.';
            return;
        }

        if (typeof data !== 'object' || data === null) {
            $$('leaderboard-message').textContent = 'Error: Invalid snapshot format.';
            return;
        }

        $$('leaderboard-message').textContent = 'Importing... This may take a moment.';
        $$('import-leaderboard-button').disabled = true;

        try {
            const batch = writeBatch(db);
            let operations = 0;

            for (const modeKey in data) {
                if (MODES[modeKey] && Array.isArray(data[modeKey])) {
                    console.log(`Importing ${modeKey}...`);
                    for (const entry of data[modeKey]) {
                        if (entry.id && entry.nickname && typeof entry.wins === 'number') {
                            const lbRef = doc(db, "leaderboards", modeKey, "scores", entry.id);
                            batch.set(lbRef, {
                                nickname: entry.nickname,
                                wins: entry.wins,
                                updatedAt: serverTimestamp()
                            }, { merge: true });
                            operations++;
                        }
                    }
                }
            }

            if (operations > 0) {
                await batch.commit();
                $$('leaderboard-message').textContent = `Successfully imported ${operations} entries! Reloading current tab...`;
                loadLeaderboard($$('#lb-tabs .tab.active').dataset.lb);
            } else {
                $$('leaderboard-message').textContent = 'No valid entries found in snapshot.'; // Corrected ID
            }

        } catch (e) {
            console.error("Import failed:", e);
            $$('leaderboard-message').textContent = 'Error during import. Check console.';
        } finally {
            $$('import-leaderboard-button').disabled = false;
        }
    }

    $$('export-leaderboard-button').addEventListener('click', exportLeaderboardSnapshot);
    $$('import-leaderboard-button').addEventListener('click', importLeaderboardSnapshot);

  </script>
</body>
</html>

